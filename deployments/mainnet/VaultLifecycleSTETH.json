{
  "address": "0x5CbB58FBd5E53A8db156C1261403b14dc618F3db",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "currentShareSupply",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "currentBalance",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "bool",
              "name": "isPut",
              "type": "bool"
            },
            {
              "internalType": "uint8",
              "name": "decimals",
              "type": "uint8"
            },
            {
              "internalType": "address",
              "name": "asset",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "underlying",
              "type": "address"
            },
            {
              "internalType": "uint56",
              "name": "minimumSupply",
              "type": "uint56"
            },
            {
              "internalType": "uint104",
              "name": "cap",
              "type": "uint104"
            }
          ],
          "internalType": "struct Vault.VaultParams",
          "name": "vaultParams",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "round",
              "type": "uint16"
            },
            {
              "internalType": "uint104",
              "name": "lockedAmount",
              "type": "uint104"
            },
            {
              "internalType": "uint104",
              "name": "lastLockedAmount",
              "type": "uint104"
            },
            {
              "internalType": "uint128",
              "name": "totalPending",
              "type": "uint128"
            },
            {
              "internalType": "uint128",
              "name": "queuedWithdrawShares",
              "type": "uint128"
            }
          ],
          "internalType": "struct Vault.VaultState",
          "name": "vaultState",
          "type": "tuple"
        }
      ],
      "name": "rollover",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "newLockedAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "queuedWithdrawAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "newPricePerShare",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "mintShares",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x597441b33cec395e6c1259e8262ea3155f14975a919e06849a0efb14ac632371",
  "receipt": {
    "to": null,
    "from": "0x691c87dc570563D1D0AD7Fd0bb099ED367858863",
    "contractAddress": "0x5CbB58FBd5E53A8db156C1261403b14dc618F3db",
    "transactionIndex": 44,
    "gasUsed": "2361205",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x4145e3e1729939c0b382e2e2684db83bcc7b61418559c3ed9c4fea3fec1594d1",
    "transactionHash": "0x597441b33cec395e6c1259e8262ea3155f14975a919e06849a0efb14ac632371",
    "logs": [],
    "blockNumber": 13676568,
    "cumulativeGasUsed": "5038911",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "d15e1612820563ab5ca0548612c4c8f1",
  "metadata": "{\"compiler\":{\"version\":\"0.8.4+commit.c7e474f2\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"currentShareSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentBalance\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isPut\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"underlying\",\"type\":\"address\"},{\"internalType\":\"uint56\",\"name\":\"minimumSupply\",\"type\":\"uint56\"},{\"internalType\":\"uint104\",\"name\":\"cap\",\"type\":\"uint104\"}],\"internalType\":\"struct Vault.VaultParams\",\"name\":\"vaultParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"round\",\"type\":\"uint16\"},{\"internalType\":\"uint104\",\"name\":\"lockedAmount\",\"type\":\"uint104\"},{\"internalType\":\"uint104\",\"name\":\"lastLockedAmount\",\"type\":\"uint104\"},{\"internalType\":\"uint128\",\"name\":\"totalPending\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"queuedWithdrawShares\",\"type\":\"uint128\"}],\"internalType\":\"struct Vault.VaultState\",\"name\":\"vaultState\",\"type\":\"tuple\"}],\"name\":\"rollover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newLockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"queuedWithdrawAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newPricePerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintShares\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"commitAndClose(address,address,uint256,VaultLifecycle.CloseParams,Vault.VaultParams storage,Vault.VaultState storage,address)\":{\"params\":{\"closeParams\":\"is the struct with details on previous option and strike selection details\",\"collateralAsset\":\"is the address of the collateral asset\",\"optionsPremiumPricer\":\"is the address of the contract with the black-scholes premium calculation logic\",\"premiumDiscount\":\"is the vault's discount applied to the premium\",\"strikeSelection\":\"is the address of the contract with strike selection logic\",\"vaultParams\":\"is the struct with vault general data\",\"vaultState\":\"is the struct with vault accounting state\"},\"returns\":{\"delta\":\"is the delta of the new option\",\"otokenAddress\":\"is the address of the new option\",\"premium\":\"is the premium of the new option\",\"strikePrice\":\"is the strike price of the new option\"}},\"createShort(address,address,address,uint256)\":{\"params\":{\"depositAmount\":\"is the amount of collateral to deposit\",\"gammaController\":\"is the address of the opyn controller contract\",\"marginPool\":\"is the address of the opyn margin contract which holds the collateral\",\"oTokenAddress\":\"is the address of the otoken to mint\"},\"returns\":{\"_0\":\"the otoken mint amount\"}},\"rollover(uint256,uint256,Vault.VaultParams,Vault.VaultState)\":{\"params\":{\"currentBalance\":\"is the total balance of the vault\",\"currentShareSupply\":\"is the total supply of shares\",\"vaultParams\":\"is the struct with vault general data\",\"vaultState\":\"is the struct with vault accounting state\"},\"returns\":{\"mintShares\":\"is the amount of shares to mint from deposits\",\"newLockedAmount\":\"is the amount of funds to allocate for the new round\",\"newPricePerShare\":\"is the price per share of the new round\",\"queuedWithdrawAmount\":\"is the amount of funds set aside for withdrawal\"}},\"transferAsset(address,uint256)\":{\"params\":{\"amount\":\"is the transfer amount\",\"recipient\":\"is the receiving address\"}},\"unwrapYieldToken(uint256,address,address,address,uint256)\":{\"params\":{\"amount\":\"is the amount of ETH to withdraw\",\"crvPool\":\"is the address of the steth <-> eth pool on curve\",\"minETHOut\":\"is the minimum eth amount to receive from the swap\",\"stethToken\":\"is the address of stETH\",\"wstEth\":\"is the address of wstETH\"},\"returns\":{\"_0\":\"amountETHOut is the amount of eth unwrapped available for the withdrawal (may incur curve slippage)\"}},\"withdrawYieldAndBaseToken(address,address,address,uint256)\":{\"params\":{\"amount\":\"is the withdraw amount in `asset`\",\"collateralToken\":\"is the address of the collateral token\",\"recipient\":\"is the recipient\",\"weth\":\"is the WETH address\"},\"returns\":{\"_0\":\"withdrawAmount is the withdraw amount in `collateralToken`\"}},\"wrapToYieldToken(address,address,address)\":{\"params\":{\"collateralToken\":\"is the address of the collateral token\",\"weth\":\"is the address of weth\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"commitAndClose(address,address,uint256,VaultLifecycle.CloseParams,Vault.VaultParams storage,Vault.VaultState storage,address)\":{\"notice\":\"Sets the next option the vault will be shorting, and calculates its premium for the auction\"},\"createShort(address,address,address,uint256)\":{\"notice\":\"Creates the actual Opyn short position by depositing collateral and minting otokens\"},\"rollover(uint256,uint256,Vault.VaultParams,Vault.VaultState)\":{\"notice\":\"Calculate the shares to mint, new price per share, and amount of funds to re-allocate as collateral for the new round\"},\"transferAsset(address,uint256)\":{\"notice\":\"Helper function to make either an ETH transfer or ERC20 transfer\"},\"unwrapYieldToken(uint256,address,address,address,uint256)\":{\"notice\":\"Unwraps the necessary amount of the wstETH token         and transfers ETH amount to vault\"},\"withdrawYieldAndBaseToken(address,address,address,uint256)\":{\"notice\":\"Withdraws stETH + WETH (if necessary) from vault using vault shares\"},\"wrapToYieldToken(address,address,address)\":{\"notice\":\"Wraps the necessary amount of the base token to the yield-bearing yearn token\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/VaultLifecycleSTETH.sol\":\"VaultLifecycleSTETH\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x027b891937d20ccf213fdb9c31531574256de774bda99d3a70ecef6e1913ed2a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x02348b2e4b9f3200c7e3907c5c2661643a6d8520e9f79939fbb9b4005a54894d\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3336baae5cf23e94274d75336e2d412193be508504aee185e61dc7d58cd05c8a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8666f020bd8fc9dc14f07e2ebc52b5f236ab4cdde7c77679b08cb2f94730043b\",\"license\":\"MIT\"},\"contracts/interfaces/GammaInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nlibrary GammaTypes {\\n    // vault is a struct of 6 arrays that describe a position a user has, a user can have multiple vaults.\\n    struct Vault {\\n        // addresses of oTokens a user has shorted (i.e. written) against this vault\\n        address[] shortOtokens;\\n        // addresses of oTokens a user has bought and deposited in this vault\\n        // user can be long oTokens without opening a vault (e.g. by buying on a DEX)\\n        // generally, long oTokens will be 'deposited' in vaults to act as collateral\\n        // in order to write oTokens against (i.e. in spreads)\\n        address[] longOtokens;\\n        // addresses of other ERC-20s a user has deposited as collateral in this vault\\n        address[] collateralAssets;\\n        // quantity of oTokens minted/written for each oToken address in shortOtokens\\n        uint256[] shortAmounts;\\n        // quantity of oTokens owned and held in the vault for each oToken address in longOtokens\\n        uint256[] longAmounts;\\n        // quantity of ERC-20 deposited as collateral in the vault for each ERC-20 address in collateralAssets\\n        uint256[] collateralAmounts;\\n    }\\n}\\n\\ninterface IOtoken {\\n    function underlyingAsset() external view returns (address);\\n\\n    function strikeAsset() external view returns (address);\\n\\n    function collateralAsset() external view returns (address);\\n\\n    function strikePrice() external view returns (uint256);\\n\\n    function expiryTimestamp() external view returns (uint256);\\n\\n    function isPut() external view returns (bool);\\n}\\n\\ninterface IOtokenFactory {\\n    function getOtoken(\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        address _collateralAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiry,\\n        bool _isPut\\n    ) external view returns (address);\\n\\n    function createOtoken(\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        address _collateralAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiry,\\n        bool _isPut\\n    ) external returns (address);\\n\\n    function getTargetOtokenAddress(\\n        address _underlyingAsset,\\n        address _strikeAsset,\\n        address _collateralAsset,\\n        uint256 _strikePrice,\\n        uint256 _expiry,\\n        bool _isPut\\n    ) external view returns (address);\\n\\n    event OtokenCreated(\\n        address tokenAddress,\\n        address creator,\\n        address indexed underlying,\\n        address indexed strike,\\n        address indexed collateral,\\n        uint256 strikePrice,\\n        uint256 expiry,\\n        bool isPut\\n    );\\n}\\n\\ninterface IController {\\n    // possible actions that can be performed\\n    enum ActionType {\\n        OpenVault,\\n        MintShortOption,\\n        BurnShortOption,\\n        DepositLongOption,\\n        WithdrawLongOption,\\n        DepositCollateral,\\n        WithdrawCollateral,\\n        SettleVault,\\n        Redeem,\\n        Call,\\n        Liquidate\\n    }\\n\\n    struct ActionArgs {\\n        // type of action that is being performed on the system\\n        ActionType actionType;\\n        // address of the account owner\\n        address owner;\\n        // address which we move assets from or to (depending on the action type)\\n        address secondAddress;\\n        // asset that is to be transfered\\n        address asset;\\n        // index of the vault that is to be modified (if any)\\n        uint256 vaultId;\\n        // amount of asset that is to be transfered\\n        uint256 amount;\\n        // each vault can hold multiple short / long / collateral assets\\n        // but we are restricting the scope to only 1 of each in this version\\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\\n        uint256 index;\\n        // any other data that needs to be passed in for arbitrary function calls\\n        bytes data;\\n    }\\n\\n    struct RedeemArgs {\\n        // address to which we pay out the oToken proceeds\\n        address receiver;\\n        // oToken that is to be redeemed\\n        address otoken;\\n        // amount of oTokens that is to be redeemed\\n        uint256 amount;\\n    }\\n\\n    function getPayout(address _otoken, uint256 _amount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function operate(ActionArgs[] calldata _actions) external;\\n\\n    function getAccountVaultCounter(address owner)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function oracle() external view returns (address);\\n\\n    function getVault(address _owner, uint256 _vaultId)\\n        external\\n        view\\n        returns (GammaTypes.Vault memory);\\n\\n    function getProceed(address _owner, uint256 _vaultId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function isSettlementAllowed(\\n        address _underlying,\\n        address _strike,\\n        address _collateral,\\n        uint256 _expiry\\n    ) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x41ed736eb79c71ea59fadcc23cfbc4ff1ccb802458ede6bd69b18e5abdcefdce\",\"license\":\"MIT\"},\"contracts/interfaces/ICRV.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\ninterface ICRV {\\n    function get_dy(\\n        int128 _indexIn,\\n        int128 _indexOut,\\n        uint256 _amountIn\\n    ) external view returns (uint256);\\n\\n    // https://github.com/curvefi/curve-contract/blob/\\n    // b0bbf77f8f93c9c5f4e415bce9cd71f0cdee960e/contracts/pools/steth/StableSwapSTETH.vy#L431\\n    function exchange(\\n        int128 _indexIn,\\n        int128 _indexOut,\\n        uint256 _amountIn,\\n        uint256 _minAmountOut\\n    ) external returns (uint256);\\n}\\n\",\"keccak256\":\"0xd2277c5ea1909c5760c9f649c46ea93ddb7bdcae04ec443001e329182545e58f\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20Detailed.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IERC20Detailed is IERC20 {\\n    function decimals() external view returns (uint8);\\n\\n    function symbol() external view returns (string calldata);\\n\\n    function name() external view returns (string calldata);\\n}\\n\",\"keccak256\":\"0x90fd29862ecc4bc1f2ee3e4d5c42364c5fbcc0f43f907d2bb82665f93df0d218\",\"license\":\"MIT\"},\"contracts/interfaces/IGnosisAuction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary AuctionType {\\n    struct AuctionData {\\n        IERC20 auctioningToken;\\n        IERC20 biddingToken;\\n        uint256 orderCancellationEndDate;\\n        uint256 auctionEndDate;\\n        bytes32 initialAuctionOrder;\\n        uint256 minimumBiddingAmountPerOrder;\\n        uint256 interimSumBidAmount;\\n        bytes32 interimOrder;\\n        bytes32 clearingPriceOrder;\\n        uint96 volumeClearingPriceOrder;\\n        bool minFundingThresholdNotReached;\\n        bool isAtomicClosureAllowed;\\n        uint256 feeNumerator;\\n        uint256 minFundingThreshold;\\n    }\\n}\\n\\ninterface IGnosisAuction {\\n    function initiateAuction(\\n        address _auctioningToken,\\n        address _biddingToken,\\n        uint256 orderCancellationEndDate,\\n        uint256 auctionEndDate,\\n        uint96 _auctionedSellAmount,\\n        uint96 _minBuyAmount,\\n        uint256 minimumBiddingAmountPerOrder,\\n        uint256 minFundingThreshold,\\n        bool isAtomicClosureAllowed,\\n        address accessManagerContract,\\n        bytes memory accessManagerContractData\\n    ) external returns (uint256);\\n\\n    function auctionCounter() external view returns (uint256);\\n\\n    function auctionData(uint256 auctionId)\\n        external\\n        view\\n        returns (AuctionType.AuctionData memory);\\n\\n    function auctionAccessManager(uint256 auctionId)\\n        external\\n        view\\n        returns (address);\\n\\n    function auctionAccessData(uint256 auctionId)\\n        external\\n        view\\n        returns (bytes memory);\\n\\n    function FEE_DENOMINATOR() external view returns (uint256);\\n\\n    function feeNumerator() external view returns (uint256);\\n\\n    function settleAuction(uint256 auctionId) external returns (bytes32);\\n\\n    function placeSellOrders(\\n        uint256 auctionId,\\n        uint96[] memory _minBuyAmounts,\\n        uint96[] memory _sellAmounts,\\n        bytes32[] memory _prevSellOrders,\\n        bytes calldata allowListCallData\\n    ) external returns (uint64);\\n\\n    function claimFromParticipantOrder(\\n        uint256 auctionId,\\n        bytes32[] memory orders\\n    ) external returns (uint256, uint256);\\n}\\n\",\"keccak256\":\"0x226639ee48018ec78891a829816799c9b9f6bbec7e84c4ca43cdc7dc8a07628f\",\"license\":\"MIT\"},\"contracts/interfaces/IRibbon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\ninterface IStrikeSelection {\\n    function getStrikePrice(uint256 expiryTimestamp, bool isPut)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    function delta() external view returns (uint256);\\n}\\n\\ninterface IOptionsPremiumPricer {\\n    function getPremium(\\n        uint256 strikePrice,\\n        uint256 timeToExpiry,\\n        bool isPut\\n    ) external view returns (uint256);\\n\\n    function getOptionDelta(\\n        uint256 spotPrice,\\n        uint256 strikePrice,\\n        uint256 volatility,\\n        uint256 expiryTimestamp\\n    ) external view returns (uint256 delta);\\n\\n    function getUnderlyingPrice() external view returns (uint256);\\n\\n    function priceOracle() external view returns (address);\\n\\n    function volatilityOracle() external view returns (address);\\n\\n    function pool() external view returns (address);\\n}\\n\",\"keccak256\":\"0xf2dcc40727ef8d8723ee3193cefdeffa3c2b5a56b0a444d233eafceee0d6f298\",\"license\":\"MIT\"},\"contracts/interfaces/IRibbonThetaVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport {Vault} from \\\"../libraries/Vault.sol\\\";\\n\\ninterface IRibbonThetaVault {\\n    function currentOption() external view returns (address);\\n\\n    function nextOption() external view returns (address);\\n\\n    function vaultParams() external view returns (Vault.VaultParams memory);\\n\\n    function vaultState() external view returns (Vault.VaultState memory);\\n\\n    function optionState() external view returns (Vault.OptionState memory);\\n\\n    function optionAuctionID() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xaca9a37c1f43c85c81c799997e75193df1980191bd6ce9b5f7b980d97e565dbf\",\"license\":\"MIT\"},\"contracts/interfaces/ISTETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\ninterface IWSTETH {\\n    function getStETHByWstETH(uint256 _amount) external view returns (uint256);\\n\\n    function getWstETHByStETH(uint256 _amount) external view returns (uint256);\\n\\n    function stEthPerToken() external view returns (uint256);\\n\\n    function tokensPerStEth() external view returns (uint256);\\n\\n    function stETH() external view returns (address);\\n\\n    function wrap(uint256 _amount) external returns (uint256);\\n\\n    function unwrap(uint256 _amount) external returns (uint256);\\n\\n    function approve(address _recipient, uint256 _amount)\\n        external\\n        returns (bool);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function decimals() external view returns (uint256);\\n}\\n\\ninterface ISTETH {\\n    function getBufferedEther(uint256 _amount) external view returns (uint256);\\n\\n    function getPooledEthByShares(uint256 _amount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function getSharesByPooledEth(uint256 _amount)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function submit(address _referralAddress)\\n        external\\n        payable\\n        returns (uint256);\\n\\n    function withdraw(uint256 _amount, bytes32 _pubkeyHash)\\n        external\\n        returns (uint256);\\n\\n    function approve(address _recipient, uint256 _amount)\\n        external\\n        returns (bool);\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function decimals() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xc0a9301f3b6db86b340789957c7597555bfb88f9bb495af1f2ca61a783c12345\",\"license\":\"MIT\"},\"contracts/interfaces/IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function decimals() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x027f79659aea02845423eb96cfc4f926efb2214745463e3cbcfe4e4c24a065d9\",\"license\":\"MIT\"},\"contracts/libraries/GnosisAuction.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {\\n    SafeERC20\\n} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {DSMath} from \\\"../vendor/DSMath.sol\\\";\\nimport {IGnosisAuction} from \\\"../interfaces/IGnosisAuction.sol\\\";\\nimport {IOtoken} from \\\"../interfaces/GammaInterface.sol\\\";\\nimport {IOptionsPremiumPricer} from \\\"../interfaces/IRibbon.sol\\\";\\nimport {Vault} from \\\"./Vault.sol\\\";\\nimport {IRibbonThetaVault} from \\\"../interfaces/IRibbonThetaVault.sol\\\";\\n\\nlibrary GnosisAuction {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    event InitiateGnosisAuction(\\n        address indexed auctioningToken,\\n        address indexed biddingToken,\\n        uint256 auctionCounter,\\n        address indexed manager\\n    );\\n\\n    event PlaceAuctionBid(\\n        uint256 auctionId,\\n        address indexed auctioningToken,\\n        uint256 sellAmount,\\n        uint256 buyAmount,\\n        address indexed bidder\\n    );\\n\\n    struct AuctionDetails {\\n        address oTokenAddress;\\n        address gnosisEasyAuction;\\n        address asset;\\n        uint256 assetDecimals;\\n        uint256 oTokenPremium;\\n        uint256 duration;\\n    }\\n\\n    struct BidDetails {\\n        address oTokenAddress;\\n        address gnosisEasyAuction;\\n        address asset;\\n        uint256 assetDecimals;\\n        uint256 auctionId;\\n        uint256 lockedBalance;\\n        uint256 optionAllocation;\\n        uint256 optionPremium;\\n        address bidder;\\n    }\\n\\n    function startAuction(AuctionDetails calldata auctionDetails)\\n        internal\\n        returns (uint256 auctionID)\\n    {\\n        uint256 oTokenSellAmount =\\n            getOTokenSellAmount(auctionDetails.oTokenAddress);\\n\\n        IERC20(auctionDetails.oTokenAddress).safeApprove(\\n            auctionDetails.gnosisEasyAuction,\\n            IERC20(auctionDetails.oTokenAddress).balanceOf(address(this))\\n        );\\n\\n        // minBidAmount is total oTokens to sell * premium per oToken\\n        // shift decimals to correspond to decimals of USDC for puts\\n        // and underlying for calls\\n        uint256 minBidAmount =\\n            DSMath\\n                .wmul(\\n                oTokenSellAmount.mul(10**10),\\n                auctionDetails\\n                    .oTokenPremium\\n            )\\n                .div(10**(uint256(18).sub(auctionDetails.assetDecimals)));\\n\\n        require(\\n            minBidAmount <= type(uint96).max,\\n            \\\"optionPremium * oTokenSellAmount > type(uint96) max value!\\\"\\n        );\\n\\n        uint256 auctionEnd = block.timestamp.add(auctionDetails.duration);\\n\\n        auctionID = IGnosisAuction(auctionDetails.gnosisEasyAuction)\\n            .initiateAuction(\\n            // address of oToken we minted and are selling\\n            auctionDetails.oTokenAddress,\\n            // address of asset we want in exchange for oTokens. Should match vault `asset`\\n            auctionDetails.asset,\\n            // orders can be cancelled at any time during the auction\\n            auctionEnd,\\n            // order will last for `duration`\\n            auctionEnd,\\n            // we are selling all of the otokens minus a fee taken by gnosis\\n            uint96(oTokenSellAmount),\\n            // the minimum we are willing to sell all the oTokens for. A discount is applied on black-scholes price\\n            uint96(minBidAmount),\\n            // the minimum bidding amount must be 1 * 10 ** -assetDecimals\\n            1,\\n            // the min funding threshold\\n            0,\\n            // no atomic closure\\n            false,\\n            // access manager contract\\n            address(0),\\n            // bytes for storing info like a whitelist for who can bid\\n            bytes(\\\"\\\")\\n        );\\n\\n        emit InitiateGnosisAuction(\\n            auctionDetails.oTokenAddress,\\n            auctionDetails.asset,\\n            auctionID,\\n            msg.sender\\n        );\\n    }\\n\\n    function placeBid(BidDetails calldata bidDetails)\\n        internal\\n        returns (\\n            uint256 sellAmount,\\n            uint256 buyAmount,\\n            uint64 userId\\n        )\\n    {\\n        // calculate how much to allocate\\n        sellAmount = bidDetails\\n            .lockedBalance\\n            .mul(bidDetails.optionAllocation)\\n            .div(100 * Vault.OPTION_ALLOCATION_MULTIPLIER);\\n\\n        // divide the `asset` sellAmount by the target premium per oToken to\\n        // get the number of oTokens to buy (8 decimals)\\n        buyAmount = sellAmount\\n            .mul(10**(bidDetails.assetDecimals.add(Vault.OTOKEN_DECIMALS)))\\n            .div(bidDetails.optionPremium)\\n            .div(10**bidDetails.assetDecimals);\\n\\n        require(\\n            sellAmount <= type(uint96).max,\\n            \\\"sellAmount > type(uint96) max value!\\\"\\n        );\\n        require(\\n            buyAmount <= type(uint96).max,\\n            \\\"buyAmount > type(uint96) max value!\\\"\\n        );\\n\\n        // approve that amount\\n        IERC20(bidDetails.asset).safeApprove(\\n            bidDetails.gnosisEasyAuction,\\n            sellAmount\\n        );\\n\\n        uint96[] memory _minBuyAmounts = new uint96[](1);\\n        uint96[] memory _sellAmounts = new uint96[](1);\\n        bytes32[] memory _prevSellOrders = new bytes32[](1);\\n        _minBuyAmounts[0] = uint96(buyAmount);\\n        _sellAmounts[0] = uint96(sellAmount);\\n        _prevSellOrders[\\n            0\\n        ] = 0x0000000000000000000000000000000000000000000000000000000000000001;\\n\\n        // place sell order with that amount\\n        userId = IGnosisAuction(bidDetails.gnosisEasyAuction).placeSellOrders(\\n            bidDetails.auctionId,\\n            _minBuyAmounts,\\n            _sellAmounts,\\n            _prevSellOrders,\\n            \\\"0x\\\"\\n        );\\n\\n        emit PlaceAuctionBid(\\n            bidDetails.auctionId,\\n            bidDetails.oTokenAddress,\\n            sellAmount,\\n            buyAmount,\\n            bidDetails.bidder\\n        );\\n\\n        return (sellAmount, buyAmount, userId);\\n    }\\n\\n    function claimAuctionOtokens(\\n        Vault.AuctionSellOrder calldata auctionSellOrder,\\n        address gnosisEasyAuction,\\n        address counterpartyThetaVault\\n    ) internal {\\n        bytes32 order =\\n            encodeOrder(\\n                auctionSellOrder.userId,\\n                auctionSellOrder.buyAmount,\\n                auctionSellOrder.sellAmount\\n            );\\n        bytes32[] memory orders = new bytes32[](1);\\n        orders[0] = order;\\n        IGnosisAuction(gnosisEasyAuction).claimFromParticipantOrder(\\n            IRibbonThetaVault(counterpartyThetaVault).optionAuctionID(),\\n            orders\\n        );\\n    }\\n\\n    function getOTokenSellAmount(address oTokenAddress)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        // We take our current oToken balance. That will be our sell amount\\n        // but otokens will be transferred to gnosis.\\n        uint256 oTokenSellAmount =\\n            IERC20(oTokenAddress).balanceOf(address(this));\\n\\n        require(\\n            oTokenSellAmount <= type(uint96).max,\\n            \\\"oTokenSellAmount > type(uint96) max value!\\\"\\n        );\\n\\n        return oTokenSellAmount;\\n    }\\n\\n    function getOTokenPremium(\\n        address oTokenAddress,\\n        address optionsPremiumPricer,\\n        uint256 premiumDiscount\\n    ) internal view returns (uint256) {\\n        IOtoken newOToken = IOtoken(oTokenAddress);\\n        IOptionsPremiumPricer premiumPricer =\\n            IOptionsPremiumPricer(optionsPremiumPricer);\\n\\n        // Apply black-scholes formula (from rvol library) to option given its features\\n        // and get price for 100 contracts denominated in the underlying asset for call option\\n        // and USDC for put option\\n        uint256 optionPremium =\\n            premiumPricer.getPremium(\\n                newOToken.strikePrice(),\\n                newOToken.expiryTimestamp(),\\n                newOToken.isPut()\\n            );\\n\\n        // Apply a discount to incentivize arbitraguers\\n        optionPremium = optionPremium.mul(premiumDiscount).div(\\n            100 * Vault.PREMIUM_DISCOUNT_MULTIPLIER\\n        );\\n\\n        require(\\n            optionPremium <= type(uint96).max,\\n            \\\"optionPremium > type(uint96) max value!\\\"\\n        );\\n\\n        return optionPremium;\\n    }\\n\\n    function encodeOrder(\\n        uint64 userId,\\n        uint96 buyAmount,\\n        uint96 sellAmount\\n    ) internal pure returns (bytes32) {\\n        return\\n            bytes32(\\n                (uint256(userId) << 192) +\\n                    (uint256(buyAmount) << 96) +\\n                    uint256(sellAmount)\\n            );\\n    }\\n}\\n\",\"keccak256\":\"0x135c9d8faacd784cae610486c10f95b263ca8e9178524c026ce00c036b663122\",\"license\":\"MIT\"},\"contracts/libraries/ShareMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport {Vault} from \\\"./Vault.sol\\\";\\n\\nlibrary ShareMath {\\n    using SafeMath for uint256;\\n\\n    uint256 internal constant PLACEHOLDER_UINT = 1;\\n\\n    function assetToShares(\\n        uint256 assetAmount,\\n        uint256 assetPerShare,\\n        uint256 decimals\\n    ) internal pure returns (uint256) {\\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\\n        // which should never happen.\\n        // Has to be larger than 1 because `1` is used in `initRoundPricePerShares` to prevent cold writes.\\n        require(assetPerShare > PLACEHOLDER_UINT, \\\"Invalid assetPerShare\\\");\\n\\n        return assetAmount.mul(10**decimals).div(assetPerShare);\\n    }\\n\\n    function sharesToAsset(\\n        uint256 shares,\\n        uint256 assetPerShare,\\n        uint256 decimals\\n    ) internal pure returns (uint256) {\\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\\n        // which should never happen.\\n        // Has to be larger than 1 because `1` is used in `initRoundPricePerShares` to prevent cold writes.\\n        require(assetPerShare > PLACEHOLDER_UINT, \\\"Invalid assetPerShare\\\");\\n\\n        return shares.mul(assetPerShare).div(10**decimals);\\n    }\\n\\n    /**\\n     * @notice Returns the shares unredeemed by the user given their DepositReceipt\\n     * @param depositReceipt is the user's deposit receipt\\n     * @param currentRound is the `round` stored on the vault\\n     * @param assetPerShare is the price in asset per share\\n     * @param decimals is the number of decimals the asset/shares use\\n     * @return unredeemedShares is the user's virtual balance of shares that are owed\\n     */\\n    function getSharesFromReceipt(\\n        Vault.DepositReceipt memory depositReceipt,\\n        uint256 currentRound,\\n        uint256 assetPerShare,\\n        uint256 decimals\\n    ) internal pure returns (uint256 unredeemedShares) {\\n        if (depositReceipt.round > 0 && depositReceipt.round < currentRound) {\\n            uint256 sharesFromRound =\\n                assetToShares(depositReceipt.amount, assetPerShare, decimals);\\n\\n            return\\n                uint256(depositReceipt.unredeemedShares).add(sharesFromRound);\\n        }\\n        return depositReceipt.unredeemedShares;\\n    }\\n\\n    function pricePerShare(\\n        uint256 totalSupply,\\n        uint256 totalBalance,\\n        uint256 pendingAmount,\\n        uint256 decimals\\n    ) internal pure returns (uint256) {\\n        uint256 singleShare = 10**decimals;\\n        return\\n            totalSupply > 0\\n                ? singleShare.mul(totalBalance.sub(pendingAmount)).div(\\n                    totalSupply\\n                )\\n                : singleShare;\\n    }\\n\\n    /************************************************\\n     *  HELPERS\\n     ***********************************************/\\n\\n    function assertUint104(uint256 num) internal pure {\\n        require(num <= type(uint104).max, \\\"Overflow uint104\\\");\\n    }\\n\\n    function assertUint128(uint256 num) internal pure {\\n        require(num <= type(uint128).max, \\\"Overflow uint128\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x90bc4b56ee48f314d1e326903bdb2926bed143fa4e6867a7d44975503106bf56\",\"license\":\"MIT\"},\"contracts/libraries/SupportsNonCompliantERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {\\n    SafeERC20\\n} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\n/**\\n * This library supports ERC20s that have quirks in their behavior.\\n * One such ERC20 is USDT, which requires allowance to be 0 before calling approve.\\n * We plan to update this library with ERC20s that display such idiosyncratic behavior.\\n */\\nlibrary SupportsNonCompliantERC20 {\\n    address private constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\\n\\n    function safeApproveNonCompliant(\\n        IERC20 token,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        if (address(token) == USDT) {\\n            SafeERC20.safeApprove(token, spender, 0);\\n        }\\n        SafeERC20.safeApprove(token, spender, amount);\\n    }\\n}\\n\",\"keccak256\":\"0xda967c8a0bcbdf15b1b60c4cba1d0b12aae75431570dfbb5fb06b64162c83cb0\",\"license\":\"MIT\"},\"contracts/libraries/Vault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nlibrary Vault {\\n    /************************************************\\n     *  IMMUTABLES & CONSTANTS\\n     ***********************************************/\\n\\n    // Fees are 6-decimal places. For example: 20 * 10**6 = 20%\\n    uint256 internal constant FEE_MULTIPLIER = 10**6;\\n\\n    // Premium discount has 1-decimal place. For example: 80 * 10**1 = 80%. Which represents a 20% discount.\\n    uint256 internal constant PREMIUM_DISCOUNT_MULTIPLIER = 10;\\n\\n    // Otokens have 8 decimal places.\\n    uint256 internal constant OTOKEN_DECIMALS = 8;\\n\\n    // Percentage of funds allocated to options is 2 decimal places. 10 * 10**2 = 10%\\n    uint256 internal constant OPTION_ALLOCATION_MULTIPLIER = 10**2;\\n\\n    // Placeholder uint value to prevent cold writes\\n    uint256 internal constant PLACEHOLDER_UINT = 1;\\n\\n    struct VaultParams {\\n        // Option type the vault is selling\\n        bool isPut;\\n        // Token decimals for vault shares\\n        uint8 decimals;\\n        // Asset used in Theta / Delta Vault\\n        address asset;\\n        // Underlying asset of the options sold by vault\\n        address underlying;\\n        // Minimum supply of the vault shares issued, for ETH it's 10**10\\n        uint56 minimumSupply;\\n        // Vault cap\\n        uint104 cap;\\n    }\\n\\n    struct OptionState {\\n        // Option that the vault is shorting / longing in the next cycle\\n        address nextOption;\\n        // Option that the vault is currently shorting / longing\\n        address currentOption;\\n        // The timestamp when the `nextOption` can be used by the vault\\n        uint32 nextOptionReadyAt;\\n    }\\n\\n    struct VaultState {\\n        // 32 byte slot 1\\n        //  Current round number. `round` represents the number of `period`s elapsed.\\n        uint16 round;\\n        // Amount that is currently locked for selling options\\n        uint104 lockedAmount;\\n        // Amount that was locked for selling options in the previous round\\n        // used for calculating performance fee deduction\\n        uint104 lastLockedAmount;\\n        // 32 byte slot 2\\n        // Stores the total tally of how much of `asset` there is\\n        // to be used to mint rTHETA tokens\\n        uint128 totalPending;\\n        // Amount locked for scheduled withdrawals;\\n        uint128 queuedWithdrawShares;\\n    }\\n\\n    struct DepositReceipt {\\n        // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\\n        uint16 round;\\n        // Deposit amount, max 20,282,409,603,651 or 20 trillion ETH deposit\\n        uint104 amount;\\n        // Unredeemed shares balance\\n        uint128 unredeemedShares;\\n    }\\n\\n    struct Withdrawal {\\n        // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\\n        uint16 round;\\n        // Number of shares withdrawn\\n        uint128 shares;\\n    }\\n\\n    struct AuctionSellOrder {\\n        // Amount of `asset` token offered in auction\\n        uint96 sellAmount;\\n        // Amount of oToken requested in auction\\n        uint96 buyAmount;\\n        // User Id of delta vault in latest gnosis auction\\n        uint64 userId;\\n    }\\n}\\n\",\"keccak256\":\"0x462aa30f83c322d3129ded8da0d5f8430425a04c8c2d87787f33d7d5c41c1571\",\"license\":\"MIT\"},\"contracts/libraries/VaultLifecycle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Vault} from \\\"./Vault.sol\\\";\\nimport {ShareMath} from \\\"./ShareMath.sol\\\";\\nimport {IStrikeSelection} from \\\"../interfaces/IRibbon.sol\\\";\\nimport {GnosisAuction} from \\\"./GnosisAuction.sol\\\";\\nimport {\\n    IOtokenFactory,\\n    IOtoken,\\n    IController,\\n    GammaTypes\\n} from \\\"../interfaces/GammaInterface.sol\\\";\\nimport {IERC20Detailed} from \\\"../interfaces/IERC20Detailed.sol\\\";\\nimport {SupportsNonCompliantERC20} from \\\"./SupportsNonCompliantERC20.sol\\\";\\n\\nlibrary VaultLifecycle {\\n    using SafeMath for uint256;\\n    using SupportsNonCompliantERC20 for IERC20;\\n\\n    struct CloseParams {\\n        address OTOKEN_FACTORY;\\n        address USDC;\\n        address currentOption;\\n        uint256 delay;\\n        uint16 lastStrikeOverrideRound;\\n        uint256 overriddenStrikePrice;\\n    }\\n\\n    /**\\n     * @notice Sets the next option the vault will be shorting, and calculates its premium for the auction\\n     * @param strikeSelection is the address of the contract with strike selection logic\\n     * @param optionsPremiumPricer is the address of the contract with the\\n       black-scholes premium calculation logic\\n     * @param premiumDiscount is the vault's discount applied to the premium\\n     * @param closeParams is the struct with details on previous option and strike selection details\\n     * @param vaultParams is the struct with vault general data\\n     * @param vaultState is the struct with vault accounting state\\n     * @return otokenAddress is the address of the new option\\n     * @return premium is the premium of the new option\\n     * @return strikePrice is the strike price of the new option\\n     * @return delta is the delta of the new option\\n     */\\n    function commitAndClose(\\n        address strikeSelection,\\n        address optionsPremiumPricer,\\n        uint256 premiumDiscount,\\n        CloseParams calldata closeParams,\\n        Vault.VaultParams storage vaultParams,\\n        Vault.VaultState storage vaultState\\n    )\\n        external\\n        returns (\\n            address otokenAddress,\\n            uint256 premium,\\n            uint256 strikePrice,\\n            uint256 delta\\n        )\\n    {\\n        uint256 expiry;\\n\\n        // uninitialized state\\n        if (closeParams.currentOption == address(0)) {\\n            expiry = getNextFriday(block.timestamp);\\n        } else {\\n            expiry = getNextFriday(\\n                IOtoken(closeParams.currentOption).expiryTimestamp()\\n            );\\n        }\\n\\n        IStrikeSelection selection = IStrikeSelection(strikeSelection);\\n\\n        bool isPut = vaultParams.isPut;\\n        address underlying = vaultParams.underlying;\\n        address asset = vaultParams.asset;\\n\\n        (strikePrice, delta) = closeParams.lastStrikeOverrideRound ==\\n            vaultState.round\\n            ? (closeParams.overriddenStrikePrice, selection.delta())\\n            : selection.getStrikePrice(expiry, isPut);\\n\\n        require(strikePrice != 0, \\\"!strikePrice\\\");\\n\\n        // retrieve address if option already exists, or deploy it\\n        otokenAddress = getOrDeployOtoken(\\n            closeParams,\\n            vaultParams,\\n            underlying,\\n            asset,\\n            strikePrice,\\n            expiry,\\n            isPut\\n        );\\n\\n        // get the black scholes premium of the option\\n        premium = GnosisAuction.getOTokenPremium(\\n            otokenAddress,\\n            optionsPremiumPricer,\\n            premiumDiscount\\n        );\\n\\n        require(premium > 0, \\\"!premium\\\");\\n\\n        return (otokenAddress, premium, strikePrice, delta);\\n    }\\n\\n    /**\\n     * @notice Verify the otoken has the correct parameters to prevent vulnerability to opyn contract changes\\n     * @param otokenAddress is the address of the otoken\\n     * @param vaultParams is the struct with vault general data\\n     * @param collateralAsset is the address of the collateral asset\\n     * @param USDC is the address of usdc\\n     * @param delay is the delay between commitAndClose and rollToNextOption\\n     */\\n    function verifyOtoken(\\n        address otokenAddress,\\n        Vault.VaultParams storage vaultParams,\\n        address collateralAsset,\\n        address USDC,\\n        uint256 delay\\n    ) private view {\\n        require(otokenAddress != address(0), \\\"!otokenAddress\\\");\\n\\n        IOtoken otoken = IOtoken(otokenAddress);\\n        require(otoken.isPut() == vaultParams.isPut, \\\"Type mismatch\\\");\\n        require(\\n            otoken.underlyingAsset() == vaultParams.underlying,\\n            \\\"Wrong underlyingAsset\\\"\\n        );\\n        require(\\n            otoken.collateralAsset() == collateralAsset,\\n            \\\"Wrong collateralAsset\\\"\\n        );\\n\\n        // we just assume all options use USDC as the strike\\n        require(otoken.strikeAsset() == USDC, \\\"strikeAsset != USDC\\\");\\n\\n        uint256 readyAt = block.timestamp.add(delay);\\n        require(otoken.expiryTimestamp() >= readyAt, \\\"Expiry before delay\\\");\\n    }\\n\\n    /**\\n     * @param currentShareSupply is the supply of the shares invoked with totalSupply()\\n     * @param asset is the address of the vault's asset\\n     * @param decimals is the decimals of the asset\\n     * @param lastQueuedWithdrawAmount is the amount queued for withdrawals from last round\\n     * @param performanceFee is the perf fee percent to charge on premiums\\n     * @param managementFee is the management fee percent to charge on the AUM\\n     */\\n    struct RolloverParams {\\n        uint256 decimals;\\n        uint256 totalBalance;\\n        uint256 currentShareSupply;\\n        uint256 lastQueuedWithdrawAmount;\\n        uint256 performanceFee;\\n        uint256 managementFee;\\n    }\\n\\n    /**\\n     * @notice Calculate the shares to mint, new price per share, and\\n      amount of funds to re-allocate as collateral for the new round\\n     * @param vaultState is the storage variable vaultState passed from RibbonVault\\n     * @param params is the rollover parameters passed to compute the next state\\n     * @return newLockedAmount is the amount of funds to allocate for the new round\\n     * @return queuedWithdrawAmount is the amount of funds set aside for withdrawal\\n     * @return newPricePerShare is the price per share of the new round\\n     * @return mintShares is the amount of shares to mint from deposits\\n     * @return performanceFeeInAsset is the performance fee charged by vault\\n     * @return totalVaultFee is the total amount of fee charged by vault\\n     */\\n    function rollover(\\n        Vault.VaultState storage vaultState,\\n        RolloverParams calldata params\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 newLockedAmount,\\n            uint256 queuedWithdrawAmount,\\n            uint256 newPricePerShare,\\n            uint256 mintShares,\\n            uint256 performanceFeeInAsset,\\n            uint256 totalVaultFee\\n        )\\n    {\\n        uint256 currentBalance = params.totalBalance;\\n        uint256 pendingAmount = vaultState.totalPending;\\n        uint256 queuedWithdrawShares = vaultState.queuedWithdrawShares;\\n\\n        uint256 withdrawAmountDiff;\\n        {\\n            uint256 pricePerShareBeforeFee =\\n                ShareMath.pricePerShare(\\n                    params.currentShareSupply,\\n                    currentBalance,\\n                    pendingAmount,\\n                    params.decimals\\n                );\\n\\n            uint256 queuedWithdrawBeforeFee =\\n                params.currentShareSupply > 0\\n                    ? ShareMath.sharesToAsset(\\n                        queuedWithdrawShares,\\n                        pricePerShareBeforeFee,\\n                        params.decimals\\n                    )\\n                    : 0;\\n\\n            // Deduct the difference between the newly scheduled withdrawals\\n            // and the older withdrawals\\n            // so we can charge them fees before they leave\\n            withdrawAmountDiff = queuedWithdrawBeforeFee >\\n                params.lastQueuedWithdrawAmount\\n                ? queuedWithdrawBeforeFee.sub(params.lastQueuedWithdrawAmount)\\n                : 0;\\n        }\\n\\n        {\\n            (performanceFeeInAsset, , totalVaultFee) = VaultLifecycle\\n                .getVaultFees(\\n                currentBalance,\\n                vaultState.lastLockedAmount,\\n                vaultState.totalPending,\\n                params.performanceFee,\\n                params.managementFee\\n            );\\n        }\\n\\n        // Take into account the fee\\n        // so we can calculate the newPricePerShare\\n        currentBalance = currentBalance.sub(totalVaultFee);\\n\\n        {\\n            newPricePerShare = ShareMath.pricePerShare(\\n                params.currentShareSupply,\\n                currentBalance,\\n                pendingAmount,\\n                params.decimals\\n            );\\n\\n            // After closing the short, if the options expire in-the-money\\n            // vault pricePerShare would go down because vault's asset balance decreased.\\n            // This ensures that the newly-minted shares do not take on the loss.\\n            mintShares = ShareMath.assetToShares(\\n                pendingAmount,\\n                newPricePerShare,\\n                params.decimals\\n            );\\n\\n            uint256 newSupply = params.currentShareSupply.add(mintShares);\\n\\n            queuedWithdrawAmount = newSupply > 0\\n                ? ShareMath.sharesToAsset(\\n                    queuedWithdrawShares,\\n                    newPricePerShare,\\n                    params.decimals\\n                )\\n                : 0;\\n        }\\n\\n        return (\\n            currentBalance.sub(queuedWithdrawAmount), // new locked balance subtracts the queued withdrawals\\n            queuedWithdrawAmount,\\n            newPricePerShare,\\n            mintShares,\\n            performanceFeeInAsset,\\n            totalVaultFee\\n        );\\n    }\\n\\n    /**\\n     * @notice Creates the actual Opyn short position by depositing collateral and minting otokens\\n     * @param gammaController is the address of the opyn controller contract\\n     * @param marginPool is the address of the opyn margin contract which holds the collateral\\n     * @param oTokenAddress is the address of the otoken to mint\\n     * @param depositAmount is the amount of collateral to deposit\\n     * @return the otoken mint amount\\n     */\\n    function createShort(\\n        address gammaController,\\n        address marginPool,\\n        address oTokenAddress,\\n        uint256 depositAmount\\n    ) external returns (uint256) {\\n        IController controller = IController(gammaController);\\n        uint256 newVaultID =\\n            (controller.getAccountVaultCounter(address(this))).add(1);\\n\\n        // An otoken's collateralAsset is the vault's `asset`\\n        // So in the context of performing Opyn short operations we call them collateralAsset\\n        IOtoken oToken = IOtoken(oTokenAddress);\\n        address collateralAsset = oToken.collateralAsset();\\n\\n        uint256 collateralDecimals =\\n            uint256(IERC20Detailed(collateralAsset).decimals());\\n        uint256 mintAmount;\\n\\n        if (oToken.isPut()) {\\n            // For minting puts, there will be instances where the full depositAmount will not be used for minting.\\n            // This is because of an issue with precision.\\n            //\\n            // For ETH put options, we are calculating the mintAmount (10**8 decimals) using\\n            // the depositAmount (10**18 decimals), which will result in truncation of decimals when scaling down.\\n            // As a result, there will be tiny amounts of dust left behind in the Opyn vault when minting put otokens.\\n            //\\n            // For simplicity's sake, we do not refund the dust back to the address(this) on minting otokens.\\n            // We retain the dust in the vault so the calling contract can withdraw the\\n            // actual locked amount + dust at settlement.\\n            //\\n            // To test this behavior, we can console.log\\n            // MarginCalculatorInterface(0x7A48d10f372b3D7c60f6c9770B91398e4ccfd3C7).getExcessCollateral(vault)\\n            // to see how much dust (or excess collateral) is left behind.\\n            mintAmount = depositAmount\\n                .mul(10**Vault.OTOKEN_DECIMALS)\\n                .mul(10**18) // we use 10**18 to give extra precision\\n                .div(oToken.strikePrice().mul(10**(10 + collateralDecimals)));\\n        } else {\\n            mintAmount = depositAmount;\\n\\n            if (collateralDecimals > 8) {\\n                uint256 scaleBy = 10**(collateralDecimals.sub(8)); // oTokens have 8 decimals\\n                if (mintAmount > scaleBy) {\\n                    mintAmount = depositAmount.div(scaleBy); // scale down from 10**18 to 10**8\\n                }\\n            }\\n        }\\n\\n        // double approve to fix non-compliant ERC20s\\n        IERC20 collateralToken = IERC20(collateralAsset);\\n        collateralToken.safeApproveNonCompliant(marginPool, depositAmount);\\n\\n        IController.ActionArgs[] memory actions =\\n            new IController.ActionArgs[](3);\\n\\n        actions[0] = IController.ActionArgs(\\n            IController.ActionType.OpenVault,\\n            address(this), // owner\\n            address(this), // receiver\\n            address(0), // asset, otoken\\n            newVaultID, // vaultId\\n            0, // amount\\n            0, //index\\n            \\\"\\\" //data\\n        );\\n\\n        actions[1] = IController.ActionArgs(\\n            IController.ActionType.DepositCollateral,\\n            address(this), // owner\\n            address(this), // address to transfer from\\n            collateralAsset, // deposited asset\\n            newVaultID, // vaultId\\n            depositAmount, // amount\\n            0, //index\\n            \\\"\\\" //data\\n        );\\n\\n        actions[2] = IController.ActionArgs(\\n            IController.ActionType.MintShortOption,\\n            address(this), // owner\\n            address(this), // address to transfer to\\n            oTokenAddress, // option address\\n            newVaultID, // vaultId\\n            mintAmount, // amount\\n            0, //index\\n            \\\"\\\" //data\\n        );\\n\\n        controller.operate(actions);\\n\\n        return mintAmount;\\n    }\\n\\n    /**\\n     * @notice Close the existing short otoken position. Currently this implementation is simple.\\n     * It closes the most recent vault opened by the contract. This assumes that the contract will\\n     * only have a single vault open at any given time. Since calling `_closeShort` deletes vaults by\\n     calling SettleVault action, this assumption should hold.\\n     * @param gammaController is the address of the opyn controller contract\\n     * @return amount of collateral redeemed from the vault\\n     */\\n    function settleShort(address gammaController) external returns (uint256) {\\n        IController controller = IController(gammaController);\\n\\n        // gets the currently active vault ID\\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\\n\\n        GammaTypes.Vault memory vault =\\n            controller.getVault(address(this), vaultID);\\n\\n        require(vault.shortOtokens.length > 0, \\\"No short\\\");\\n\\n        // An otoken's collateralAsset is the vault's `asset`\\n        // So in the context of performing Opyn short operations we call them collateralAsset\\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\\n\\n        // The short position has been previously closed, or all the otokens have been burned.\\n        // So we return early.\\n        if (address(collateralToken) == address(0)) {\\n            return 0;\\n        }\\n\\n        // This is equivalent to doing IERC20(vault.asset).balanceOf(address(this))\\n        uint256 startCollateralBalance =\\n            collateralToken.balanceOf(address(this));\\n\\n        // If it is after expiry, we need to settle the short position using the normal way\\n        // Delete the vault and withdraw all remaining collateral from the vault\\n        IController.ActionArgs[] memory actions =\\n            new IController.ActionArgs[](1);\\n\\n        actions[0] = IController.ActionArgs(\\n            IController.ActionType.SettleVault,\\n            address(this), // owner\\n            address(this), // address to transfer to\\n            address(0), // not used\\n            vaultID, // vaultId\\n            0, // not used\\n            0, // not used\\n            \\\"\\\" // not used\\n        );\\n\\n        controller.operate(actions);\\n\\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\\n\\n        return endCollateralBalance.sub(startCollateralBalance);\\n    }\\n\\n    /**\\n     * @notice Exercises the ITM option using existing long otoken position. Currently this implementation is simple.\\n     * It calls the `Redeem` action to claim the payout.\\n     * @param gammaController is the address of the opyn controller contract\\n     * @param oldOption is the address of the old option\\n     * @param asset is the address of the vault's asset\\n     * @return amount of asset received by exercising the option\\n     */\\n    function settleLong(\\n        address gammaController,\\n        address oldOption,\\n        address asset\\n    ) external returns (uint256) {\\n        IController controller = IController(gammaController);\\n\\n        uint256 oldOptionBalance = IERC20(oldOption).balanceOf(address(this));\\n\\n        if (controller.getPayout(oldOption, oldOptionBalance) == 0) {\\n            return 0;\\n        }\\n\\n        uint256 startAssetBalance = IERC20(asset).balanceOf(address(this));\\n\\n        // If it is after expiry, we need to redeem the profits\\n        IController.ActionArgs[] memory actions =\\n            new IController.ActionArgs[](1);\\n\\n        actions[0] = IController.ActionArgs(\\n            IController.ActionType.Redeem,\\n            address(0), // not used\\n            address(this), // address to send profits to\\n            oldOption, // address of otoken\\n            0, // not used\\n            oldOptionBalance, // otoken balance\\n            0, // not used\\n            \\\"\\\" // not used\\n        );\\n\\n        controller.operate(actions);\\n\\n        uint256 endAssetBalance = IERC20(asset).balanceOf(address(this));\\n\\n        return endAssetBalance.sub(startAssetBalance);\\n    }\\n\\n    /**\\n     * @notice Burn the remaining oTokens left over from auction. Currently this implementation is simple.\\n     * It burns oTokens from the most recent vault opened by the contract. This assumes that the contract will\\n     * only have a single vault open at any given time.\\n     * @param gammaController is the address of the opyn controller contract\\n     * @param currentOption is the address of the current option\\n     * @return amount of collateral redeemed by burning otokens\\n     */\\n    function burnOtokens(address gammaController, address currentOption)\\n        external\\n        returns (uint256)\\n    {\\n        uint256 numOTokensToBurn =\\n            IERC20(currentOption).balanceOf(address(this));\\n\\n        require(numOTokensToBurn > 0, \\\"No oTokens to burn\\\");\\n\\n        IController controller = IController(gammaController);\\n\\n        // gets the currently active vault ID\\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\\n\\n        GammaTypes.Vault memory vault =\\n            controller.getVault(address(this), vaultID);\\n\\n        require(vault.shortOtokens.length > 0, \\\"No short\\\");\\n\\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\\n\\n        uint256 startCollateralBalance =\\n            collateralToken.balanceOf(address(this));\\n\\n        // Burning `amount` of oTokens from the ribbon vault,\\n        // then withdrawing the corresponding collateral amount from the vault\\n        IController.ActionArgs[] memory actions =\\n            new IController.ActionArgs[](2);\\n\\n        actions[0] = IController.ActionArgs(\\n            IController.ActionType.BurnShortOption,\\n            address(this), // owner\\n            address(this), // address to transfer from\\n            address(vault.shortOtokens[0]), // otoken address\\n            vaultID, // vaultId\\n            numOTokensToBurn, // amount\\n            0, //index\\n            \\\"\\\" //data\\n        );\\n\\n        actions[1] = IController.ActionArgs(\\n            IController.ActionType.WithdrawCollateral,\\n            address(this), // owner\\n            address(this), // address to transfer to\\n            address(collateralToken), // withdrawn asset\\n            vaultID, // vaultId\\n            vault.collateralAmounts[0].mul(numOTokensToBurn).div(\\n                vault.shortAmounts[0]\\n            ), // amount\\n            0, //index\\n            \\\"\\\" //data\\n        );\\n\\n        controller.operate(actions);\\n\\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\\n\\n        return endCollateralBalance.sub(startCollateralBalance);\\n    }\\n\\n    /**\\n     * @notice Calculates the performance and management fee for this week's round\\n     * @param currentBalance is the balance of funds held on the vault after closing short\\n     * @param lastLockedAmount is the amount of funds locked from the previous round\\n     * @param pendingAmount is the pending deposit amount\\n     * @param performanceFeePercent is the performance fee pct.\\n     * @param managementFeePercent is the management fee pct.\\n     * @return performanceFeeInAsset is the performance fee\\n     * @return managementFeeInAsset is the management fee\\n     * @return vaultFee is the total fees\\n     */\\n    function getVaultFees(\\n        uint256 currentBalance,\\n        uint256 lastLockedAmount,\\n        uint256 pendingAmount,\\n        uint256 performanceFeePercent,\\n        uint256 managementFeePercent\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256 performanceFeeInAsset,\\n            uint256 managementFeeInAsset,\\n            uint256 vaultFee\\n        )\\n    {\\n        // At the first round, currentBalance=0, pendingAmount>0\\n        // so we just do not charge anything on the first round\\n        uint256 lockedBalanceSansPending =\\n            currentBalance > pendingAmount\\n                ? currentBalance.sub(pendingAmount)\\n                : 0;\\n\\n        uint256 _performanceFeeInAsset;\\n        uint256 _managementFeeInAsset;\\n        uint256 _vaultFee;\\n\\n        // Take performance fee and management fee ONLY if difference between\\n        // last week and this week's vault deposits, taking into account pending\\n        // deposits and withdrawals, is positive. If it is negative, last week's\\n        // option expired ITM past breakeven, and the vault took a loss so we\\n        // do not collect performance fee for last week\\n        if (lockedBalanceSansPending > lastLockedAmount) {\\n            _performanceFeeInAsset = performanceFeePercent > 0\\n                ? lockedBalanceSansPending\\n                    .sub(lastLockedAmount)\\n                    .mul(performanceFeePercent)\\n                    .div(100 * Vault.FEE_MULTIPLIER)\\n                : 0;\\n            _managementFeeInAsset = managementFeePercent > 0\\n                ? lockedBalanceSansPending.mul(managementFeePercent).div(\\n                    100 * Vault.FEE_MULTIPLIER\\n                )\\n                : 0;\\n\\n            _vaultFee = _performanceFeeInAsset.add(_managementFeeInAsset);\\n        }\\n\\n        return (_performanceFeeInAsset, _managementFeeInAsset, _vaultFee);\\n    }\\n\\n    /**\\n     * @notice Either retrieves the option token if it already exists, or deploy it\\n     * @param closeParams is the struct with details on previous option and strike selection details\\n     * @param vaultParams is the struct with vault general data\\n     * @param underlying is the address of the underlying asset of the option\\n     * @param collateralAsset is the address of the collateral asset of the option\\n     * @param strikePrice is the strike price of the option\\n     * @param expiry is the expiry timestamp of the option\\n     * @param isPut is whether the option is a put\\n     * @return the address of the option\\n     */\\n    function getOrDeployOtoken(\\n        CloseParams calldata closeParams,\\n        Vault.VaultParams storage vaultParams,\\n        address underlying,\\n        address collateralAsset,\\n        uint256 strikePrice,\\n        uint256 expiry,\\n        bool isPut\\n    ) internal returns (address) {\\n        IOtokenFactory factory = IOtokenFactory(closeParams.OTOKEN_FACTORY);\\n\\n        address otokenFromFactory =\\n            factory.getOtoken(\\n                underlying,\\n                closeParams.USDC,\\n                collateralAsset,\\n                strikePrice,\\n                expiry,\\n                isPut\\n            );\\n\\n        if (otokenFromFactory != address(0)) {\\n            return otokenFromFactory;\\n        }\\n\\n        address otoken =\\n            factory.createOtoken(\\n                underlying,\\n                closeParams.USDC,\\n                collateralAsset,\\n                strikePrice,\\n                expiry,\\n                isPut\\n            );\\n\\n        verifyOtoken(\\n            otoken,\\n            vaultParams,\\n            collateralAsset,\\n            closeParams.USDC,\\n            closeParams.delay\\n        );\\n\\n        return otoken;\\n    }\\n\\n    /**\\n     * @notice Starts the gnosis auction\\n     * @param auctionDetails is the struct with all the custom parameters of the auction\\n     * @return the auction id of the newly created auction\\n     */\\n    function startAuction(GnosisAuction.AuctionDetails calldata auctionDetails)\\n        external\\n        returns (uint256)\\n    {\\n        return GnosisAuction.startAuction(auctionDetails);\\n    }\\n\\n    /**\\n     * @notice Places a bid in an auction\\n     * @param bidDetails is the struct with all the details of the\\n      bid including the auction's id and how much to bid\\n     */\\n    function placeBid(GnosisAuction.BidDetails calldata bidDetails)\\n        external\\n        returns (\\n            uint256 sellAmount,\\n            uint256 buyAmount,\\n            uint64 userId\\n        )\\n    {\\n        return GnosisAuction.placeBid(bidDetails);\\n    }\\n\\n    /**\\n     * @notice Claims the oTokens belonging to the vault\\n     * @param auctionSellOrder is the sell order of the bid\\n     * @param gnosisEasyAuction is the address of the gnosis auction contract\\n     holding custody to the funds\\n     * @param counterpartyThetaVault is the address of the counterparty theta\\n     vault of this delta vault\\n     */\\n    function claimAuctionOtokens(\\n        Vault.AuctionSellOrder calldata auctionSellOrder,\\n        address gnosisEasyAuction,\\n        address counterpartyThetaVault\\n    ) external {\\n        GnosisAuction.claimAuctionOtokens(\\n            auctionSellOrder,\\n            gnosisEasyAuction,\\n            counterpartyThetaVault\\n        );\\n    }\\n\\n    /**\\n     * @notice Verify the constructor params satisfy requirements\\n     * @param owner is the owner of the vault with critical permissions\\n     * @param feeRecipient is the address to recieve vault performance and management fees\\n     * @param performanceFee is the perfomance fee pct.\\n     * @param tokenName is the name of the token\\n     * @param tokenSymbol is the symbol of the token\\n     * @param _vaultParams is the struct with vault general data\\n     */\\n    function verifyInitializerParams(\\n        address owner,\\n        address keeper,\\n        address feeRecipient,\\n        uint256 performanceFee,\\n        uint256 managementFee,\\n        string calldata tokenName,\\n        string calldata tokenSymbol,\\n        Vault.VaultParams calldata _vaultParams\\n    ) external pure {\\n        require(owner != address(0), \\\"!owner\\\");\\n        require(keeper != address(0), \\\"!keeper\\\");\\n        require(feeRecipient != address(0), \\\"!feeRecipient\\\");\\n        require(\\n            performanceFee < 100 * Vault.FEE_MULTIPLIER,\\n            \\\"performanceFee >= 100%\\\"\\n        );\\n        require(\\n            managementFee < 100 * Vault.FEE_MULTIPLIER,\\n            \\\"managementFee >= 100%\\\"\\n        );\\n        require(bytes(tokenName).length > 0, \\\"!tokenName\\\");\\n        require(bytes(tokenSymbol).length > 0, \\\"!tokenSymbol\\\");\\n\\n        require(_vaultParams.asset != address(0), \\\"!asset\\\");\\n        require(_vaultParams.underlying != address(0), \\\"!underlying\\\");\\n        require(_vaultParams.minimumSupply > 0, \\\"!minimumSupply\\\");\\n        require(_vaultParams.cap > 0, \\\"!cap\\\");\\n        require(\\n            _vaultParams.cap > _vaultParams.minimumSupply,\\n            \\\"cap has to be higher than minimumSupply\\\"\\n        );\\n    }\\n\\n    /**\\n     * @notice Gets the next options expiry timestamp\\n     * @param currentExpiry is the expiry timestamp of the current option\\n     * Reference: https://codereview.stackexchange.com/a/33532\\n     * Examples:\\n     * getNextFriday(week 1 thursday) -> week 1 friday\\n     * getNextFriday(week 1 friday) -> week 2 friday\\n     * getNextFriday(week 1 saturday) -> week 2 friday\\n     */\\n    function getNextFriday(uint256 currentExpiry)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        // dayOfWeek = 0 (sunday) - 6 (saturday)\\n        uint256 dayOfWeek = ((currentExpiry / 1 days) + 4) % 7;\\n        uint256 nextFriday = currentExpiry + ((7 + 5 - dayOfWeek) % 7) * 1 days;\\n        uint256 friday8am = nextFriday - (nextFriday % (24 hours)) + (8 hours);\\n\\n        // If the passed currentExpiry is day=Friday hour>8am, we simply increment it by a week to next Friday\\n        if (currentExpiry >= friday8am) {\\n            friday8am += 7 days;\\n        }\\n        return friday8am;\\n    }\\n}\\n\",\"keccak256\":\"0x984a52e5ee2bda45b49802741da143999c726fbcc51d6604df02ef44076cd8d7\",\"license\":\"MIT\"},\"contracts/libraries/VaultLifecycleSTETH.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport {SafeMath} from \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport {DSMath} from \\\"../vendor/DSMath.sol\\\";\\nimport {\\n    SafeERC20\\n} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {VaultLifecycle} from \\\"./VaultLifecycle.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {Vault} from \\\"./Vault.sol\\\";\\nimport {ShareMath} from \\\"./ShareMath.sol\\\";\\nimport {ISTETH, IWSTETH} from \\\"../interfaces/ISTETH.sol\\\";\\nimport {IWETH} from \\\"../interfaces/IWETH.sol\\\";\\nimport {ICRV} from \\\"../interfaces/ICRV.sol\\\";\\nimport {IStrikeSelection} from \\\"../interfaces/IRibbon.sol\\\";\\nimport {GnosisAuction} from \\\"./GnosisAuction.sol\\\";\\nimport {\\n    IOtokenFactory,\\n    IOtoken,\\n    IController,\\n    GammaTypes\\n} from \\\"../interfaces/GammaInterface.sol\\\";\\nimport {IERC20Detailed} from \\\"../interfaces/IERC20Detailed.sol\\\";\\n\\nlibrary VaultLifecycleSTETH {\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    /**\\n     * @notice Sets the next option the vault will be shorting, and calculates its premium for the auction\\n     * @param strikeSelection is the address of the contract with strike selection logic\\n     * @param optionsPremiumPricer is the address of the contract with the\\n       black-scholes premium calculation logic\\n     * @param premiumDiscount is the vault's discount applied to the premium\\n     * @param closeParams is the struct with details on previous option and strike selection details\\n     * @param vaultParams is the struct with vault general data\\n     * @param vaultState is the struct with vault accounting state\\n     * @param collateralAsset is the address of the collateral asset\\n     * @return otokenAddress is the address of the new option\\n     * @return premium is the premium of the new option\\n     * @return strikePrice is the strike price of the new option\\n     * @return delta is the delta of the new option\\n     */\\n    function commitAndClose(\\n        address strikeSelection,\\n        address optionsPremiumPricer,\\n        uint256 premiumDiscount,\\n        VaultLifecycle.CloseParams calldata closeParams,\\n        Vault.VaultParams storage vaultParams,\\n        Vault.VaultState storage vaultState,\\n        address collateralAsset\\n    )\\n        external\\n        returns (\\n            address otokenAddress,\\n            uint256 premium,\\n            uint256 strikePrice,\\n            uint256 delta\\n        )\\n    {\\n        uint256 expiry;\\n\\n        // uninitialized state\\n        if (closeParams.currentOption == address(0)) {\\n            expiry = VaultLifecycle.getNextFriday(block.timestamp);\\n        } else {\\n            expiry = VaultLifecycle.getNextFriday(\\n                IOtoken(closeParams.currentOption).expiryTimestamp()\\n            );\\n        }\\n\\n        IStrikeSelection selection = IStrikeSelection(strikeSelection);\\n\\n        // calculate strike and delta\\n        (strikePrice, delta) = closeParams.lastStrikeOverrideRound ==\\n            vaultState.round\\n            ? (closeParams.overriddenStrikePrice, selection.delta())\\n            : selection.getStrikePrice(expiry, false);\\n\\n        require(strikePrice != 0, \\\"!strikePrice\\\");\\n\\n        // retrieve address if option already exists, or deploy it\\n        otokenAddress = VaultLifecycle.getOrDeployOtoken(\\n            closeParams,\\n            vaultParams,\\n            vaultParams.underlying,\\n            collateralAsset,\\n            strikePrice,\\n            expiry,\\n            false\\n        );\\n\\n        // get the black scholes premium of the option and adjust premium based on\\n        // steth <-> eth exchange rate\\n        premium = DSMath.wmul(\\n            GnosisAuction.getOTokenPremium(\\n                otokenAddress,\\n                optionsPremiumPricer,\\n                premiumDiscount\\n            ),\\n            IWSTETH(collateralAsset).stEthPerToken()\\n        );\\n\\n        require(premium > 0, \\\"!premium\\\");\\n\\n        return (otokenAddress, premium, strikePrice, delta);\\n    }\\n\\n    /**\\n     * @notice Calculate the shares to mint, new price per share, and\\n      amount of funds to re-allocate as collateral for the new round\\n     * @param currentShareSupply is the total supply of shares\\n     * @param currentBalance is the total balance of the vault\\n     * @param vaultParams is the struct with vault general data\\n     * @param vaultState is the struct with vault accounting state\\n     * @return newLockedAmount is the amount of funds to allocate for the new round\\n     * @return queuedWithdrawAmount is the amount of funds set aside for withdrawal\\n     * @return newPricePerShare is the price per share of the new round\\n     * @return mintShares is the amount of shares to mint from deposits\\n     */\\n    function rollover(\\n        uint256 currentShareSupply,\\n        uint256 currentBalance,\\n        Vault.VaultParams calldata vaultParams,\\n        Vault.VaultState calldata vaultState\\n    )\\n        external\\n        pure\\n        returns (\\n            uint256 newLockedAmount,\\n            uint256 queuedWithdrawAmount,\\n            uint256 newPricePerShare,\\n            uint256 mintShares\\n        )\\n    {\\n        uint256 pendingAmount = uint256(vaultState.totalPending);\\n        uint256 _decimals = vaultParams.decimals;\\n\\n        newPricePerShare = ShareMath.pricePerShare(\\n            currentShareSupply,\\n            currentBalance,\\n            pendingAmount,\\n            _decimals\\n        );\\n\\n        // After closing the short, if the options expire in-the-money\\n        // vault pricePerShare would go down because vault's asset balance decreased.\\n        // This ensures that the newly-minted shares do not take on the loss.\\n        uint256 _mintShares =\\n            ShareMath.assetToShares(pendingAmount, newPricePerShare, _decimals);\\n\\n        uint256 newSupply = currentShareSupply.add(_mintShares);\\n        uint256 queuedAmount =\\n            newSupply > 0\\n                ? ShareMath.sharesToAsset(\\n                    vaultState.queuedWithdrawShares,\\n                    newPricePerShare,\\n                    _decimals\\n                )\\n                : 0;\\n\\n        return (\\n            currentBalance.sub(queuedAmount),\\n            queuedAmount,\\n            newPricePerShare,\\n            _mintShares\\n        );\\n    }\\n\\n    /**\\n     * @notice Creates the actual Opyn short position by depositing collateral and minting otokens\\n     * @param gammaController is the address of the opyn controller contract\\n     * @param marginPool is the address of the opyn margin contract which holds the collateral\\n     * @param oTokenAddress is the address of the otoken to mint\\n     * @param depositAmount is the amount of collateral to deposit\\n     * @return the otoken mint amount\\n     */\\n    function createShort(\\n        address gammaController,\\n        address marginPool,\\n        address oTokenAddress,\\n        uint256 depositAmount\\n    ) external returns (uint256) {\\n        IController controller = IController(gammaController);\\n        uint256 newVaultID =\\n            (controller.getAccountVaultCounter(address(this))).add(1);\\n\\n        // An otoken's collateralAsset is the vault's `asset`\\n        // So in the context of performing Opyn short operations we call them collateralAsset\\n        IOtoken oToken = IOtoken(oTokenAddress);\\n        address collateralAsset = oToken.collateralAsset();\\n\\n        uint256 collateralDecimals =\\n            uint256(IERC20Detailed(collateralAsset).decimals());\\n        uint256 mintAmount;\\n\\n        mintAmount = depositAmount;\\n        if (collateralDecimals > 8) {\\n            uint256 scaleBy = 10**(collateralDecimals.sub(8)); // oTokens have 8 decimals\\n            if (mintAmount > scaleBy) {\\n                mintAmount = depositAmount.div(scaleBy); // scale down from 10**18 to 10**8\\n            }\\n        }\\n\\n        IERC20 collateralToken = IERC20(collateralAsset);\\n        collateralToken.safeApprove(marginPool, depositAmount);\\n\\n        IController.ActionArgs[] memory actions =\\n            new IController.ActionArgs[](3);\\n\\n        actions[0] = IController.ActionArgs(\\n            IController.ActionType.OpenVault,\\n            address(this), // owner\\n            address(this), // receiver\\n            address(0), // asset, otoken\\n            newVaultID, // vaultId\\n            0, // amount\\n            0, //index\\n            \\\"\\\" //data\\n        );\\n\\n        actions[1] = IController.ActionArgs(\\n            IController.ActionType.DepositCollateral,\\n            address(this), // owner\\n            address(this), // address to transfer from\\n            collateralAsset, // deposited asset\\n            newVaultID, // vaultId\\n            depositAmount, // amount\\n            0, //index\\n            \\\"\\\" //data\\n        );\\n\\n        actions[2] = IController.ActionArgs(\\n            IController.ActionType.MintShortOption,\\n            address(this), // owner\\n            address(this), // address to transfer to\\n            oTokenAddress, // option address\\n            newVaultID, // vaultId\\n            mintAmount, // amount\\n            0, //index\\n            \\\"\\\" //data\\n        );\\n\\n        controller.operate(actions);\\n\\n        return mintAmount;\\n    }\\n\\n    /**\\n     * @notice Withdraws stETH + WETH (if necessary) from vault using vault shares\\n     * @param collateralToken is the address of the collateral token\\n     * @param weth is the WETH address\\n     * @param recipient is the recipient\\n     * @param amount is the withdraw amount in `asset`\\n     * @return withdrawAmount is the withdraw amount in `collateralToken`\\n     */\\n    function withdrawYieldAndBaseToken(\\n        address collateralToken,\\n        address weth,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (uint256) {\\n        IWSTETH collateral = IWSTETH(collateralToken);\\n\\n        uint256 withdrawAmount = collateral.getWstETHByStETH(amount);\\n\\n        uint256 yieldTokenBalance =\\n            withdrawYieldToken(collateralToken, recipient, withdrawAmount);\\n\\n        // If there is not enough wstETH in the vault, it withdraws as much as possible and\\n        // transfers the rest in `asset`\\n        if (withdrawAmount > yieldTokenBalance) {\\n            withdrawBaseToken(\\n                collateralToken,\\n                weth,\\n                recipient,\\n                withdrawAmount,\\n                yieldTokenBalance\\n            );\\n        }\\n\\n        return withdrawAmount;\\n    }\\n\\n    /**\\n     * @notice Withdraws stETH from vault\\n     * @param collateralToken is the address of the collateral token\\n     * @param recipient is the recipient\\n     * @param withdrawAmount is the withdraw amount in terms of yearn tokens\\n     * @return yieldTokenBalance is the balance of the yield token\\n     */\\n    function withdrawYieldToken(\\n        address collateralToken,\\n        address recipient,\\n        uint256 withdrawAmount\\n    ) internal returns (uint256) {\\n        IERC20 collateral = IERC20(collateralToken);\\n\\n        uint256 yieldTokenBalance = collateral.balanceOf(address(this));\\n        uint256 yieldTokensToWithdraw =\\n            DSMath.min(yieldTokenBalance, withdrawAmount);\\n        if (yieldTokensToWithdraw > 0) {\\n            collateral.safeTransfer(recipient, yieldTokensToWithdraw);\\n        }\\n\\n        return yieldTokenBalance;\\n    }\\n\\n    /**\\n     * @notice Withdraws `asset` from vault\\n     * @param collateralToken is the address of the collateral token\\n     * @param weth is the WETH address\\n     * @param recipient is the recipient\\n     * @param withdrawAmount is the withdraw amount in terms of yearn tokens\\n     * @param yieldTokenBalance is the collateral token (stETH) balance of the vault\\n     */\\n    function withdrawBaseToken(\\n        address collateralToken,\\n        address weth,\\n        address recipient,\\n        uint256 withdrawAmount,\\n        uint256 yieldTokenBalance\\n    ) internal {\\n        uint256 underlyingTokensToWithdraw =\\n            IWSTETH(collateralToken).getStETHByWstETH(\\n                withdrawAmount.sub(yieldTokenBalance)\\n            );\\n\\n        IWETH(weth).deposit{value: underlyingTokensToWithdraw}();\\n        IERC20(weth).safeTransfer(recipient, underlyingTokensToWithdraw);\\n    }\\n\\n    /**\\n     * @notice Unwraps the necessary amount of the wstETH token\\n     *         and transfers ETH amount to vault\\n     * @param amount is the amount of ETH to withdraw\\n     * @param wstEth is the address of wstETH\\n     * @param stethToken is the address of stETH\\n     * @param crvPool is the address of the steth <-> eth pool on curve\\n     * @param minETHOut is the minimum eth amount to receive from the swap\\n     * @return amountETHOut is the amount of eth unwrapped\\n     available for the withdrawal (may incur curve slippage)\\n     */\\n    function unwrapYieldToken(\\n        uint256 amount,\\n        address wstEth,\\n        address stethToken,\\n        address crvPool,\\n        uint256 minETHOut\\n    ) external returns (uint256) {\\n        require(\\n            amount >= minETHOut,\\n            \\\"Amount withdrawn smaller than minETHOut from swap\\\"\\n        );\\n        require(\\n            minETHOut.mul(10**18).div(amount) >= 0.95 ether,\\n            \\\"Slippage on minETHOut too high\\\"\\n        );\\n\\n        uint256 ethBalance = address(this).balance;\\n        IERC20 steth = IERC20(stethToken);\\n        uint256 stethBalance = steth.balanceOf(address(this));\\n\\n        // 3 different success scenarios\\n        // Scenario 1. We hold enough ETH to satisfy withdrawal. Send it out directly\\n        // Scenario 2. We hold enough wstETH to satisy withdrawal. Unwrap then swap\\n        // Scenario 3. We hold enough ETH + stETH to satisfy withdrawal. Do a swap\\n\\n        // Scenario 1\\n        if (ethBalance >= amount) {\\n            return amount;\\n        }\\n\\n        // Scenario 2\\n        stethBalance = unwrapWstethForWithdrawal(\\n            wstEth,\\n            steth,\\n            ethBalance,\\n            stethBalance,\\n            amount,\\n            minETHOut\\n        );\\n\\n        // Scenario 3\\n        // Now that we satisfied the ETH + stETH sum, we swap the stETH amounts necessary\\n        // to facilitate a withdrawal\\n\\n        // This won't underflow since we already asserted that ethBalance < amount before this\\n        uint256 stEthAmountToSwap =\\n            DSMath.min(amount.sub(ethBalance), stethBalance);\\n\\n        uint256 ethAmountOutFromSwap =\\n            swapStEthToEth(steth, crvPool, stEthAmountToSwap);\\n\\n        uint256 totalETHOut = ethBalance.add(ethAmountOutFromSwap);\\n\\n        // Since minETHOut is derived from calling the Curve pool's getter,\\n        // it reverts in the worst case where the user needs to unwrap and sell\\n        // 100% of their ETH withdrawal amount\\n        require(\\n            totalETHOut >= minETHOut,\\n            \\\"Output ETH amount smaller than minETHOut\\\"\\n        );\\n\\n        return totalETHOut;\\n    }\\n\\n    /**\\n     * @notice Unwraps the required amount of wstETH to a target ETH amount\\n     * @param wstEthAddress is the address for wstETH\\n     * @param steth is the ERC20 of stETH\\n     * @param startStEthBalance is the starting stETH balance used to determine how much more to unwrap\\n     * @param ethAmount is the ETH amount needed for the contract\\n     * @param minETHOut is the ETH amount but adjusted for slippage\\n     * @return the new stETH balance\\n     */\\n    function unwrapWstethForWithdrawal(\\n        address wstEthAddress,\\n        IERC20 steth,\\n        uint256 ethBalance,\\n        uint256 startStEthBalance,\\n        uint256 ethAmount,\\n        uint256 minETHOut\\n    ) internal returns (uint256) {\\n        uint256 ethstEthSum = ethBalance.add(startStEthBalance);\\n\\n        if (ethstEthSum < minETHOut) {\\n            uint256 stethNeededFromUnwrap = ethAmount.sub(ethstEthSum);\\n            IWSTETH wstEth = IWSTETH(wstEthAddress);\\n            uint256 wstAmountToUnwrap =\\n                wstEth.getWstETHByStETH(stethNeededFromUnwrap);\\n\\n            wstEth.unwrap(wstAmountToUnwrap);\\n\\n            uint256 newStEthBalance = steth.balanceOf(address(this));\\n            require(\\n                ethBalance.add(newStEthBalance) >= minETHOut,\\n                \\\"Unwrapping wstETH did not return sufficient stETH\\\"\\n            );\\n            return newStEthBalance;\\n        }\\n        return startStEthBalance;\\n    }\\n\\n    /**\\n     * @notice Swaps from stEth to ETH on the Lido Curve pool\\n     * @param steth is the address for the Lido staked ether\\n     * @param crvPool is the Curve pool address to do the swap\\n     * @param stEthAmount is the stEth amount to be swapped to Ether\\n     * @return ethAmountOutFromSwap is the returned ETH amount from swap\\n     */\\n    function swapStEthToEth(\\n        IERC20 steth,\\n        address crvPool,\\n        uint256 stEthAmount\\n    ) internal returns (uint256) {\\n        steth.safeApprove(crvPool, stEthAmount);\\n\\n        // CRV SWAP HERE from steth -> eth\\n        // 0 = ETH, 1 = STETH\\n        // We are setting 1, which is the smallest possible value for the _minAmountOut parameter\\n        // However it is fine because we check that the totalETHOut >= minETHOut at the end\\n        // which makes sandwich attacks not possible\\n        uint256 ethAmountOutFromSwap =\\n            ICRV(crvPool).exchange(1, 0, stEthAmount, 1);\\n\\n        return ethAmountOutFromSwap;\\n    }\\n\\n    /**\\n     * @notice Wraps the necessary amount of the base token to the yield-bearing yearn token\\n     * @param weth is the address of weth\\n     * @param collateralToken is the address of the collateral token\\n     */\\n    function wrapToYieldToken(\\n        address weth,\\n        address collateralToken,\\n        address steth\\n    ) external {\\n        // Unwrap all weth premiums transferred to contract\\n        IWETH wethToken = IWETH(weth);\\n        uint256 wethBalance = wethToken.balanceOf(address(this));\\n\\n        if (wethBalance > 0) {\\n            wethToken.withdraw(wethBalance);\\n        }\\n\\n        uint256 ethBalance = address(this).balance;\\n\\n        IWSTETH collateral = IWSTETH(collateralToken);\\n        IERC20 stethToken = IERC20(steth);\\n\\n        if (ethBalance > 0) {\\n            // Send eth to Lido, recieve steth\\n            ISTETH(steth).submit{value: ethBalance}(address(this));\\n        }\\n\\n        // Get all steth in contract\\n        uint256 stethBalance = stethToken.balanceOf(address(this));\\n\\n        if (stethBalance > 0) {\\n            // approve wrap\\n            stethToken.safeApprove(collateralToken, stethBalance.add(1));\\n            // Wrap to wstETH - need to add 1 to steth balance as it is innacurate\\n            collateral.wrap(stethBalance.add(1));\\n        }\\n    }\\n\\n    /**\\n     * @notice Helper function to make either an ETH transfer or ERC20 transfer\\n     * @param recipient is the receiving address\\n     * @param amount is the transfer amount\\n     */\\n    function transferAsset(address recipient, uint256 amount) public {\\n        (bool success, ) = payable(recipient).call{value: amount}(\\\"\\\");\\n        require(success, \\\"!success\\\");\\n    }\\n}\\n\",\"keccak256\":\"0x2a3ec403f7142fc86c70bb73b79593091b70603590c8f1a70e77ebb364add85f\",\"license\":\"MIT\"},\"contracts/vendor/DSMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\n/// math.sol -- mixin for inline numerical wizardry\\n\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity >0.4.13;\\n\\nlibrary DSMath {\\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x + y) >= x, \\\"ds-math-add-overflow\\\");\\n    }\\n\\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require((z = x - y) <= x, \\\"ds-math-sub-underflow\\\");\\n    }\\n\\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        require(y == 0 || (z = x * y) / y == x, \\\"ds-math-mul-overflow\\\");\\n    }\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x <= y ? x : y;\\n    }\\n\\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\\n        return x >= y ? x : y;\\n    }\\n\\n    uint256 constant WAD = 10**18;\\n    uint256 constant RAY = 10**27;\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), WAD / 2) / WAD;\\n    }\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, y), RAY / 2) / RAY;\\n    }\\n\\n    //rounds to zero if x*y < WAD / 2\\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, WAD), y / 2) / y;\\n    }\\n\\n    //rounds to zero if x*y < RAY / 2\\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = add(mul(x, RAY), y / 2) / y;\\n    }\\n\\n    // This famous algorithm is called \\\"exponentiation by squaring\\\"\\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\\n    //\\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\\n    //\\n    // These facts are why it works:\\n    //\\n    //  If n is even, then x^n = (x^2)^(n/2).\\n    //  If n is odd,  then x^n = x * x^(n-1),\\n    //   and applying the equation for even x gives\\n    //    x^n = x * (x^2)^((n-1) / 2).\\n    //\\n    //  Also, EVM division is flooring and\\n    //    floor[(n-1) / 2] = floor[n / 2].\\n    //\\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\\n        z = n % 2 != 0 ? x : RAY;\\n\\n        for (n /= 2; n != 0; n /= 2) {\\n            x = rmul(x, x);\\n\\n            if (n % 2 != 0) {\\n                z = rmul(z, x);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe1c6bb5cff7c83c85792349f61b3f4faf6e22bb02fa95d7af7b269e59a3902b2\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6129c161003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c80632ffe43f8116100655780632ffe43f8146101295780635c921eb9146101495780636627a9d41461016b578063c29d2a3c1461018b57600080fd5b806303a20e3d1461008c5780631d6c3157146100db5780632904c23914610109575b600080fd5b81801561009857600080fd5b506100ac6100a7366004612406565b6101be565b604080516001600160a01b03909516855260208501939093529183015260608201526080015b60405180910390f35b8180156100e757600080fd5b506100fb6100f636600461252f565b6104d2565b6040519081526020016100d2565b81801561011557600080fd5b506100fb6101243660046123b6565b6106f9565b81801561013557600080fd5b506100fb6101443660046123b6565b610b84565b81801561015557600080fd5b50610169610164366004612483565b610c33565b005b81801561017757600080fd5b5061016961018636600461236c565b610cc6565b61019e6101993660046125ac565b610f64565b6040805194855260208501939093529183015260608201526080016100d2565b600080808080806101d560608b0160408c01612334565b6001600160a01b031614156101f4576101ed4261101b565b905061027f565b61027c61020760608b0160408c01612334565b6001600160a01b031663ade6e2aa6040518163ffffffff1660e01b815260040160206040518083038186803b15801561023f57600080fd5b505afa158015610253573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102779190612517565b61101b565b90505b86548c9061ffff1661029760a08c0160808d016124f5565b61ffff16146103235760405163e436b89160e01b815260048101839052600060248201526001600160a01b0382169063e436b89190604401604080518083038186803b1580156102e657600080fd5b505afa1580156102fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061031e9190612589565b610399565b8960a00135816001600160a01b03166312b495a86040518163ffffffff1660e01b815260040160206040518083038186803b15801561036157600080fd5b505afa158015610375573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103999190612517565b9094509250836103df5760405162461bcd60e51b815260206004820152600c60248201526b21737472696b65507269636560a01b60448201526064015b60405180910390fd5b60018901546103ff908b908b906001600160a01b03168a888760006110bc565b955061048561040f878e8e611250565b886001600160a01b031663035faf826040518163ffffffff1660e01b815260040160206040518083038186803b15801561044857600080fd5b505afa15801561045c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104809190612517565b6114d2565b9450600085116104c25760405162461bcd60e51b8152602060048201526008602482015267217072656d69756d60c01b60448201526064016103d6565b5050975097509750979350505050565b60008186101561053e5760405162461bcd60e51b815260206004820152603160248201527f416d6f756e742077697468647261776e20736d616c6c6572207468616e206d6960448201527006e4554484f75742066726f6d207377617607c1b60648201526084016103d6565b670d2f13f7789f00006105638761055d85670de0b6b3a764000061150c565b9061151e565b10156105b15760405162461bcd60e51b815260206004820152601e60248201527f536c697070616765206f6e206d696e4554484f757420746f6f2068696768000060448201526064016103d6565b6040516370a0823160e01b8152306004820152479085906000906001600160a01b038316906370a082319060240160206040518083038186803b1580156105f757600080fd5b505afa15801561060b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061062f9190612517565b9050888310610643578893505050506106f0565b610651888385848d8a61152a565b905060006106686106628b86611754565b83611760565b90506000610677848984611777565b905060006106858683611822565b9050878110156106e85760405162461bcd60e51b815260206004820152602860248201527f4f75747075742045544820616d6f756e7420736d616c6c6572207468616e206d6044820152671a5b91551213dd5d60c21b60648201526084016103d6565b955050505050505b95945050505050565b604051636553690d60e11b815230600482015260009085908290610784906001906001600160a01b0385169063caa6d21a9060240160206040518083038186803b15801561074657600080fd5b505afa15801561075a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061077e9190612517565b90611822565b905060008590506000816001600160a01b031663aabaecd66040518163ffffffff1660e01b815260040160206040518083038186803b1580156107c657600080fd5b505afa1580156107da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107fe9190612350565b90506000816001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b15801561083b57600080fd5b505afa15801561084f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108739190612619565b60ff1690508660088211156108b357600061088f836008611754565b61089a90600a612816565b9050808211156108b1576108ae898261151e565b91505b505b826108c86001600160a01b0382168c8b61182e565b60408051600380825260808201909252600091816020015b610944604080516101008101909152806000815260200160006001600160a01b0316815260200160006001600160a01b0316815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001606081525090565b8152602001906001900390816108e0579050506040805161010081019091529091508060008152602001306001600160a01b03168152602001306001600160a01b0316815260200160006001600160a01b03168152602001888152602001600081526020016000815260200160405180602001604052806000815250815250816000815181106109e457634e487b7160e01b600052603260045260246000fd5b60209081029190910101526040805161010081019091528060058152602001306001600160a01b03168152602001306001600160a01b03168152602001866001600160a01b031681526020018881526020018b8152602001600081526020016040518060200160405280600081525081525081600181518110610a7757634e487b7160e01b600052603260045260246000fd5b60209081029190910101526040805161010081019091528060018152602001306001600160a01b03168152602001306001600160a01b031681526020018c6001600160a01b03168152602001888152602001848152602001600081526020016040518060200160405280600081525081525081600281518110610b0a57634e487b7160e01b600052603260045260246000fd5b6020908102919091010152604051635b0bf86360e11b81526001600160a01b0389169063b617f0c690610b419084906004016126b6565b600060405180830381600087803b158015610b5b57600080fd5b505af1158015610b6f573d6000803e3d6000fd5b50949f9e505050505050505050505050505050565b60405162b0e38960e81b815260048101829052600090859082906001600160a01b0383169063b0e389009060240160206040518083038186803b158015610bca57600080fd5b505afa158015610bde573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c029190612517565b90506000610c11888784611985565b905080821115610c2857610c288888888585611a37565b509695505050505050565b6000826001600160a01b03168260405160006040518083038185875af1925050503d8060008114610c80576040519150601f19603f3d011682016040523d82523d6000602084013e610c85565b606091505b5050905080610cc15760405162461bcd60e51b8152602060048201526008602482015267217375636365737360c01b60448201526064016103d6565b505050565b6040516370a0823160e01b815230600482015283906000906001600160a01b038316906370a082319060240160206040518083038186803b158015610d0a57600080fd5b505afa158015610d1e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d429190612517565b90508015610da557604051632e1a7d4d60e01b8152600481018290526001600160a01b03831690632e1a7d4d90602401600060405180830381600087803b158015610d8c57600080fd5b505af1158015610da0573d6000803e3d6000fd5b505050505b4784848215610e2b5760405163a1903eab60e01b81523060048201526001600160a01b0387169063a1903eab9085906024016020604051808303818588803b158015610df057600080fd5b505af1158015610e04573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190610e299190612517565b505b6040516370a0823160e01b81523060048201526000906001600160a01b038316906370a082319060240160206040518083038186803b158015610e6d57600080fd5b505afa158015610e81573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ea59190612517565b90508015610f5957610ecd88610ebc836001611822565b6001600160a01b038516919061182e565b6001600160a01b03831663ea598cb0610ee7836001611822565b6040518263ffffffff1660e01b8152600401610f0591815260200190565b602060405180830381600087803b158015610f1f57600080fd5b505af1158015610f33573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f579190612517565b505b505050505050505050565b600080808080610f7a60808701606088016124ce565b6001600160801b031690506000610f976040890160208a016125fd565b60ff169050610fa88a8a8484611b34565b93506000610fb7838684611b6a565b90506000610fc58c83611822565b90506000808211610fd7576000610ffa565b610ffa610fea60a08c0160808d016124ce565b6001600160801b03168886611bcd565b90506110068c82611754565b98509650909350505050945094509450949050565b600080600761102d62015180856127bf565b6110389060046127a7565b6110429190612924565b90506000600761105383600c6128dd565b61105d9190612924565b61106a90620151806128be565b61107490856127a7565b905060006110856201518083612924565b61108f90836128dd565b61109b906170806127a7565b90508085106110b4576110b162093a80826127a7565b90505b949350505050565b6000806110cc60208a018a612334565b905060006001600160a01b0382166311547054896110f060408e0160208f01612334565b8a8a8a8a6040518763ffffffff1660e01b81526004016111159695949392919061267d565b60206040518083038186803b15801561112d57600080fd5b505afa158015611141573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111659190612350565b90506001600160a01b0381161561117f5791506112459050565b6000826001600160a01b031663c09746308a8d60200160208101906111a49190612334565b8b8b8b8b6040518763ffffffff1660e01b81526004016111c99695949392919061267d565b602060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061121b9190612350565b9050611240818b8a8e60200160208101906112369190612334565b8f60600135611c2f565b925050505b979650505050505050565b60008084905060008490506000816001600160a01b031663fc3d42e8846001600160a01b031663c52987cf6040518163ffffffff1660e01b815260040160206040518083038186803b1580156112a557600080fd5b505afa1580156112b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112dd9190612517565b856001600160a01b031663ade6e2aa6040518163ffffffff1660e01b815260040160206040518083038186803b15801561131657600080fd5b505afa15801561132a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061134e9190612517565b866001600160a01b031663f3c274a66040518163ffffffff1660e01b815260040160206040518083038186803b15801561138757600080fd5b505afa15801561139b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113bf91906124ae565b6040516001600160e01b031960e086901b168152600481019390935260248301919091521515604482015260640160206040518083038186803b15801561140557600080fd5b505afa158015611419573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061143d9190612517565b905061145861144e600a60646128be565b61055d838861150c565b90506bffffffffffffffffffffffff8111156114c65760405162461bcd60e51b815260206004820152602760248201527f6f7074696f6e5072656d69756d203e20747970652875696e74393629206d61786044820152662076616c75652160c81b60648201526084016103d6565b925050505b9392505050565b6000670de0b6b3a76400006115026114ea8585612064565b6114fd6002670de0b6b3a76400006127bf565b6120cb565b6114cb91906127bf565b60006114cb82846128be565b92915050565b60006114cb82846127bf565b6000806115378686611822565b90508281101561174557600061154d8583611754565b60405162b0e38960e81b81526004810182905290915089906000906001600160a01b0383169063b0e389009060240160206040518083038186803b15801561159457600080fd5b505afa1580156115a8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115cc9190612517565b604051636f074d1f60e11b8152600481018290529091506001600160a01b0383169063de0e9a3e90602401602060405180830381600087803b15801561161157600080fd5b505af1158015611625573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116499190612517565b506040516370a0823160e01b81523060048201526000906001600160a01b038c16906370a082319060240160206040518083038186803b15801561168c57600080fd5b505afa1580156116a0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116c49190612517565b9050866116d18b83611822565b10156117395760405162461bcd60e51b815260206004820152603160248201527f556e7772617070696e672077737445544820646964206e6f742072657475726e604482015270040e6eaccccd2c6d2cadce840e6e88aa89607b1b60648201526084016103d6565b945061174a9350505050565b849150505b9695505050505050565b60006114cb82846128dd565b60008183111561177057816114cb565b5090919050565b600061178d6001600160a01b038516848461182e565b604051630f7c084960e21b8152600160048201819052600060248301819052604483018590526064830191909152906001600160a01b03851690633df0212490608401602060405180830381600087803b1580156117ea57600080fd5b505af11580156117fe573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106f09190612517565b60006114cb82846127a7565b8015806118b75750604051636eb1769f60e11b81523060048201526001600160a01b03838116602483015284169063dd62ed3e9060440160206040518083038186803b15801561187d57600080fd5b505afa158015611891573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118b59190612517565b155b6119225760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b60648201526084016103d6565b6040516001600160a01b038316602482015260448101829052610cc190849063095ea7b360e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152612120565b6040516370a0823160e01b8152306004820152600090849082906001600160a01b038316906370a082319060240160206040518083038186803b1580156119cb57600080fd5b505afa1580156119df573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a039190612517565b90506000611a118286611760565b90508015611a2d57611a2d6001600160a01b03841687836121f2565b5095945050505050565b60006001600160a01b03861663bb2952fc611a528585611754565b6040518263ffffffff1660e01b8152600401611a7091815260200190565b60206040518083038186803b158015611a8857600080fd5b505afa158015611a9c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ac09190612517565b9050846001600160a01b031663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b158015611afd57600080fd5b505af1158015611b11573d6000803e3d6000fd5b50611b2c935050506001600160a01b038716905085836121f2565b505050505050565b600080611b4283600a612816565b905060008611611b52578061174a565b61174a8661055d611b638888611754565b849061150c565b600060018311611bb45760405162461bcd60e51b8152602060048201526015602482015274496e76616c6964206173736574506572536861726560581b60448201526064016103d6565b6110b48361055d611bc685600a612816565b879061150c565b600060018311611c175760405162461bcd60e51b8152602060048201526015602482015274496e76616c6964206173736574506572536861726560581b60448201526064016103d6565b6110b4611c2583600a612816565b61055d868661150c565b6001600160a01b038516611c765760405162461bcd60e51b815260206004820152600e60248201526d216f746f6b656e4164647265737360901b60448201526064016103d6565b8354604080516379e13a5360e11b81529051879260ff161515916001600160a01b0384169163f3c274a691600480820192602092909190829003018186803b158015611cc157600080fd5b505afa158015611cd5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cf991906124ae565b151514611d385760405162461bcd60e51b815260206004820152600d60248201526c0a8f2e0ca40dad2e6dac2e8c6d609b1b60448201526064016103d6565b600185015460408051631c56369f60e21b815290516001600160a01b0392831692841691637158da7c916004808301926020929190829003018186803b158015611d8157600080fd5b505afa158015611d95573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611db99190612350565b6001600160a01b031614611e075760405162461bcd60e51b815260206004820152601560248201527415dc9bdb99c81d5b99195c9b1e5a5b99d05cdcd95d605a1b60448201526064016103d6565b836001600160a01b0316816001600160a01b031663aabaecd66040518163ffffffff1660e01b815260040160206040518083038186803b158015611e4a57600080fd5b505afa158015611e5e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e829190612350565b6001600160a01b031614611ed05760405162461bcd60e51b815260206004820152601560248201527415dc9bdb99c818dbdb1b185d195c985b105cdcd95d605a1b60448201526064016103d6565b826001600160a01b0316816001600160a01b03166317d69bc86040518163ffffffff1660e01b815260040160206040518083038186803b158015611f1357600080fd5b505afa158015611f27573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f4b9190612350565b6001600160a01b031614611f975760405162461bcd60e51b8152602060048201526013602482015272737472696b65417373657420213d205553444360681b60448201526064016103d6565b6000611fa34284611822565b905080826001600160a01b031663ade6e2aa6040518163ffffffff1660e01b815260040160206040518083038186803b158015611fdf57600080fd5b505afa158015611ff3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120179190612517565b101561205b5760405162461bcd60e51b8152602060048201526013602482015272457870697279206265666f72652064656c617960681b60448201526064016103d6565b50505050505050565b60008115806120885750828261207a81836128be565b925061208690836127bf565b145b6115185760405162461bcd60e51b815260206004820152601460248201527364732d6d6174682d6d756c2d6f766572666c6f7760601b60448201526064016103d6565b6000826120d883826127a7565b91508110156115185760405162461bcd60e51b815260206004820152601460248201527364732d6d6174682d6164642d6f766572666c6f7760601b60448201526064016103d6565b6000612175826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166122229092919063ffffffff16565b805190915015610cc1578080602001905181019061219391906124ae565b610cc15760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016103d6565b6040516001600160a01b038316602482015260448101829052610cc190849063a9059cbb60e01b9060640161194e565b60606110b4848460008585843b61227b5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016103d6565b600080866001600160a01b031685876040516122979190612661565b60006040518083038185875af1925050503d80600081146122d4576040519150601f19603f3d011682016040523d82523d6000602084013e6122d9565b606091505b5091509150611245828286606083156122f35750816114cb565b8251156123035782518084602001fd5b8160405162461bcd60e51b81526004016103d69190612794565b600060c0828403121561232e578081fd5b50919050565b600060208284031215612345578081fd5b81356114cb81612964565b600060208284031215612361578081fd5b81516114cb81612964565b600080600060608486031215612380578182fd5b833561238b81612964565b9250602084013561239b81612964565b915060408401356123ab81612964565b809150509250925092565b600080600080608085870312156123cb578081fd5b84356123d681612964565b935060208501356123e681612964565b925060408501356123f681612964565b9396929550929360600135925050565b6000806000806000806000610180888a031215612421578283fd5b873561242c81612964565b9650602088013561243c81612964565b9550604088013594506124528960608a0161231d565b93506101208801359250610140880135915061016088013561247381612964565b8091505092959891949750929550565b60008060408385031215612495578182fd5b82356124a081612964565b946020939093013593505050565b6000602082840312156124bf578081fd5b815180151581146114cb578182fd5b6000602082840312156124df578081fd5b81356001600160801b03811681146114cb578182fd5b600060208284031215612506578081fd5b813561ffff811681146114cb578182fd5b600060208284031215612528578081fd5b5051919050565b600080600080600060a08688031215612546578081fd5b85359450602086013561255881612964565b9350604086013561256881612964565b9250606086013561257881612964565b949793965091946080013592915050565b6000806040838503121561259b578182fd5b505080516020909101519092909150565b6000806000808486036101a08112156125c3578283fd5b85359450602086013593506125db876040880161231d565b925060a060ff19820112156125ee578182fd5b50929591945092610100019150565b60006020828403121561260e578081fd5b81356114cb8161297c565b60006020828403121561262a578081fd5b81516114cb8161297c565b6000815180845261264d8160208601602086016128f4565b601f01601f19169290920160200192915050565b600082516126738184602087016128f4565b9190910192915050565b6001600160a01b03968716815294861660208601529290941660408401526060830152608082019290925290151560a082015260c00190565b60006020808301818452808551808352604092508286019150828160051b870101848801865b8381101561278657603f1989840301855281516101008151600b811061271057634e487b7160e01b8b52602160045260248bfd5b8552818901516001600160a01b039081168a87015288830151811689870152606080840151909116908601526080808301519086015260a0808301519086015260c0808301519086015260e09182015191850181905261277281860183612635565b9689019694505050908601906001016126dc565b509098975050505050505050565b6020815260006114cb6020830184612635565b600082198211156127ba576127ba612938565b500190565b6000826127ce576127ce61294e565b500490565b600181815b8085111561280e5781600019048211156127f4576127f4612938565b8085161561280157918102915b93841c93908002906127d8565b509250929050565b60006114cb838360008261282c57506001611518565b8161283957506000611518565b816001811461284f576002811461285957612875565b6001915050611518565b60ff84111561286a5761286a612938565b50506001821b611518565b5060208310610133831016604e8410600b8410161715612898575081810a611518565b6128a283836127d3565b80600019048211156128b6576128b6612938565b029392505050565b60008160001904831182151516156128d8576128d8612938565b500290565b6000828210156128ef576128ef612938565b500390565b60005b8381101561290f5781810151838201526020016128f7565b8381111561291e576000848401525b50505050565b6000826129335761293361294e565b500690565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b6001600160a01b038116811461297957600080fd5b50565b60ff8116811461297957600080fdfea2646970667358221220a1a6907b252be7837e43055a93480d3428d6e6725bfebb5f07ef947269c0d8b964736f6c63430008040033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c80632ffe43f8116100655780632ffe43f8146101295780635c921eb9146101495780636627a9d41461016b578063c29d2a3c1461018b57600080fd5b806303a20e3d1461008c5780631d6c3157146100db5780632904c23914610109575b600080fd5b81801561009857600080fd5b506100ac6100a7366004612406565b6101be565b604080516001600160a01b03909516855260208501939093529183015260608201526080015b60405180910390f35b8180156100e757600080fd5b506100fb6100f636600461252f565b6104d2565b6040519081526020016100d2565b81801561011557600080fd5b506100fb6101243660046123b6565b6106f9565b81801561013557600080fd5b506100fb6101443660046123b6565b610b84565b81801561015557600080fd5b50610169610164366004612483565b610c33565b005b81801561017757600080fd5b5061016961018636600461236c565b610cc6565b61019e6101993660046125ac565b610f64565b6040805194855260208501939093529183015260608201526080016100d2565b600080808080806101d560608b0160408c01612334565b6001600160a01b031614156101f4576101ed4261101b565b905061027f565b61027c61020760608b0160408c01612334565b6001600160a01b031663ade6e2aa6040518163ffffffff1660e01b815260040160206040518083038186803b15801561023f57600080fd5b505afa158015610253573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102779190612517565b61101b565b90505b86548c9061ffff1661029760a08c0160808d016124f5565b61ffff16146103235760405163e436b89160e01b815260048101839052600060248201526001600160a01b0382169063e436b89190604401604080518083038186803b1580156102e657600080fd5b505afa1580156102fa573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061031e9190612589565b610399565b8960a00135816001600160a01b03166312b495a86040518163ffffffff1660e01b815260040160206040518083038186803b15801561036157600080fd5b505afa158015610375573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103999190612517565b9094509250836103df5760405162461bcd60e51b815260206004820152600c60248201526b21737472696b65507269636560a01b60448201526064015b60405180910390fd5b60018901546103ff908b908b906001600160a01b03168a888760006110bc565b955061048561040f878e8e611250565b886001600160a01b031663035faf826040518163ffffffff1660e01b815260040160206040518083038186803b15801561044857600080fd5b505afa15801561045c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104809190612517565b6114d2565b9450600085116104c25760405162461bcd60e51b8152602060048201526008602482015267217072656d69756d60c01b60448201526064016103d6565b5050975097509750979350505050565b60008186101561053e5760405162461bcd60e51b815260206004820152603160248201527f416d6f756e742077697468647261776e20736d616c6c6572207468616e206d6960448201527006e4554484f75742066726f6d207377617607c1b60648201526084016103d6565b670d2f13f7789f00006105638761055d85670de0b6b3a764000061150c565b9061151e565b10156105b15760405162461bcd60e51b815260206004820152601e60248201527f536c697070616765206f6e206d696e4554484f757420746f6f2068696768000060448201526064016103d6565b6040516370a0823160e01b8152306004820152479085906000906001600160a01b038316906370a082319060240160206040518083038186803b1580156105f757600080fd5b505afa15801561060b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061062f9190612517565b9050888310610643578893505050506106f0565b610651888385848d8a61152a565b905060006106686106628b86611754565b83611760565b90506000610677848984611777565b905060006106858683611822565b9050878110156106e85760405162461bcd60e51b815260206004820152602860248201527f4f75747075742045544820616d6f756e7420736d616c6c6572207468616e206d6044820152671a5b91551213dd5d60c21b60648201526084016103d6565b955050505050505b95945050505050565b604051636553690d60e11b815230600482015260009085908290610784906001906001600160a01b0385169063caa6d21a9060240160206040518083038186803b15801561074657600080fd5b505afa15801561075a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061077e9190612517565b90611822565b905060008590506000816001600160a01b031663aabaecd66040518163ffffffff1660e01b815260040160206040518083038186803b1580156107c657600080fd5b505afa1580156107da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107fe9190612350565b90506000816001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b15801561083b57600080fd5b505afa15801561084f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108739190612619565b60ff1690508660088211156108b357600061088f836008611754565b61089a90600a612816565b9050808211156108b1576108ae898261151e565b91505b505b826108c86001600160a01b0382168c8b61182e565b60408051600380825260808201909252600091816020015b610944604080516101008101909152806000815260200160006001600160a01b0316815260200160006001600160a01b0316815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001606081525090565b8152602001906001900390816108e0579050506040805161010081019091529091508060008152602001306001600160a01b03168152602001306001600160a01b0316815260200160006001600160a01b03168152602001888152602001600081526020016000815260200160405180602001604052806000815250815250816000815181106109e457634e487b7160e01b600052603260045260246000fd5b60209081029190910101526040805161010081019091528060058152602001306001600160a01b03168152602001306001600160a01b03168152602001866001600160a01b031681526020018881526020018b8152602001600081526020016040518060200160405280600081525081525081600181518110610a7757634e487b7160e01b600052603260045260246000fd5b60209081029190910101526040805161010081019091528060018152602001306001600160a01b03168152602001306001600160a01b031681526020018c6001600160a01b03168152602001888152602001848152602001600081526020016040518060200160405280600081525081525081600281518110610b0a57634e487b7160e01b600052603260045260246000fd5b6020908102919091010152604051635b0bf86360e11b81526001600160a01b0389169063b617f0c690610b419084906004016126b6565b600060405180830381600087803b158015610b5b57600080fd5b505af1158015610b6f573d6000803e3d6000fd5b50949f9e505050505050505050505050505050565b60405162b0e38960e81b815260048101829052600090859082906001600160a01b0383169063b0e389009060240160206040518083038186803b158015610bca57600080fd5b505afa158015610bde573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c029190612517565b90506000610c11888784611985565b905080821115610c2857610c288888888585611a37565b509695505050505050565b6000826001600160a01b03168260405160006040518083038185875af1925050503d8060008114610c80576040519150601f19603f3d011682016040523d82523d6000602084013e610c85565b606091505b5050905080610cc15760405162461bcd60e51b8152602060048201526008602482015267217375636365737360c01b60448201526064016103d6565b505050565b6040516370a0823160e01b815230600482015283906000906001600160a01b038316906370a082319060240160206040518083038186803b158015610d0a57600080fd5b505afa158015610d1e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d429190612517565b90508015610da557604051632e1a7d4d60e01b8152600481018290526001600160a01b03831690632e1a7d4d90602401600060405180830381600087803b158015610d8c57600080fd5b505af1158015610da0573d6000803e3d6000fd5b505050505b4784848215610e2b5760405163a1903eab60e01b81523060048201526001600160a01b0387169063a1903eab9085906024016020604051808303818588803b158015610df057600080fd5b505af1158015610e04573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190610e299190612517565b505b6040516370a0823160e01b81523060048201526000906001600160a01b038316906370a082319060240160206040518083038186803b158015610e6d57600080fd5b505afa158015610e81573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ea59190612517565b90508015610f5957610ecd88610ebc836001611822565b6001600160a01b038516919061182e565b6001600160a01b03831663ea598cb0610ee7836001611822565b6040518263ffffffff1660e01b8152600401610f0591815260200190565b602060405180830381600087803b158015610f1f57600080fd5b505af1158015610f33573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f579190612517565b505b505050505050505050565b600080808080610f7a60808701606088016124ce565b6001600160801b031690506000610f976040890160208a016125fd565b60ff169050610fa88a8a8484611b34565b93506000610fb7838684611b6a565b90506000610fc58c83611822565b90506000808211610fd7576000610ffa565b610ffa610fea60a08c0160808d016124ce565b6001600160801b03168886611bcd565b90506110068c82611754565b98509650909350505050945094509450949050565b600080600761102d62015180856127bf565b6110389060046127a7565b6110429190612924565b90506000600761105383600c6128dd565b61105d9190612924565b61106a90620151806128be565b61107490856127a7565b905060006110856201518083612924565b61108f90836128dd565b61109b906170806127a7565b90508085106110b4576110b162093a80826127a7565b90505b949350505050565b6000806110cc60208a018a612334565b905060006001600160a01b0382166311547054896110f060408e0160208f01612334565b8a8a8a8a6040518763ffffffff1660e01b81526004016111159695949392919061267d565b60206040518083038186803b15801561112d57600080fd5b505afa158015611141573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111659190612350565b90506001600160a01b0381161561117f5791506112459050565b6000826001600160a01b031663c09746308a8d60200160208101906111a49190612334565b8b8b8b8b6040518763ffffffff1660e01b81526004016111c99695949392919061267d565b602060405180830381600087803b1580156111e357600080fd5b505af11580156111f7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061121b9190612350565b9050611240818b8a8e60200160208101906112369190612334565b8f60600135611c2f565b925050505b979650505050505050565b60008084905060008490506000816001600160a01b031663fc3d42e8846001600160a01b031663c52987cf6040518163ffffffff1660e01b815260040160206040518083038186803b1580156112a557600080fd5b505afa1580156112b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112dd9190612517565b856001600160a01b031663ade6e2aa6040518163ffffffff1660e01b815260040160206040518083038186803b15801561131657600080fd5b505afa15801561132a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061134e9190612517565b866001600160a01b031663f3c274a66040518163ffffffff1660e01b815260040160206040518083038186803b15801561138757600080fd5b505afa15801561139b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113bf91906124ae565b6040516001600160e01b031960e086901b168152600481019390935260248301919091521515604482015260640160206040518083038186803b15801561140557600080fd5b505afa158015611419573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061143d9190612517565b905061145861144e600a60646128be565b61055d838861150c565b90506bffffffffffffffffffffffff8111156114c65760405162461bcd60e51b815260206004820152602760248201527f6f7074696f6e5072656d69756d203e20747970652875696e74393629206d61786044820152662076616c75652160c81b60648201526084016103d6565b925050505b9392505050565b6000670de0b6b3a76400006115026114ea8585612064565b6114fd6002670de0b6b3a76400006127bf565b6120cb565b6114cb91906127bf565b60006114cb82846128be565b92915050565b60006114cb82846127bf565b6000806115378686611822565b90508281101561174557600061154d8583611754565b60405162b0e38960e81b81526004810182905290915089906000906001600160a01b0383169063b0e389009060240160206040518083038186803b15801561159457600080fd5b505afa1580156115a8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115cc9190612517565b604051636f074d1f60e11b8152600481018290529091506001600160a01b0383169063de0e9a3e90602401602060405180830381600087803b15801561161157600080fd5b505af1158015611625573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116499190612517565b506040516370a0823160e01b81523060048201526000906001600160a01b038c16906370a082319060240160206040518083038186803b15801561168c57600080fd5b505afa1580156116a0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116c49190612517565b9050866116d18b83611822565b10156117395760405162461bcd60e51b815260206004820152603160248201527f556e7772617070696e672077737445544820646964206e6f742072657475726e604482015270040e6eaccccd2c6d2cadce840e6e88aa89607b1b60648201526084016103d6565b945061174a9350505050565b849150505b9695505050505050565b60006114cb82846128dd565b60008183111561177057816114cb565b5090919050565b600061178d6001600160a01b038516848461182e565b604051630f7c084960e21b8152600160048201819052600060248301819052604483018590526064830191909152906001600160a01b03851690633df0212490608401602060405180830381600087803b1580156117ea57600080fd5b505af11580156117fe573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106f09190612517565b60006114cb82846127a7565b8015806118b75750604051636eb1769f60e11b81523060048201526001600160a01b03838116602483015284169063dd62ed3e9060440160206040518083038186803b15801561187d57600080fd5b505afa158015611891573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118b59190612517565b155b6119225760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b60648201526084016103d6565b6040516001600160a01b038316602482015260448101829052610cc190849063095ea7b360e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152612120565b6040516370a0823160e01b8152306004820152600090849082906001600160a01b038316906370a082319060240160206040518083038186803b1580156119cb57600080fd5b505afa1580156119df573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a039190612517565b90506000611a118286611760565b90508015611a2d57611a2d6001600160a01b03841687836121f2565b5095945050505050565b60006001600160a01b03861663bb2952fc611a528585611754565b6040518263ffffffff1660e01b8152600401611a7091815260200190565b60206040518083038186803b158015611a8857600080fd5b505afa158015611a9c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ac09190612517565b9050846001600160a01b031663d0e30db0826040518263ffffffff1660e01b81526004016000604051808303818588803b158015611afd57600080fd5b505af1158015611b11573d6000803e3d6000fd5b50611b2c935050506001600160a01b038716905085836121f2565b505050505050565b600080611b4283600a612816565b905060008611611b52578061174a565b61174a8661055d611b638888611754565b849061150c565b600060018311611bb45760405162461bcd60e51b8152602060048201526015602482015274496e76616c6964206173736574506572536861726560581b60448201526064016103d6565b6110b48361055d611bc685600a612816565b879061150c565b600060018311611c175760405162461bcd60e51b8152602060048201526015602482015274496e76616c6964206173736574506572536861726560581b60448201526064016103d6565b6110b4611c2583600a612816565b61055d868661150c565b6001600160a01b038516611c765760405162461bcd60e51b815260206004820152600e60248201526d216f746f6b656e4164647265737360901b60448201526064016103d6565b8354604080516379e13a5360e11b81529051879260ff161515916001600160a01b0384169163f3c274a691600480820192602092909190829003018186803b158015611cc157600080fd5b505afa158015611cd5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cf991906124ae565b151514611d385760405162461bcd60e51b815260206004820152600d60248201526c0a8f2e0ca40dad2e6dac2e8c6d609b1b60448201526064016103d6565b600185015460408051631c56369f60e21b815290516001600160a01b0392831692841691637158da7c916004808301926020929190829003018186803b158015611d8157600080fd5b505afa158015611d95573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611db99190612350565b6001600160a01b031614611e075760405162461bcd60e51b815260206004820152601560248201527415dc9bdb99c81d5b99195c9b1e5a5b99d05cdcd95d605a1b60448201526064016103d6565b836001600160a01b0316816001600160a01b031663aabaecd66040518163ffffffff1660e01b815260040160206040518083038186803b158015611e4a57600080fd5b505afa158015611e5e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e829190612350565b6001600160a01b031614611ed05760405162461bcd60e51b815260206004820152601560248201527415dc9bdb99c818dbdb1b185d195c985b105cdcd95d605a1b60448201526064016103d6565b826001600160a01b0316816001600160a01b03166317d69bc86040518163ffffffff1660e01b815260040160206040518083038186803b158015611f1357600080fd5b505afa158015611f27573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f4b9190612350565b6001600160a01b031614611f975760405162461bcd60e51b8152602060048201526013602482015272737472696b65417373657420213d205553444360681b60448201526064016103d6565b6000611fa34284611822565b905080826001600160a01b031663ade6e2aa6040518163ffffffff1660e01b815260040160206040518083038186803b158015611fdf57600080fd5b505afa158015611ff3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120179190612517565b101561205b5760405162461bcd60e51b8152602060048201526013602482015272457870697279206265666f72652064656c617960681b60448201526064016103d6565b50505050505050565b60008115806120885750828261207a81836128be565b925061208690836127bf565b145b6115185760405162461bcd60e51b815260206004820152601460248201527364732d6d6174682d6d756c2d6f766572666c6f7760601b60448201526064016103d6565b6000826120d883826127a7565b91508110156115185760405162461bcd60e51b815260206004820152601460248201527364732d6d6174682d6164642d6f766572666c6f7760601b60448201526064016103d6565b6000612175826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166122229092919063ffffffff16565b805190915015610cc1578080602001905181019061219391906124ae565b610cc15760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016103d6565b6040516001600160a01b038316602482015260448101829052610cc190849063a9059cbb60e01b9060640161194e565b60606110b4848460008585843b61227b5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016103d6565b600080866001600160a01b031685876040516122979190612661565b60006040518083038185875af1925050503d80600081146122d4576040519150601f19603f3d011682016040523d82523d6000602084013e6122d9565b606091505b5091509150611245828286606083156122f35750816114cb565b8251156123035782518084602001fd5b8160405162461bcd60e51b81526004016103d69190612794565b600060c0828403121561232e578081fd5b50919050565b600060208284031215612345578081fd5b81356114cb81612964565b600060208284031215612361578081fd5b81516114cb81612964565b600080600060608486031215612380578182fd5b833561238b81612964565b9250602084013561239b81612964565b915060408401356123ab81612964565b809150509250925092565b600080600080608085870312156123cb578081fd5b84356123d681612964565b935060208501356123e681612964565b925060408501356123f681612964565b9396929550929360600135925050565b6000806000806000806000610180888a031215612421578283fd5b873561242c81612964565b9650602088013561243c81612964565b9550604088013594506124528960608a0161231d565b93506101208801359250610140880135915061016088013561247381612964565b8091505092959891949750929550565b60008060408385031215612495578182fd5b82356124a081612964565b946020939093013593505050565b6000602082840312156124bf578081fd5b815180151581146114cb578182fd5b6000602082840312156124df578081fd5b81356001600160801b03811681146114cb578182fd5b600060208284031215612506578081fd5b813561ffff811681146114cb578182fd5b600060208284031215612528578081fd5b5051919050565b600080600080600060a08688031215612546578081fd5b85359450602086013561255881612964565b9350604086013561256881612964565b9250606086013561257881612964565b949793965091946080013592915050565b6000806040838503121561259b578182fd5b505080516020909101519092909150565b6000806000808486036101a08112156125c3578283fd5b85359450602086013593506125db876040880161231d565b925060a060ff19820112156125ee578182fd5b50929591945092610100019150565b60006020828403121561260e578081fd5b81356114cb8161297c565b60006020828403121561262a578081fd5b81516114cb8161297c565b6000815180845261264d8160208601602086016128f4565b601f01601f19169290920160200192915050565b600082516126738184602087016128f4565b9190910192915050565b6001600160a01b03968716815294861660208601529290941660408401526060830152608082019290925290151560a082015260c00190565b60006020808301818452808551808352604092508286019150828160051b870101848801865b8381101561278657603f1989840301855281516101008151600b811061271057634e487b7160e01b8b52602160045260248bfd5b8552818901516001600160a01b039081168a87015288830151811689870152606080840151909116908601526080808301519086015260a0808301519086015260c0808301519086015260e09182015191850181905261277281860183612635565b9689019694505050908601906001016126dc565b509098975050505050505050565b6020815260006114cb6020830184612635565b600082198211156127ba576127ba612938565b500190565b6000826127ce576127ce61294e565b500490565b600181815b8085111561280e5781600019048211156127f4576127f4612938565b8085161561280157918102915b93841c93908002906127d8565b509250929050565b60006114cb838360008261282c57506001611518565b8161283957506000611518565b816001811461284f576002811461285957612875565b6001915050611518565b60ff84111561286a5761286a612938565b50506001821b611518565b5060208310610133831016604e8410600b8410161715612898575081810a611518565b6128a283836127d3565b80600019048211156128b6576128b6612938565b029392505050565b60008160001904831182151516156128d8576128d8612938565b500290565b6000828210156128ef576128ef612938565b500390565b60005b8381101561290f5781810151838201526020016128f7565b8381111561291e576000848401525b50505050565b6000826129335761293361294e565b500690565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052601260045260246000fd5b6001600160a01b038116811461297957600080fd5b50565b60ff8116811461297957600080fdfea2646970667358221220a1a6907b252be7837e43055a93480d3428d6e6725bfebb5f07ef947269c0d8b964736f6c63430008040033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "commitAndClose(address,address,uint256,VaultLifecycle.CloseParams,Vault.VaultParams storage,Vault.VaultState storage,address)": {
        "params": {
          "closeParams": "is the struct with details on previous option and strike selection details",
          "collateralAsset": "is the address of the collateral asset",
          "optionsPremiumPricer": "is the address of the contract with the black-scholes premium calculation logic",
          "premiumDiscount": "is the vault's discount applied to the premium",
          "strikeSelection": "is the address of the contract with strike selection logic",
          "vaultParams": "is the struct with vault general data",
          "vaultState": "is the struct with vault accounting state"
        },
        "returns": {
          "delta": "is the delta of the new option",
          "otokenAddress": "is the address of the new option",
          "premium": "is the premium of the new option",
          "strikePrice": "is the strike price of the new option"
        }
      },
      "createShort(address,address,address,uint256)": {
        "params": {
          "depositAmount": "is the amount of collateral to deposit",
          "gammaController": "is the address of the opyn controller contract",
          "marginPool": "is the address of the opyn margin contract which holds the collateral",
          "oTokenAddress": "is the address of the otoken to mint"
        },
        "returns": {
          "_0": "the otoken mint amount"
        }
      },
      "rollover(uint256,uint256,Vault.VaultParams,Vault.VaultState)": {
        "params": {
          "currentBalance": "is the total balance of the vault",
          "currentShareSupply": "is the total supply of shares",
          "vaultParams": "is the struct with vault general data",
          "vaultState": "is the struct with vault accounting state"
        },
        "returns": {
          "mintShares": "is the amount of shares to mint from deposits",
          "newLockedAmount": "is the amount of funds to allocate for the new round",
          "newPricePerShare": "is the price per share of the new round",
          "queuedWithdrawAmount": "is the amount of funds set aside for withdrawal"
        }
      },
      "transferAsset(address,uint256)": {
        "params": {
          "amount": "is the transfer amount",
          "recipient": "is the receiving address"
        }
      },
      "unwrapYieldToken(uint256,address,address,address,uint256)": {
        "params": {
          "amount": "is the amount of ETH to withdraw",
          "crvPool": "is the address of the steth <-> eth pool on curve",
          "minETHOut": "is the minimum eth amount to receive from the swap",
          "stethToken": "is the address of stETH",
          "wstEth": "is the address of wstETH"
        },
        "returns": {
          "_0": "amountETHOut is the amount of eth unwrapped available for the withdrawal (may incur curve slippage)"
        }
      },
      "withdrawYieldAndBaseToken(address,address,address,uint256)": {
        "params": {
          "amount": "is the withdraw amount in `asset`",
          "collateralToken": "is the address of the collateral token",
          "recipient": "is the recipient",
          "weth": "is the WETH address"
        },
        "returns": {
          "_0": "withdrawAmount is the withdraw amount in `collateralToken`"
        }
      },
      "wrapToYieldToken(address,address,address)": {
        "params": {
          "collateralToken": "is the address of the collateral token",
          "weth": "is the address of weth"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "commitAndClose(address,address,uint256,VaultLifecycle.CloseParams,Vault.VaultParams storage,Vault.VaultState storage,address)": {
        "notice": "Sets the next option the vault will be shorting, and calculates its premium for the auction"
      },
      "createShort(address,address,address,uint256)": {
        "notice": "Creates the actual Opyn short position by depositing collateral and minting otokens"
      },
      "rollover(uint256,uint256,Vault.VaultParams,Vault.VaultState)": {
        "notice": "Calculate the shares to mint, new price per share, and amount of funds to re-allocate as collateral for the new round"
      },
      "transferAsset(address,uint256)": {
        "notice": "Helper function to make either an ETH transfer or ERC20 transfer"
      },
      "unwrapYieldToken(uint256,address,address,address,uint256)": {
        "notice": "Unwraps the necessary amount of the wstETH token         and transfers ETH amount to vault"
      },
      "withdrawYieldAndBaseToken(address,address,address,uint256)": {
        "notice": "Withdraws stETH + WETH (if necessary) from vault using vault shares"
      },
      "wrapToYieldToken(address,address,address)": {
        "notice": "Wraps the necessary amount of the base token to the yield-bearing yearn token"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}