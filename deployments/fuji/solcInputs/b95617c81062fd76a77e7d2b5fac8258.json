{
  "language": "Solidity",
  "sources": {
    "contracts/interfaces/GammaInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nlibrary GammaTypes {\n    // vault is a struct of 6 arrays that describe a position a user has, a user can have multiple vaults.\n    struct Vault {\n        // addresses of oTokens a user has shorted (i.e. written) against this vault\n        address[] shortOtokens;\n        // addresses of oTokens a user has bought and deposited in this vault\n        // user can be long oTokens without opening a vault (e.g. by buying on a DEX)\n        // generally, long oTokens will be 'deposited' in vaults to act as collateral\n        // in order to write oTokens against (i.e. in spreads)\n        address[] longOtokens;\n        // addresses of other ERC-20s a user has deposited as collateral in this vault\n        address[] collateralAssets;\n        // quantity of oTokens minted/written for each oToken address in shortOtokens\n        uint256[] shortAmounts;\n        // quantity of oTokens owned and held in the vault for each oToken address in longOtokens\n        uint256[] longAmounts;\n        // quantity of ERC-20 deposited as collateral in the vault for each ERC-20 address in collateralAssets\n        uint256[] collateralAmounts;\n    }\n}\n\ninterface IOtoken {\n    function underlyingAsset() external view returns (address);\n\n    function strikeAsset() external view returns (address);\n\n    function collateralAsset() external view returns (address);\n\n    function strikePrice() external view returns (uint256);\n\n    function expiryTimestamp() external view returns (uint256);\n\n    function isPut() external view returns (bool);\n}\n\ninterface IOtokenFactory {\n    function getOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address);\n\n    function createOtoken(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external returns (address);\n\n    function getTargetOtokenAddress(\n        address _underlyingAsset,\n        address _strikeAsset,\n        address _collateralAsset,\n        uint256 _strikePrice,\n        uint256 _expiry,\n        bool _isPut\n    ) external view returns (address);\n\n    event OtokenCreated(\n        address tokenAddress,\n        address creator,\n        address indexed underlying,\n        address indexed strike,\n        address indexed collateral,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    );\n}\n\ninterface IController {\n    // possible actions that can be performed\n    enum ActionType {\n        OpenVault,\n        MintShortOption,\n        BurnShortOption,\n        DepositLongOption,\n        WithdrawLongOption,\n        DepositCollateral,\n        WithdrawCollateral,\n        SettleVault,\n        Redeem,\n        Call,\n        Liquidate\n    }\n\n    struct ActionArgs {\n        // type of action that is being performed on the system\n        ActionType actionType;\n        // address of the account owner\n        address owner;\n        // address which we move assets from or to (depending on the action type)\n        address secondAddress;\n        // asset that is to be transfered\n        address asset;\n        // index of the vault that is to be modified (if any)\n        uint256 vaultId;\n        // amount of asset that is to be transfered\n        uint256 amount;\n        // each vault can hold multiple short / long / collateral assets\n        // but we are restricting the scope to only 1 of each in this version\n        // in future versions this would be the index of the short / long / collateral asset that needs to be modified\n        uint256 index;\n        // any other data that needs to be passed in for arbitrary function calls\n        bytes data;\n    }\n\n    struct RedeemArgs {\n        // address to which we pay out the oToken proceeds\n        address receiver;\n        // oToken that is to be redeemed\n        address otoken;\n        // amount of oTokens that is to be redeemed\n        uint256 amount;\n    }\n\n    function getPayout(address _otoken, uint256 _amount)\n        external\n        view\n        returns (uint256);\n\n    function operate(ActionArgs[] calldata _actions) external;\n\n    function getAccountVaultCounter(address owner)\n        external\n        view\n        returns (uint256);\n\n    function oracle() external view returns (address);\n\n    function getVault(address _owner, uint256 _vaultId)\n        external\n        view\n        returns (GammaTypes.Vault memory);\n\n    function getProceed(address _owner, uint256 _vaultId)\n        external\n        view\n        returns (uint256);\n\n    function isSettlementAllowed(\n        address _underlying,\n        address _strike,\n        address _collateral,\n        uint256 _expiry\n    ) external view returns (bool);\n}\n"
    },
    "contracts/libraries/VaultLifecycleYearn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {DSMath} from \"../vendor/DSMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {VaultLifecycle} from \"./VaultLifecycle.sol\";\nimport {Vault} from \"./Vault.sol\";\nimport {ShareMath} from \"./ShareMath.sol\";\nimport {IYearnVault} from \"../interfaces/IYearn.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {IStrikeSelection} from \"../interfaces/IRibbon.sol\";\nimport {GnosisAuction} from \"./GnosisAuction.sol\";\nimport {\n    IOtokenFactory,\n    IOtoken,\n    IController,\n    GammaTypes\n} from \"../interfaces/GammaInterface.sol\";\nimport {IERC20Detailed} from \"../interfaces/IERC20Detailed.sol\";\nimport {SupportsNonCompliantERC20} from \"./SupportsNonCompliantERC20.sol\";\n\nlibrary VaultLifecycleYearn {\n    using SafeMath for uint256;\n    using SupportsNonCompliantERC20 for IERC20;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and calculates its premium for the auction\n     * @param strikeSelection is the address of the contract with strike selection logic\n     * @param optionsPremiumPricer is the address of the contract with the\n       black-scholes premium calculation logic\n     * @param premiumDiscount is the vault's discount applied to the premium\n     * @param closeParams is the struct with details on previous option and strike selection details\n     * @param vaultParams is the struct with vault general data\n     * @param vaultState is the struct with vault accounting state\n     * @param collateralAsset is the address of the collateral asset\n     * @return otokenAddress is the address of the new option\n     * @return premium is the premium of the new option\n     * @return strikePrice is the strike price of the new option\n     * @return delta is the delta of the new option\n     */\n    function commitAndClose(\n        address strikeSelection,\n        address optionsPremiumPricer,\n        uint256 premiumDiscount,\n        VaultLifecycle.CloseParams calldata closeParams,\n        Vault.VaultParams storage vaultParams,\n        Vault.VaultState storage vaultState,\n        address collateralAsset\n    )\n        external\n        returns (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        )\n    {\n        uint256 expiry =\n            VaultLifecycle.getNextExpiry(closeParams.currentOption);\n\n        bool isPut = vaultParams.isPut;\n\n        IStrikeSelection selection = IStrikeSelection(strikeSelection);\n\n        // calculate strike and delta\n        (strikePrice, delta) = closeParams.lastStrikeOverrideRound ==\n            vaultState.round\n            ? (closeParams.overriddenStrikePrice, selection.delta())\n            : selection.getStrikePrice(expiry, isPut);\n\n        require(strikePrice != 0, \"!strikePrice\");\n\n        // retrieve address if option already exists, or deploy it\n        otokenAddress = VaultLifecycle.getOrDeployOtoken(\n            closeParams,\n            vaultParams,\n            vaultParams.underlying,\n            collateralAsset,\n            strikePrice,\n            expiry,\n            isPut\n        );\n\n        // get the black scholes premium of the option and adjust premium based on\n        // collateral asset <-> asset exchange rate\n        premium = DSMath.wmul(\n            GnosisAuction.getOTokenPremium(\n                otokenAddress,\n                optionsPremiumPricer,\n                premiumDiscount\n            ),\n            IYearnVault(collateralAsset).pricePerShare().mul(\n                decimalShift(collateralAsset)\n            )\n        );\n\n        require(premium > 0, \"!premium\");\n\n        return (otokenAddress, premium, strikePrice, delta);\n    }\n\n    /**\n     * @notice Calculate the shares to mint, new price per share, and\n      amount of funds to re-allocate as collateral for the new round\n     * @param currentShareSupply is the total supply of shares\n     * @param currentBalance is the total balance of the vault\n     * @param vaultParams is the struct with vault general data\n     * @param vaultState is the struct with vault accounting state\n     * @return newLockedAmount is the amount of funds to allocate for the new round\n     * @return queuedWithdrawAmount is the amount of funds set aside for withdrawal\n     * @return newPricePerShare is the price per share of the new round\n     * @return mintShares is the amount of shares to mint from deposits\n     */\n    function rollover(\n        uint256 currentShareSupply,\n        uint256 currentBalance,\n        Vault.VaultParams calldata vaultParams,\n        Vault.VaultState calldata vaultState\n    )\n        external\n        pure\n        returns (\n            uint256 newLockedAmount,\n            uint256 queuedWithdrawAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares\n        )\n    {\n        uint256 pendingAmount = uint256(vaultState.totalPending);\n        uint256 _decimals = vaultParams.decimals;\n\n        newPricePerShare = ShareMath.pricePerShare(\n            currentShareSupply,\n            currentBalance,\n            pendingAmount,\n            _decimals\n        );\n\n        // After closing the short, if the options expire in-the-money\n        // vault pricePerShare would go down because vault's asset balance decreased.\n        // This ensures that the newly-minted shares do not take on the loss.\n        uint256 _mintShares =\n            ShareMath.assetToShares(pendingAmount, newPricePerShare, _decimals);\n\n        uint256 newSupply = currentShareSupply.add(_mintShares);\n\n        uint256 queuedAmount =\n            newSupply > 0\n                ? ShareMath.sharesToAsset(\n                    vaultState.queuedWithdrawShares,\n                    newPricePerShare,\n                    _decimals\n                )\n                : 0;\n\n        return (\n            currentBalance.sub(queuedAmount),\n            queuedAmount,\n            newPricePerShare,\n            _mintShares\n        );\n    }\n\n    /**\n     * @notice Withdraws yvWETH + WETH (if necessary) from vault using vault shares\n     * @param weth is the weth address\n     * @param asset is the vault asset address\n     * @param collateralToken is the address of the collateral token\n     * @param recipient is the recipient\n     * @param amount is the withdraw amount in `asset`\n     * @return withdrawAmount is the withdraw amount in `collateralToken`\n     */\n    function withdrawYieldAndBaseToken(\n        address weth,\n        address asset,\n        address collateralToken,\n        address recipient,\n        uint256 amount\n    ) external returns (uint256) {\n        uint256 pricePerYearnShare =\n            IYearnVault(collateralToken).pricePerShare();\n        uint256 withdrawAmount =\n            DSMath.wdiv(\n                amount,\n                pricePerYearnShare.mul(decimalShift(collateralToken))\n            );\n        uint256 yieldTokenBalance =\n            withdrawYieldToken(collateralToken, recipient, withdrawAmount);\n\n        // If there is not enough yvWETH in the vault, it withdraws as much as possible and\n        // transfers the rest in `asset`\n        if (withdrawAmount > yieldTokenBalance) {\n            withdrawBaseToken(\n                weth,\n                asset,\n                collateralToken,\n                recipient,\n                withdrawAmount,\n                yieldTokenBalance,\n                pricePerYearnShare\n            );\n        }\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @notice Withdraws yvWETH from vault\n     * @param collateralToken is the address of the collateral token\n     * @param recipient is the recipient\n     * @param withdrawAmount is the withdraw amount in terms of yearn tokens\n     * @return yieldTokenBalance is the balance of the yield token\n     */\n    function withdrawYieldToken(\n        address collateralToken,\n        address recipient,\n        uint256 withdrawAmount\n    ) internal returns (uint256) {\n        IERC20 collateral = IERC20(collateralToken);\n\n        uint256 yieldTokenBalance = collateral.balanceOf(address(this));\n        uint256 yieldTokensToWithdraw =\n            DSMath.min(yieldTokenBalance, withdrawAmount);\n        if (yieldTokensToWithdraw > 0) {\n            collateral.safeTransfer(recipient, yieldTokensToWithdraw);\n        }\n\n        return yieldTokenBalance;\n    }\n\n    /**\n     * @notice Withdraws `asset` from vault\n     * @param weth is the weth address\n     * @param asset is the vault asset address\n     * @param collateralToken is the address of the collateral token\n     * @param recipient is the recipient\n     * @param withdrawAmount is the withdraw amount in terms of yearn tokens\n     * @param yieldTokenBalance is the collateral token (yvWETH) balance of the vault\n     * @param pricePerYearnShare is the yvWETH<->WETH price ratio\n     */\n    function withdrawBaseToken(\n        address weth,\n        address asset,\n        address collateralToken,\n        address recipient,\n        uint256 withdrawAmount,\n        uint256 yieldTokenBalance,\n        uint256 pricePerYearnShare\n    ) internal {\n        uint256 underlyingTokensToWithdraw =\n            DSMath.wmul(\n                withdrawAmount.sub(yieldTokenBalance),\n                pricePerYearnShare.mul(decimalShift(collateralToken))\n            );\n        transferAsset(\n            weth,\n            asset,\n            payable(recipient),\n            underlyingTokensToWithdraw\n        );\n    }\n\n    /**\n     * @notice Unwraps the necessary amount of the yield-bearing yearn token\n     *         and transfers amount to vault\n     * @param amount is the amount of `asset` to withdraw\n     * @param asset is the vault asset address\n     * @param collateralToken is the address of the collateral token\n     * @param yearnWithdrawalBuffer is the buffer for withdrawals from yearn vault\n     * @param yearnWithdrawalSlippage is the slippage for withdrawals from yearn vault\n     */\n    function unwrapYieldToken(\n        uint256 amount,\n        address asset,\n        address collateralToken,\n        uint256 yearnWithdrawalBuffer,\n        uint256 yearnWithdrawalSlippage\n    ) external {\n        uint256 assetBalance = IERC20(asset).balanceOf(address(this));\n        IYearnVault collateral = IYearnVault(collateralToken);\n\n        uint256 amountToUnwrap =\n            DSMath.wdiv(\n                DSMath.max(assetBalance, amount).sub(assetBalance),\n                collateral.pricePerShare().mul(decimalShift(collateralToken))\n            );\n\n        if (amountToUnwrap > 0) {\n            amountToUnwrap = amountToUnwrap\n                .add(amountToUnwrap.mul(yearnWithdrawalBuffer).div(10000))\n                .sub(1);\n\n            collateral.withdraw(\n                amountToUnwrap,\n                address(this),\n                yearnWithdrawalSlippage\n            );\n        }\n    }\n\n    /**\n     * @notice Wraps the necessary amount of the base token to the yield-bearing yearn token\n     * @param asset is the vault asset address\n     * @param collateralToken is the address of the collateral token\n     */\n    function wrapToYieldToken(address asset, address collateralToken) external {\n        uint256 amountToWrap = IERC20(asset).balanceOf(address(this));\n\n        if (amountToWrap > 0) {\n            IERC20(asset).safeApprove(collateralToken, amountToWrap);\n\n            // there is a slight imprecision with regards to calculating back from yearn token -> underlying\n            // that stems from miscoordination between ytoken .deposit() amount wrapped and pricePerShare\n            // at that point in time.\n            // ex: if I have 1 eth, deposit 1 eth into yearn vault and calculate value of yearn token balance\n            // denominated in eth (via balance(yearn token) * pricePerShare) we will get 1 eth - 1 wei.\n            IYearnVault(collateralToken).deposit(amountToWrap, address(this));\n        }\n    }\n\n    /**\n     * @notice Helper function to make either an ETH transfer or ERC20 transfer\n     * @param weth is the weth address\n     * @param asset is the vault asset address\n     * @param recipient is the receiving address\n     * @param amount is the transfer amount\n     */\n    function transferAsset(\n        address weth,\n        address asset,\n        address recipient,\n        uint256 amount\n    ) public {\n        if (asset == weth) {\n            IWETH(weth).withdraw(amount);\n            (bool success, ) = payable(recipient).call{value: amount}(\"\");\n            require(success, \"!success\");\n            return;\n        }\n        IERC20(asset).safeTransfer(recipient, amount);\n    }\n\n    /**\n     * @notice Returns the decimal shift between 18 decimals and asset tokens\n     * @param collateralToken is the address of the collateral token\n     */\n    function decimalShift(address collateralToken)\n        public\n        view\n        returns (uint256)\n    {\n        return\n            10**(uint256(18).sub(IERC20Detailed(collateralToken).decimals()));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/vendor/DSMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >0.4.13;\n\nlibrary DSMath {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x <= y ? x : y;\n    }\n\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        return x >= y ? x : y;\n    }\n\n    function imin(int256 x, int256 y) internal pure returns (int256 z) {\n        return x <= y ? x : y;\n    }\n\n    function imax(int256 x, int256 y) internal pure returns (int256 z) {\n        return x >= y ? x : y;\n    }\n\n    uint256 constant WAD = 10**18;\n    uint256 constant RAY = 10**27;\n\n    //rounds to zero if x*y < WAD / 2\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), WAD / 2) / WAD;\n    }\n\n    //rounds to zero if x*y < WAD / 2\n    function rmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, y), RAY / 2) / RAY;\n    }\n\n    //rounds to zero if x*y < WAD / 2\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, WAD), y / 2) / y;\n    }\n\n    //rounds to zero if x*y < RAY / 2\n    function rdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = add(mul(x, RAY), y / 2) / y;\n    }\n\n    // This famous algorithm is called \"exponentiation by squaring\"\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\n    //\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\n    //\n    // These facts are why it works:\n    //\n    //  If n is even, then x^n = (x^2)^(n/2).\n    //  If n is odd,  then x^n = x * x^(n-1),\n    //   and applying the equation for even x gives\n    //    x^n = x * (x^2)^((n-1) / 2).\n    //\n    //  Also, EVM division is flooring and\n    //    floor[(n-1) / 2] = floor[n / 2].\n    //\n    function rpow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rmul(x, x);\n\n            if (n % 2 != 0) {\n                z = rmul(z, x);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/libraries/VaultLifecycle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Vault} from \"./Vault.sol\";\nimport {ShareMath} from \"./ShareMath.sol\";\nimport {IStrikeSelection} from \"../interfaces/IRibbon.sol\";\nimport {GnosisAuction} from \"./GnosisAuction.sol\";\nimport {\n    IOtokenFactory,\n    IOtoken,\n    IController,\n    GammaTypes\n} from \"../interfaces/GammaInterface.sol\";\nimport {IERC20Detailed} from \"../interfaces/IERC20Detailed.sol\";\nimport {IGnosisAuction} from \"../interfaces/IGnosisAuction.sol\";\nimport {SupportsNonCompliantERC20} from \"./SupportsNonCompliantERC20.sol\";\nimport {UniswapRouter} from \"./UniswapRouter.sol\";\n\nlibrary VaultLifecycle {\n    using SafeMath for uint256;\n    using SupportsNonCompliantERC20 for IERC20;\n\n    struct CloseParams {\n        address OTOKEN_FACTORY;\n        address USDC;\n        address currentOption;\n        uint256 delay;\n        uint16 lastStrikeOverrideRound;\n        uint256 overriddenStrikePrice;\n    }\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and calculates its premium for the auction\n     * @param strikeSelection is the address of the contract with strike selection logic\n     * @param optionsPremiumPricer is the address of the contract with the\n       black-scholes premium calculation logic\n     * @param premiumDiscount is the vault's discount applied to the premium\n     * @param closeParams is the struct with details on previous option and strike selection details\n     * @param vaultParams is the struct with vault general data\n     * @param vaultState is the struct with vault accounting state\n     * @return otokenAddress is the address of the new option\n     * @return premium is the premium of the new option\n     * @return strikePrice is the strike price of the new option\n     * @return delta is the delta of the new option\n     */\n    function commitAndClose(\n        address strikeSelection,\n        address optionsPremiumPricer,\n        uint256 premiumDiscount,\n        CloseParams calldata closeParams,\n        Vault.VaultParams storage vaultParams,\n        Vault.VaultState storage vaultState\n    )\n        external\n        returns (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        )\n    {\n        uint256 expiry = getNextExpiry(closeParams.currentOption);\n\n        IStrikeSelection selection = IStrikeSelection(strikeSelection);\n\n        bool isPut = vaultParams.isPut;\n        address underlying = vaultParams.underlying;\n        address asset = vaultParams.asset;\n\n        (strikePrice, delta) = closeParams.lastStrikeOverrideRound ==\n            vaultState.round\n            ? (closeParams.overriddenStrikePrice, selection.delta())\n            : selection.getStrikePrice(expiry, isPut);\n\n        require(strikePrice != 0, \"!strikePrice\");\n\n        // retrieve address if option already exists, or deploy it\n        otokenAddress = getOrDeployOtoken(\n            closeParams,\n            vaultParams,\n            underlying,\n            asset,\n            strikePrice,\n            expiry,\n            isPut\n        );\n\n        // get the black scholes premium of the option\n        premium = GnosisAuction.getOTokenPremium(\n            otokenAddress,\n            optionsPremiumPricer,\n            premiumDiscount\n        );\n\n        require(premium > 0, \"!premium\");\n\n        return (otokenAddress, premium, strikePrice, delta);\n    }\n\n    /**\n     * @notice Verify the otoken has the correct parameters to prevent vulnerability to opyn contract changes\n     * @param otokenAddress is the address of the otoken\n     * @param vaultParams is the struct with vault general data\n     * @param collateralAsset is the address of the collateral asset\n     * @param USDC is the address of usdc\n     * @param delay is the delay between commitAndClose and rollToNextOption\n     */\n    function verifyOtoken(\n        address otokenAddress,\n        Vault.VaultParams storage vaultParams,\n        address collateralAsset,\n        address USDC,\n        uint256 delay\n    ) private view {\n        require(otokenAddress != address(0), \"!otokenAddress\");\n\n        IOtoken otoken = IOtoken(otokenAddress);\n        require(otoken.isPut() == vaultParams.isPut, \"Type mismatch\");\n        require(\n            otoken.underlyingAsset() == vaultParams.underlying,\n            \"Wrong underlyingAsset\"\n        );\n        require(\n            otoken.collateralAsset() == collateralAsset,\n            \"Wrong collateralAsset\"\n        );\n\n        // we just assume all options use USDC as the strike\n        require(otoken.strikeAsset() == USDC, \"strikeAsset != USDC\");\n\n        uint256 readyAt = block.timestamp.add(delay);\n        require(otoken.expiryTimestamp() >= readyAt, \"Expiry before delay\");\n    }\n\n    /**\n     * @param currentShareSupply is the supply of the shares invoked with totalSupply()\n     * @param asset is the address of the vault's asset\n     * @param decimals is the decimals of the asset\n     * @param lastQueuedWithdrawAmount is the amount queued for withdrawals from last round\n     * @param performanceFee is the perf fee percent to charge on premiums\n     * @param managementFee is the management fee percent to charge on the AUM\n     */\n    struct RolloverParams {\n        uint256 decimals;\n        uint256 totalBalance;\n        uint256 currentShareSupply;\n        uint256 lastQueuedWithdrawAmount;\n        uint256 performanceFee;\n        uint256 managementFee;\n    }\n\n    /**\n     * @notice Calculate the shares to mint, new price per share, and\n      amount of funds to re-allocate as collateral for the new round\n     * @param vaultState is the storage variable vaultState passed from RibbonVault\n     * @param params is the rollover parameters passed to compute the next state\n     * @return newLockedAmount is the amount of funds to allocate for the new round\n     * @return queuedWithdrawAmount is the amount of funds set aside for withdrawal\n     * @return newPricePerShare is the price per share of the new round\n     * @return mintShares is the amount of shares to mint from deposits\n     * @return performanceFeeInAsset is the performance fee charged by vault\n     * @return totalVaultFee is the total amount of fee charged by vault\n     */\n    function rollover(\n        Vault.VaultState storage vaultState,\n        RolloverParams calldata params\n    )\n        external\n        view\n        returns (\n            uint256 newLockedAmount,\n            uint256 queuedWithdrawAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares,\n            uint256 performanceFeeInAsset,\n            uint256 totalVaultFee\n        )\n    {\n        uint256 currentBalance = params.totalBalance;\n        uint256 pendingAmount = vaultState.totalPending;\n        uint256 queuedWithdrawShares = vaultState.queuedWithdrawShares;\n\n        uint256 balanceForVaultFees;\n        {\n            uint256 pricePerShareBeforeFee =\n                ShareMath.pricePerShare(\n                    params.currentShareSupply,\n                    currentBalance,\n                    pendingAmount,\n                    params.decimals\n                );\n\n            uint256 queuedWithdrawBeforeFee =\n                params.currentShareSupply > 0\n                    ? ShareMath.sharesToAsset(\n                        queuedWithdrawShares,\n                        pricePerShareBeforeFee,\n                        params.decimals\n                    )\n                    : 0;\n\n            // Deduct the difference between the newly scheduled withdrawals\n            // and the older withdrawals\n            // so we can charge them fees before they leave\n            uint256 withdrawAmountDiff =\n                queuedWithdrawBeforeFee > params.lastQueuedWithdrawAmount\n                    ? queuedWithdrawBeforeFee.sub(\n                        params.lastQueuedWithdrawAmount\n                    )\n                    : 0;\n\n            balanceForVaultFees = currentBalance\n                .sub(queuedWithdrawBeforeFee)\n                .add(withdrawAmountDiff);\n        }\n\n        {\n            (performanceFeeInAsset, , totalVaultFee) = VaultLifecycle\n                .getVaultFees(\n                balanceForVaultFees,\n                vaultState.lastLockedAmount,\n                vaultState.totalPending,\n                params.performanceFee,\n                params.managementFee\n            );\n        }\n\n        // Take into account the fee\n        // so we can calculate the newPricePerShare\n        currentBalance = currentBalance.sub(totalVaultFee);\n\n        {\n            newPricePerShare = ShareMath.pricePerShare(\n                params.currentShareSupply,\n                currentBalance,\n                pendingAmount,\n                params.decimals\n            );\n\n            // After closing the short, if the options expire in-the-money\n            // vault pricePerShare would go down because vault's asset balance decreased.\n            // This ensures that the newly-minted shares do not take on the loss.\n            mintShares = ShareMath.assetToShares(\n                pendingAmount,\n                newPricePerShare,\n                params.decimals\n            );\n\n            uint256 newSupply = params.currentShareSupply.add(mintShares);\n\n            queuedWithdrawAmount = newSupply > 0\n                ? ShareMath.sharesToAsset(\n                    queuedWithdrawShares,\n                    newPricePerShare,\n                    params.decimals\n                )\n                : 0;\n        }\n\n        return (\n            currentBalance.sub(queuedWithdrawAmount), // new locked balance subtracts the queued withdrawals\n            queuedWithdrawAmount,\n            newPricePerShare,\n            mintShares,\n            performanceFeeInAsset,\n            totalVaultFee\n        );\n    }\n\n    /**\n     * @notice Creates the actual Opyn short position by depositing collateral and minting otokens\n     * @param gammaController is the address of the opyn controller contract\n     * @param marginPool is the address of the opyn margin contract which holds the collateral\n     * @param oTokenAddress is the address of the otoken to mint\n     * @param depositAmount is the amount of collateral to deposit\n     * @return the otoken mint amount\n     */\n    function createShort(\n        address gammaController,\n        address marginPool,\n        address oTokenAddress,\n        uint256 depositAmount\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n        uint256 newVaultID =\n            (controller.getAccountVaultCounter(address(this))).add(1);\n\n        // An otoken's collateralAsset is the vault's `asset`\n        // So in the context of performing Opyn short operations we call them collateralAsset\n        IOtoken oToken = IOtoken(oTokenAddress);\n        address collateralAsset = oToken.collateralAsset();\n\n        uint256 collateralDecimals =\n            uint256(IERC20Detailed(collateralAsset).decimals());\n        uint256 mintAmount;\n\n        if (oToken.isPut()) {\n            // For minting puts, there will be instances where the full depositAmount will not be used for minting.\n            // This is because of an issue with precision.\n            //\n            // For ETH put options, we are calculating the mintAmount (10**8 decimals) using\n            // the depositAmount (10**18 decimals), which will result in truncation of decimals when scaling down.\n            // As a result, there will be tiny amounts of dust left behind in the Opyn vault when minting put otokens.\n            //\n            // For simplicity's sake, we do not refund the dust back to the address(this) on minting otokens.\n            // We retain the dust in the vault so the calling contract can withdraw the\n            // actual locked amount + dust at settlement.\n            //\n            // To test this behavior, we can console.log\n            // MarginCalculatorInterface(0x7A48d10f372b3D7c60f6c9770B91398e4ccfd3C7).getExcessCollateral(vault)\n            // to see how much dust (or excess collateral) is left behind.\n            mintAmount = depositAmount\n                .mul(10**Vault.OTOKEN_DECIMALS)\n                .mul(10**18) // we use 10**18 to give extra precision\n                .div(oToken.strikePrice().mul(10**(10 + collateralDecimals)));\n        } else {\n            mintAmount = depositAmount;\n\n            if (collateralDecimals > 8) {\n                uint256 scaleBy = 10**(collateralDecimals.sub(8)); // oTokens have 8 decimals\n                if (mintAmount > scaleBy) {\n                    mintAmount = depositAmount.div(scaleBy); // scale down from 10**18 to 10**8\n                }\n            }\n        }\n\n        // double approve to fix non-compliant ERC20s\n        IERC20 collateralToken = IERC20(collateralAsset);\n        collateralToken.safeApproveNonCompliant(marginPool, depositAmount);\n\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](3);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.OpenVault,\n            address(this), // owner\n            address(this), // receiver\n            address(0), // asset, otoken\n            newVaultID, // vaultId\n            0, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.DepositCollateral,\n            address(this), // owner\n            address(this), // address to transfer from\n            collateralAsset, // deposited asset\n            newVaultID, // vaultId\n            depositAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[2] = IController.ActionArgs(\n            IController.ActionType.MintShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            oTokenAddress, // option address\n            newVaultID, // vaultId\n            mintAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        return mintAmount;\n    }\n\n    /**\n     * @notice Close the existing short otoken position. Currently this implementation is simple.\n     * It closes the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time. Since calling `_closeShort` deletes vaults by\n     calling SettleVault action, this assumption should hold.\n     * @param gammaController is the address of the opyn controller contract\n     * @return amount of collateral redeemed from the vault\n     */\n    function settleShort(address gammaController) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault =\n            controller.getVault(address(this), vaultID);\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        // An otoken's collateralAsset is the vault's `asset`\n        // So in the context of performing Opyn short operations we call them collateralAsset\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        // The short position has been previously closed, or all the otokens have been burned.\n        // So we return early.\n        if (address(collateralToken) == address(0)) {\n            return 0;\n        }\n\n        // This is equivalent to doing IERC20(vault.asset).balanceOf(address(this))\n        uint256 startCollateralBalance =\n            collateralToken.balanceOf(address(this));\n\n        // If it is after expiry, we need to settle the short position using the normal way\n        // Delete the vault and withdraw all remaining collateral from the vault\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](1);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.SettleVault,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(0), // not used\n            vaultID, // vaultId\n            0, // not used\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance.sub(startCollateralBalance);\n    }\n\n    /**\n     * @notice Exercises the ITM option using existing long otoken position. Currently this implementation is simple.\n     * It calls the `Redeem` action to claim the payout.\n     * @param gammaController is the address of the opyn controller contract\n     * @param oldOption is the address of the old option\n     * @param asset is the address of the vault's asset\n     * @return amount of asset received by exercising the option\n     */\n    function settleLong(\n        address gammaController,\n        address oldOption,\n        address asset\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        uint256 oldOptionBalance = IERC20(oldOption).balanceOf(address(this));\n\n        if (controller.getPayout(oldOption, oldOptionBalance) == 0) {\n            return 0;\n        }\n\n        uint256 startAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        // If it is after expiry, we need to redeem the profits\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](1);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.Redeem,\n            address(0), // not used\n            address(this), // address to send profits to\n            oldOption, // address of otoken\n            0, // not used\n            oldOptionBalance, // otoken balance\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        return endAssetBalance.sub(startAssetBalance);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from auction. Currently this implementation is simple.\n     * It burns oTokens from the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time.\n     * @param gammaController is the address of the opyn controller contract\n     * @param currentOption is the address of the current option\n     * @return amount of collateral redeemed by burning otokens\n     */\n    function burnOtokens(address gammaController, address currentOption)\n        external\n        returns (uint256)\n    {\n        uint256 numOTokensToBurn =\n            IERC20(currentOption).balanceOf(address(this));\n\n        require(numOTokensToBurn > 0, \"No oTokens to burn\");\n\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault =\n            controller.getVault(address(this), vaultID);\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        uint256 startCollateralBalance =\n            collateralToken.balanceOf(address(this));\n\n        // Burning `amount` of oTokens from the ribbon vault,\n        // then withdrawing the corresponding collateral amount from the vault\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](2);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.BurnShortOption,\n            address(this), // owner\n            address(this), // address to transfer from\n            address(vault.shortOtokens[0]), // otoken address\n            vaultID, // vaultId\n            numOTokensToBurn, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.WithdrawCollateral,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(collateralToken), // withdrawn asset\n            vaultID, // vaultId\n            vault.collateralAmounts[0].mul(numOTokensToBurn).div(\n                vault.shortAmounts[0]\n            ), // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance.sub(startCollateralBalance);\n    }\n\n    /**\n     * @notice Calculates the performance and management fee for this week's round\n     * @param currentBalance is the balance of funds held on the vault after closing short\n     * @param lastLockedAmount is the amount of funds locked from the previous round\n     * @param pendingAmount is the pending deposit amount\n     * @param performanceFeePercent is the performance fee pct.\n     * @param managementFeePercent is the management fee pct.\n     * @return performanceFeeInAsset is the performance fee\n     * @return managementFeeInAsset is the management fee\n     * @return vaultFee is the total fees\n     */\n    function getVaultFees(\n        uint256 currentBalance,\n        uint256 lastLockedAmount,\n        uint256 pendingAmount,\n        uint256 performanceFeePercent,\n        uint256 managementFeePercent\n    )\n        internal\n        pure\n        returns (\n            uint256 performanceFeeInAsset,\n            uint256 managementFeeInAsset,\n            uint256 vaultFee\n        )\n    {\n        // At the first round, currentBalance=0, pendingAmount>0\n        // so we just do not charge anything on the first round\n        uint256 lockedBalanceSansPending =\n            currentBalance > pendingAmount\n                ? currentBalance.sub(pendingAmount)\n                : 0;\n\n        uint256 _performanceFeeInAsset;\n        uint256 _managementFeeInAsset;\n        uint256 _vaultFee;\n\n        // Take performance fee and management fee ONLY if difference between\n        // last week and this week's vault deposits, taking into account pending\n        // deposits and withdrawals, is positive. If it is negative, last week's\n        // option expired ITM past breakeven, and the vault took a loss so we\n        // do not collect performance fee for last week\n        if (lockedBalanceSansPending > lastLockedAmount) {\n            _performanceFeeInAsset = performanceFeePercent > 0\n                ? lockedBalanceSansPending\n                    .sub(lastLockedAmount)\n                    .mul(performanceFeePercent)\n                    .div(100 * Vault.FEE_MULTIPLIER)\n                : 0;\n            _managementFeeInAsset = managementFeePercent > 0\n                ? lockedBalanceSansPending.mul(managementFeePercent).div(\n                    100 * Vault.FEE_MULTIPLIER\n                )\n                : 0;\n\n            _vaultFee = _performanceFeeInAsset.add(_managementFeeInAsset);\n        }\n\n        return (_performanceFeeInAsset, _managementFeeInAsset, _vaultFee);\n    }\n\n    /**\n     * @notice Either retrieves the option token if it already exists, or deploy it\n     * @param closeParams is the struct with details on previous option and strike selection details\n     * @param vaultParams is the struct with vault general data\n     * @param underlying is the address of the underlying asset of the option\n     * @param collateralAsset is the address of the collateral asset of the option\n     * @param strikePrice is the strike price of the option\n     * @param expiry is the expiry timestamp of the option\n     * @param isPut is whether the option is a put\n     * @return the address of the option\n     */\n    function getOrDeployOtoken(\n        CloseParams calldata closeParams,\n        Vault.VaultParams storage vaultParams,\n        address underlying,\n        address collateralAsset,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    ) internal returns (address) {\n        IOtokenFactory factory = IOtokenFactory(closeParams.OTOKEN_FACTORY);\n\n        address otokenFromFactory =\n            factory.getOtoken(\n                underlying,\n                closeParams.USDC,\n                collateralAsset,\n                strikePrice,\n                expiry,\n                isPut\n            );\n\n        if (otokenFromFactory != address(0)) {\n            return otokenFromFactory;\n        }\n\n        address otoken =\n            factory.createOtoken(\n                underlying,\n                closeParams.USDC,\n                collateralAsset,\n                strikePrice,\n                expiry,\n                isPut\n            );\n\n        verifyOtoken(\n            otoken,\n            vaultParams,\n            collateralAsset,\n            closeParams.USDC,\n            closeParams.delay\n        );\n\n        return otoken;\n    }\n\n    /**\n     * @notice Starts the gnosis auction\n     * @param auctionDetails is the struct with all the custom parameters of the auction\n     * @return the auction id of the newly created auction\n     */\n    function startAuction(GnosisAuction.AuctionDetails calldata auctionDetails)\n        external\n        returns (uint256)\n    {\n        return GnosisAuction.startAuction(auctionDetails);\n    }\n\n    /**\n     * @notice Settles the gnosis auction\n     * @param gnosisEasyAuction is the contract address of Gnosis easy auction protocol\n     * @param auctionID is the auction ID of the gnosis easy auction\n     */\n    function settleAuction(address gnosisEasyAuction, uint256 auctionID)\n        internal\n    {\n        IGnosisAuction(gnosisEasyAuction).settleAuction(auctionID);\n    }\n\n    /**\n     * @notice Swaps tokens using UniswapV3 router\n     * @param tokenIn is the token address to swap\n     * @param minAmountOut is the minimum acceptable amount of tokenOut received from swap\n     * @param router is the contract address of UniswapV3 router\n     * @param swapPath is the swap path e.g. encodePacked(tokenIn, poolFee, tokenOut)\n     */\n    function swap(\n        address tokenIn,\n        uint256 minAmountOut,\n        address router,\n        bytes calldata swapPath\n    ) external {\n        uint256 balance = IERC20(tokenIn).balanceOf(address(this));\n\n        if (balance > 0) {\n            UniswapRouter.swap(\n                address(this),\n                tokenIn,\n                balance,\n                minAmountOut,\n                router,\n                swapPath\n            );\n        }\n    }\n\n    function checkPath(\n        bytes calldata swapPath,\n        address validTokenIn,\n        address validTokenOut,\n        address uniswapFactory\n    ) external view returns (bool isValidPath) {\n        return\n            UniswapRouter.checkPath(\n                swapPath,\n                validTokenIn,\n                validTokenOut,\n                uniswapFactory\n            );\n    }\n\n    /**\n     * @notice Places a bid in an auction\n     * @param bidDetails is the struct with all the details of the\n      bid including the auction's id and how much to bid\n     */\n    function placeBid(GnosisAuction.BidDetails calldata bidDetails)\n        external\n        returns (\n            uint256 sellAmount,\n            uint256 buyAmount,\n            uint64 userId\n        )\n    {\n        return GnosisAuction.placeBid(bidDetails);\n    }\n\n    /**\n     * @notice Claims the oTokens belonging to the vault\n     * @param auctionSellOrder is the sell order of the bid\n     * @param gnosisEasyAuction is the address of the gnosis auction contract\n     holding custody to the funds\n     * @param counterpartyThetaVault is the address of the counterparty theta\n     vault of this delta vault\n     */\n    function claimAuctionOtokens(\n        Vault.AuctionSellOrder calldata auctionSellOrder,\n        address gnosisEasyAuction,\n        address counterpartyThetaVault\n    ) external {\n        GnosisAuction.claimAuctionOtokens(\n            auctionSellOrder,\n            gnosisEasyAuction,\n            counterpartyThetaVault\n        );\n    }\n\n    /**\n     * @notice Verify the constructor params satisfy requirements\n     * @param owner is the owner of the vault with critical permissions\n     * @param feeRecipient is the address to recieve vault performance and management fees\n     * @param performanceFee is the perfomance fee pct.\n     * @param tokenName is the name of the token\n     * @param tokenSymbol is the symbol of the token\n     * @param _vaultParams is the struct with vault general data\n     */\n    function verifyInitializerParams(\n        address owner,\n        address keeper,\n        address feeRecipient,\n        uint256 performanceFee,\n        uint256 managementFee,\n        string calldata tokenName,\n        string calldata tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) external pure {\n        require(owner != address(0), \"!owner\");\n        require(keeper != address(0), \"!keeper\");\n        require(feeRecipient != address(0), \"!feeRecipient\");\n        require(\n            performanceFee < 100 * Vault.FEE_MULTIPLIER,\n            \"performanceFee >= 100%\"\n        );\n        require(\n            managementFee < 100 * Vault.FEE_MULTIPLIER,\n            \"managementFee >= 100%\"\n        );\n        require(bytes(tokenName).length > 0, \"!tokenName\");\n        require(bytes(tokenSymbol).length > 0, \"!tokenSymbol\");\n\n        require(_vaultParams.asset != address(0), \"!asset\");\n        require(_vaultParams.underlying != address(0), \"!underlying\");\n        require(_vaultParams.minimumSupply > 0, \"!minimumSupply\");\n        require(_vaultParams.cap > 0, \"!cap\");\n        require(\n            _vaultParams.cap > _vaultParams.minimumSupply,\n            \"cap has to be higher than minimumSupply\"\n        );\n    }\n\n    /**\n     * @notice Gets the next option expiry timestamp\n     * @param currentOption is the otoken address that the vault is currently writing\n     */\n    function getNextExpiry(address currentOption)\n        internal\n        view\n        returns (uint256)\n    {\n        // uninitialized state\n        if (currentOption == address(0)) {\n            return getNextFriday(block.timestamp);\n        }\n        uint256 currentExpiry = IOtoken(currentOption).expiryTimestamp();\n\n        // After options expiry if no options are written for >1 week\n        // We need to give the ability continue writing options\n        if (block.timestamp > currentExpiry + 7 days) {\n            return getNextFriday(block.timestamp);\n        }\n        return getNextFriday(currentExpiry);\n    }\n\n    /**\n     * @notice Gets the next options expiry timestamp\n     * @param timestamp is the expiry timestamp of the current option\n     * Reference: https://codereview.stackexchange.com/a/33532\n     * Examples:\n     * getNextFriday(week 1 thursday) -> week 1 friday\n     * getNextFriday(week 1 friday) -> week 2 friday\n     * getNextFriday(week 1 saturday) -> week 2 friday\n     */\n    function getNextFriday(uint256 timestamp) internal pure returns (uint256) {\n        // dayOfWeek = 0 (sunday) - 6 (saturday)\n        uint256 dayOfWeek = ((timestamp / 1 days) + 4) % 7;\n        uint256 nextFriday = timestamp + ((7 + 5 - dayOfWeek) % 7) * 1 days;\n        uint256 friday8am = nextFriday - (nextFriday % (24 hours)) + (8 hours);\n\n        // If the passed timestamp is day=Friday hour>8am, we simply increment it by a week to next Friday\n        if (timestamp >= friday8am) {\n            friday8am += 7 days;\n        }\n        return friday8am;\n    }\n}\n"
    },
    "contracts/libraries/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nlibrary Vault {\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    // Fees are 6-decimal places. For example: 20 * 10**6 = 20%\n    uint256 internal constant FEE_MULTIPLIER = 10**6;\n\n    // Premium discount has 1-decimal place. For example: 80 * 10**1 = 80%. Which represents a 20% discount.\n    uint256 internal constant PREMIUM_DISCOUNT_MULTIPLIER = 10;\n\n    // Otokens have 8 decimal places.\n    uint256 internal constant OTOKEN_DECIMALS = 8;\n\n    // Percentage of funds allocated to options is 2 decimal places. 10 * 10**2 = 10%\n    uint256 internal constant OPTION_ALLOCATION_MULTIPLIER = 10**2;\n\n    // Placeholder uint value to prevent cold writes\n    uint256 internal constant PLACEHOLDER_UINT = 1;\n\n    struct VaultParams {\n        // Option type the vault is selling\n        bool isPut;\n        // Token decimals for vault shares\n        uint8 decimals;\n        // Asset used in Theta / Delta Vault\n        address asset;\n        // Underlying asset of the options sold by vault\n        address underlying;\n        // Minimum supply of the vault shares issued, for ETH it's 10**10\n        uint56 minimumSupply;\n        // Vault cap\n        uint104 cap;\n    }\n\n    struct OptionState {\n        // Option that the vault is shorting / longing in the next cycle\n        address nextOption;\n        // Option that the vault is currently shorting / longing\n        address currentOption;\n        // The timestamp when the `nextOption` can be used by the vault\n        uint32 nextOptionReadyAt;\n    }\n\n    struct VaultState {\n        // 32 byte slot 1\n        //  Current round number. `round` represents the number of `period`s elapsed.\n        uint16 round;\n        // Amount that is currently locked for selling options\n        uint104 lockedAmount;\n        // Amount that was locked for selling options in the previous round\n        // used for calculating performance fee deduction\n        uint104 lastLockedAmount;\n        // 32 byte slot 2\n        // Stores the total tally of how much of `asset` there is\n        // to be used to mint rTHETA tokens\n        uint128 totalPending;\n        // Amount locked for scheduled withdrawals;\n        uint128 queuedWithdrawShares;\n    }\n\n    struct DepositReceipt {\n        // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\n        uint16 round;\n        // Deposit amount, max 20,282,409,603,651 or 20 trillion ETH deposit\n        uint104 amount;\n        // Unredeemed shares balance\n        uint128 unredeemedShares;\n    }\n\n    struct Withdrawal {\n        // Maximum of 65535 rounds. Assuming 1 round is 7 days, maximum is 1256 years.\n        uint16 round;\n        // Number of shares withdrawn\n        uint128 shares;\n    }\n\n    struct AuctionSellOrder {\n        // Amount of `asset` token offered in auction\n        uint96 sellAmount;\n        // Amount of oToken requested in auction\n        uint96 buyAmount;\n        // User Id of delta vault in latest gnosis auction\n        uint64 userId;\n    }\n}\n"
    },
    "contracts/libraries/ShareMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {Vault} from \"./Vault.sol\";\n\nlibrary ShareMath {\n    using SafeMath for uint256;\n\n    uint256 internal constant PLACEHOLDER_UINT = 1;\n\n    function assetToShares(\n        uint256 assetAmount,\n        uint256 assetPerShare,\n        uint256 decimals\n    ) internal pure returns (uint256) {\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\n        // which should never happen.\n        // Has to be larger than 1 because `1` is used in `initRoundPricePerShares` to prevent cold writes.\n        require(assetPerShare > PLACEHOLDER_UINT, \"Invalid assetPerShare\");\n\n        return assetAmount.mul(10**decimals).div(assetPerShare);\n    }\n\n    function sharesToAsset(\n        uint256 shares,\n        uint256 assetPerShare,\n        uint256 decimals\n    ) internal pure returns (uint256) {\n        // If this throws, it means that vault's roundPricePerShare[currentRound] has not been set yet\n        // which should never happen.\n        // Has to be larger than 1 because `1` is used in `initRoundPricePerShares` to prevent cold writes.\n        require(assetPerShare > PLACEHOLDER_UINT, \"Invalid assetPerShare\");\n\n        return shares.mul(assetPerShare).div(10**decimals);\n    }\n\n    /**\n     * @notice Returns the shares unredeemed by the user given their DepositReceipt\n     * @param depositReceipt is the user's deposit receipt\n     * @param currentRound is the `round` stored on the vault\n     * @param assetPerShare is the price in asset per share\n     * @param decimals is the number of decimals the asset/shares use\n     * @return unredeemedShares is the user's virtual balance of shares that are owed\n     */\n    function getSharesFromReceipt(\n        Vault.DepositReceipt memory depositReceipt,\n        uint256 currentRound,\n        uint256 assetPerShare,\n        uint256 decimals\n    ) internal pure returns (uint256 unredeemedShares) {\n        if (depositReceipt.round > 0 && depositReceipt.round < currentRound) {\n            uint256 sharesFromRound =\n                assetToShares(depositReceipt.amount, assetPerShare, decimals);\n\n            return\n                uint256(depositReceipt.unredeemedShares).add(sharesFromRound);\n        }\n        return depositReceipt.unredeemedShares;\n    }\n\n    function pricePerShare(\n        uint256 totalSupply,\n        uint256 totalBalance,\n        uint256 pendingAmount,\n        uint256 decimals\n    ) internal pure returns (uint256) {\n        uint256 singleShare = 10**decimals;\n        return\n            totalSupply > 0\n                ? singleShare.mul(totalBalance.sub(pendingAmount)).div(\n                    totalSupply\n                )\n                : singleShare;\n    }\n\n    /************************************************\n     *  HELPERS\n     ***********************************************/\n\n    function assertUint104(uint256 num) internal pure {\n        require(num <= type(uint104).max, \"Overflow uint104\");\n    }\n\n    function assertUint128(uint256 num) internal pure {\n        require(num <= type(uint128).max, \"Overflow uint128\");\n    }\n}\n"
    },
    "contracts/interfaces/IYearn.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\ninterface IYearnVault {\n    function pricePerShare() external view returns (uint256);\n\n    function deposit(uint256 _amount, address _recipient)\n        external\n        returns (uint256);\n\n    function withdraw(\n        uint256 _maxShares,\n        address _recipient,\n        uint256 _maxLoss\n    ) external returns (uint256);\n\n    function approve(address _recipient, uint256 _amount)\n        external\n        returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function decimals() external view returns (uint256);\n}\n\ninterface IYearnRegistry {\n    function latestVault(address token) external returns (address);\n}\n\ninterface IYearnPricer {\n    function setExpiryPriceInOracle(uint256 _expiryTimestamp) external;\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function decimals() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/IRibbon.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\ninterface IStrikeSelection {\n    function getStrikePrice(uint256 expiryTimestamp, bool isPut)\n        external\n        view\n        returns (uint256, uint256);\n\n    function delta() external view returns (uint256);\n}\n\ninterface IOptionsPremiumPricer {\n    function getPremium(\n        uint256 strikePrice,\n        uint256 timeToExpiry,\n        bool isPut\n    ) external view returns (uint256);\n\n    function getPremiumInStables(\n        uint256 strikePrice,\n        uint256 timeToExpiry,\n        bool isPut\n    ) external view returns (uint256);\n\n    function getOptionDelta(\n        uint256 spotPrice,\n        uint256 strikePrice,\n        uint256 volatility,\n        uint256 expiryTimestamp\n    ) external view returns (uint256 delta);\n\n    function getUnderlyingPrice() external view returns (uint256);\n\n    function priceOracle() external view returns (address);\n\n    function volatilityOracle() external view returns (address);\n\n    function pool() external view returns (address);\n}\n"
    },
    "contracts/libraries/GnosisAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {DSMath} from \"../vendor/DSMath.sol\";\nimport {IGnosisAuction} from \"../interfaces/IGnosisAuction.sol\";\nimport {IOtoken} from \"../interfaces/GammaInterface.sol\";\nimport {IOptionsPremiumPricer} from \"../interfaces/IRibbon.sol\";\nimport {Vault} from \"./Vault.sol\";\nimport {IRibbonThetaVault} from \"../interfaces/IRibbonThetaVault.sol\";\n\nlibrary GnosisAuction {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    event InitiateGnosisAuction(\n        address indexed auctioningToken,\n        address indexed biddingToken,\n        uint256 auctionCounter,\n        address indexed manager\n    );\n\n    event PlaceAuctionBid(\n        uint256 auctionId,\n        address indexed auctioningToken,\n        uint256 sellAmount,\n        uint256 buyAmount,\n        address indexed bidder\n    );\n\n    struct AuctionDetails {\n        address oTokenAddress;\n        address gnosisEasyAuction;\n        address asset;\n        uint256 assetDecimals;\n        uint256 oTokenPremium;\n        uint256 duration;\n    }\n\n    struct BidDetails {\n        address oTokenAddress;\n        address gnosisEasyAuction;\n        address asset;\n        uint256 assetDecimals;\n        uint256 auctionId;\n        uint256 lockedBalance;\n        uint256 optionAllocation;\n        uint256 optionPremium;\n        address bidder;\n    }\n\n    function startAuction(AuctionDetails calldata auctionDetails)\n        internal\n        returns (uint256 auctionID)\n    {\n        uint256 oTokenSellAmount =\n            getOTokenSellAmount(auctionDetails.oTokenAddress);\n\n        IERC20(auctionDetails.oTokenAddress).safeApprove(\n            auctionDetails.gnosisEasyAuction,\n            IERC20(auctionDetails.oTokenAddress).balanceOf(address(this))\n        );\n\n        // minBidAmount is total oTokens to sell * premium per oToken\n        // shift decimals to correspond to decimals of USDC for puts\n        // and underlying for calls\n        uint256 minBidAmount =\n            DSMath.wmul(\n                oTokenSellAmount.mul(10**10),\n                auctionDetails.oTokenPremium\n            );\n\n        minBidAmount = auctionDetails.assetDecimals > 18\n            ? minBidAmount.mul(10**(auctionDetails.assetDecimals.sub(18)))\n            : minBidAmount.div(\n                10**(uint256(18).sub(auctionDetails.assetDecimals))\n            );\n\n        require(\n            minBidAmount <= type(uint96).max,\n            \"optionPremium * oTokenSellAmount > type(uint96) max value!\"\n        );\n\n        uint256 auctionEnd = block.timestamp.add(auctionDetails.duration);\n\n        auctionID = IGnosisAuction(auctionDetails.gnosisEasyAuction)\n            .initiateAuction(\n            // address of oToken we minted and are selling\n            auctionDetails.oTokenAddress,\n            // address of asset we want in exchange for oTokens. Should match vault `asset`\n            auctionDetails.asset,\n            // orders can be cancelled at any time during the auction\n            auctionEnd,\n            // order will last for `duration`\n            auctionEnd,\n            // we are selling all of the otokens minus a fee taken by gnosis\n            uint96(oTokenSellAmount),\n            // the minimum we are willing to sell all the oTokens for. A discount is applied on black-scholes price\n            uint96(minBidAmount),\n            // the minimum bidding amount must be 1 * 10 ** -assetDecimals\n            1,\n            // the min funding threshold\n            0,\n            // no atomic closure\n            false,\n            // access manager contract\n            address(0),\n            // bytes for storing info like a whitelist for who can bid\n            bytes(\"\")\n        );\n\n        emit InitiateGnosisAuction(\n            auctionDetails.oTokenAddress,\n            auctionDetails.asset,\n            auctionID,\n            msg.sender\n        );\n    }\n\n    function placeBid(BidDetails calldata bidDetails)\n        internal\n        returns (\n            uint256 sellAmount,\n            uint256 buyAmount,\n            uint64 userId\n        )\n    {\n        // calculate how much to allocate\n        sellAmount = bidDetails\n            .lockedBalance\n            .mul(bidDetails.optionAllocation)\n            .div(100 * Vault.OPTION_ALLOCATION_MULTIPLIER);\n\n        // divide the `asset` sellAmount by the target premium per oToken to\n        // get the number of oTokens to buy (8 decimals)\n        buyAmount = sellAmount\n            .mul(10**(bidDetails.assetDecimals.add(Vault.OTOKEN_DECIMALS)))\n            .div(bidDetails.optionPremium)\n            .div(10**bidDetails.assetDecimals);\n\n        require(\n            sellAmount <= type(uint96).max,\n            \"sellAmount > type(uint96) max value!\"\n        );\n        require(\n            buyAmount <= type(uint96).max,\n            \"buyAmount > type(uint96) max value!\"\n        );\n\n        // approve that amount\n        IERC20(bidDetails.asset).safeApprove(\n            bidDetails.gnosisEasyAuction,\n            sellAmount\n        );\n\n        uint96[] memory _minBuyAmounts = new uint96[](1);\n        uint96[] memory _sellAmounts = new uint96[](1);\n        bytes32[] memory _prevSellOrders = new bytes32[](1);\n        _minBuyAmounts[0] = uint96(buyAmount);\n        _sellAmounts[0] = uint96(sellAmount);\n        _prevSellOrders[\n            0\n        ] = 0x0000000000000000000000000000000000000000000000000000000000000001;\n\n        // place sell order with that amount\n        userId = IGnosisAuction(bidDetails.gnosisEasyAuction).placeSellOrders(\n            bidDetails.auctionId,\n            _minBuyAmounts,\n            _sellAmounts,\n            _prevSellOrders,\n            \"0x\"\n        );\n\n        emit PlaceAuctionBid(\n            bidDetails.auctionId,\n            bidDetails.oTokenAddress,\n            sellAmount,\n            buyAmount,\n            bidDetails.bidder\n        );\n\n        return (sellAmount, buyAmount, userId);\n    }\n\n    function claimAuctionOtokens(\n        Vault.AuctionSellOrder calldata auctionSellOrder,\n        address gnosisEasyAuction,\n        address counterpartyThetaVault\n    ) internal {\n        bytes32 order =\n            encodeOrder(\n                auctionSellOrder.userId,\n                auctionSellOrder.buyAmount,\n                auctionSellOrder.sellAmount\n            );\n        bytes32[] memory orders = new bytes32[](1);\n        orders[0] = order;\n        IGnosisAuction(gnosisEasyAuction).claimFromParticipantOrder(\n            IRibbonThetaVault(counterpartyThetaVault).optionAuctionID(),\n            orders\n        );\n    }\n\n    function getOTokenSellAmount(address oTokenAddress)\n        internal\n        view\n        returns (uint256)\n    {\n        // We take our current oToken balance. That will be our sell amount\n        // but otokens will be transferred to gnosis.\n        uint256 oTokenSellAmount =\n            IERC20(oTokenAddress).balanceOf(address(this));\n\n        require(\n            oTokenSellAmount <= type(uint96).max,\n            \"oTokenSellAmount > type(uint96) max value!\"\n        );\n\n        return oTokenSellAmount;\n    }\n\n    function getOTokenPremium(\n        address oTokenAddress,\n        address optionsPremiumPricer,\n        uint256 premiumDiscount\n    ) internal view returns (uint256) {\n        IOtoken newOToken = IOtoken(oTokenAddress);\n        IOptionsPremiumPricer premiumPricer =\n            IOptionsPremiumPricer(optionsPremiumPricer);\n\n        // Apply black-scholes formula (from rvol library) to option given its features\n        // and get price for 100 contracts denominated in the underlying asset for call option\n        // and USDC for put option\n        uint256 optionPremium =\n            premiumPricer.getPremium(\n                newOToken.strikePrice(),\n                newOToken.expiryTimestamp(),\n                newOToken.isPut()\n            );\n\n        // Apply a discount to incentivize arbitraguers\n        optionPremium = optionPremium.mul(premiumDiscount).div(\n            100 * Vault.PREMIUM_DISCOUNT_MULTIPLIER\n        );\n\n        require(\n            optionPremium <= type(uint96).max,\n            \"optionPremium > type(uint96) max value!\"\n        );\n\n        return optionPremium;\n    }\n\n    function getOTokenPremiumInStables(\n        address oTokenAddress,\n        address optionsPremiumPricer,\n        uint256 premiumDiscount\n    ) internal view returns (uint256) {\n        IOtoken newOToken = IOtoken(oTokenAddress);\n        IOptionsPremiumPricer premiumPricer =\n            IOptionsPremiumPricer(optionsPremiumPricer);\n\n        // Apply black-scholes formula (from rvol library) to option given its features\n        // and get price for 100 contracts denominated USDC for both call and put options\n        uint256 optionPremium =\n            premiumPricer.getPremiumInStables(\n                newOToken.strikePrice(),\n                newOToken.expiryTimestamp(),\n                newOToken.isPut()\n            );\n\n        // Apply a discount to incentivize arbitraguers\n        optionPremium = optionPremium.mul(premiumDiscount).div(\n            100 * Vault.PREMIUM_DISCOUNT_MULTIPLIER\n        );\n\n        require(\n            optionPremium <= type(uint96).max,\n            \"optionPremium > type(uint96) max value!\"\n        );\n\n        return optionPremium;\n    }\n\n    function encodeOrder(\n        uint64 userId,\n        uint96 buyAmount,\n        uint96 sellAmount\n    ) internal pure returns (bytes32) {\n        return\n            bytes32(\n                (uint256(userId) << 192) +\n                    (uint256(buyAmount) << 96) +\n                    uint256(sellAmount)\n            );\n    }\n}\n"
    },
    "contracts/interfaces/IERC20Detailed.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IERC20Detailed is IERC20 {\n    function decimals() external view returns (uint8);\n\n    function symbol() external view returns (string calldata);\n\n    function name() external view returns (string calldata);\n}\n"
    },
    "contracts/libraries/SupportsNonCompliantERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * This library supports ERC20s that have quirks in their behavior.\n * One such ERC20 is USDT, which requires allowance to be 0 before calling approve.\n * We plan to update this library with ERC20s that display such idiosyncratic behavior.\n */\nlibrary SupportsNonCompliantERC20 {\n    address private constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n    function safeApproveNonCompliant(\n        IERC20 token,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (address(token) == USDT) {\n            SafeERC20.safeApprove(token, spender, 0);\n        }\n        SafeERC20.safeApprove(token, spender, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IGnosisAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary AuctionType {\n    struct AuctionData {\n        IERC20 auctioningToken;\n        IERC20 biddingToken;\n        uint256 orderCancellationEndDate;\n        uint256 auctionEndDate;\n        bytes32 initialAuctionOrder;\n        uint256 minimumBiddingAmountPerOrder;\n        uint256 interimSumBidAmount;\n        bytes32 interimOrder;\n        bytes32 clearingPriceOrder;\n        uint96 volumeClearingPriceOrder;\n        bool minFundingThresholdNotReached;\n        bool isAtomicClosureAllowed;\n        uint256 feeNumerator;\n        uint256 minFundingThreshold;\n    }\n}\n\ninterface IGnosisAuction {\n    function initiateAuction(\n        address _auctioningToken,\n        address _biddingToken,\n        uint256 orderCancellationEndDate,\n        uint256 auctionEndDate,\n        uint96 _auctionedSellAmount,\n        uint96 _minBuyAmount,\n        uint256 minimumBiddingAmountPerOrder,\n        uint256 minFundingThreshold,\n        bool isAtomicClosureAllowed,\n        address accessManagerContract,\n        bytes memory accessManagerContractData\n    ) external returns (uint256);\n\n    function auctionCounter() external view returns (uint256);\n\n    function auctionData(uint256 auctionId)\n        external\n        view\n        returns (AuctionType.AuctionData memory);\n\n    function auctionAccessManager(uint256 auctionId)\n        external\n        view\n        returns (address);\n\n    function auctionAccessData(uint256 auctionId)\n        external\n        view\n        returns (bytes memory);\n\n    function FEE_DENOMINATOR() external view returns (uint256);\n\n    function feeNumerator() external view returns (uint256);\n\n    function settleAuction(uint256 auctionId) external returns (bytes32);\n\n    function placeSellOrders(\n        uint256 auctionId,\n        uint96[] memory _minBuyAmounts,\n        uint96[] memory _sellAmounts,\n        bytes32[] memory _prevSellOrders,\n        bytes calldata allowListCallData\n    ) external returns (uint64);\n\n    function claimFromParticipantOrder(\n        uint256 auctionId,\n        bytes32[] memory orders\n    ) external returns (uint256, uint256);\n}\n"
    },
    "contracts/libraries/UniswapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ISwapRouter} from \"../interfaces/ISwapRouter.sol\";\nimport {IUniswapV3Factory} from \"../interfaces/IUniswapV3Factory.sol\";\nimport \"./Path.sol\";\n\nlibrary UniswapRouter {\n    using Path for bytes;\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Check if the path set for swap is valid\n     * @param swapPath is the swap path e.g. encodePacked(tokenIn, poolFee, tokenOut)\n     * @param validTokenIn is the contract address of the correct tokenIn\n     * @param validTokenOut is the contract address of the correct tokenOut\n     * @param uniswapFactory is the contract address of UniswapV3 factory\n     * @return isValidPath is whether the path is valid\n     */\n    function checkPath(\n        bytes memory swapPath,\n        address validTokenIn,\n        address validTokenOut,\n        address uniswapFactory\n    ) internal view returns (bool isValidPath) {\n        // Function checks if the tokenIn and tokenOut in the swapPath\n        // matches the validTokenIn and validTokenOut specified.\n        address tokenIn;\n        address tokenOut;\n        address tempTokenIn;\n        uint24 fee;\n        IUniswapV3Factory factory = IUniswapV3Factory(uniswapFactory);\n\n        // Return early if swapPath is below the bare minimum (43)\n        require(swapPath.length >= 43, \"Path too short\");\n        // Return early if swapPath is above the max (66)\n        // At worst we have 2 hops e.g. USDC > WETH > asset\n        require(swapPath.length <= 66, \"Path too long\");\n\n        // Decode the first pool in path\n        (tokenIn, tokenOut, fee) = swapPath.decodeFirstPool();\n\n        // Check to factory if pool exists\n        require(\n            factory.getPool(tokenIn, tokenOut, fee) != address(0),\n            \"Pool does not exist\"\n        );\n\n        // Check next pool if multiple pools\n        while (swapPath.hasMultiplePools()) {\n            // Remove the first pool from path\n            swapPath = swapPath.skipToken();\n            // Check the next pool and update tokenOut\n            (tempTokenIn, tokenOut, fee) = swapPath.decodeFirstPool();\n\n            require(\n                factory.getPool(tokenIn, tokenOut, fee) != address(0),\n                \"Pool does not exist\"\n            );\n        }\n\n        return tokenIn == validTokenIn && tokenOut == validTokenOut;\n    }\n\n    /**\n     * @notice Swaps assets by calling UniswapV3 router\n     * @param recipient is the address of recipient of the tokenOut\n     * @param tokenIn is the address of the token given to the router\n     * @param amountIn is the amount of tokenIn given to the router\n     * @param minAmountOut is the minimum acceptable amount of tokenOut received from swap\n     * @param router is the contract address of UniswapV3 router\n     * @param swapPath is the swap path e.g. encodePacked(tokenIn, poolFee, tokenOut)\n     * @return amountOut is the amount of tokenOut received from the swap\n     */\n    function swap(\n        address recipient,\n        address tokenIn,\n        uint256 amountIn,\n        uint256 minAmountOut,\n        address router,\n        bytes calldata swapPath\n    ) internal returns (uint256 amountOut) {\n        // Approve router to spend tokenIn\n        IERC20(tokenIn).safeApprove(router, amountIn);\n\n        // Swap assets using UniswapV3 router\n        ISwapRouter.ExactInputParams memory swapParams =\n            ISwapRouter.ExactInputParams({\n                recipient: recipient,\n                path: swapPath,\n                deadline: block.timestamp.add(10 minutes),\n                amountIn: amountIn,\n                amountOutMinimum: minAmountOut\n            });\n\n        amountOut = ISwapRouter(router).exactInput(swapParams);\n\n        return amountOut;\n    }\n}\n"
    },
    "contracts/interfaces/IRibbonThetaVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {Vault} from \"../libraries/Vault.sol\";\n\ninterface IRibbonThetaVault {\n    function currentOption() external view returns (address);\n\n    function nextOption() external view returns (address);\n\n    function vaultParams() external view returns (Vault.VaultParams memory);\n\n    function vaultState() external view returns (Vault.VaultState memory);\n\n    function optionState() external view returns (Vault.OptionState memory);\n\n    function optionAuctionID() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.8.4;\npragma abicoder v2;\n\n/// Source: https://github.com/Uniswap/v3-core/blob/main/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n\n/// Source: https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/ISwapRouter.sol\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params)\n        external\n        payable\n        returns (uint256 amountIn);\n}\n"
    },
    "contracts/interfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Source: https://github.com/Uniswap/v3-core/blob/main/contracts/interfaces/IUniswapV3Factory.sol\npragma solidity =0.8.4;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n}\n"
    },
    "contracts/libraries/Path.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Source: https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/Path.sol\npragma solidity =0.8.4;\n\nimport \"./BytesLib.sol\";\n\n/// @title Functions for manipulating path data for multihop swaps\nlibrary Path {\n    using BytesLib for bytes;\n\n    /// @dev The length of the bytes encoded address\n    uint256 private constant ADDR_SIZE = 20;\n    /// @dev The length of the bytes encoded fee\n    uint256 private constant FEE_SIZE = 3;\n\n    /// @dev The offset of a single token address and pool fee\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\n    /// @dev The offset of an encoded pool key\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\n    /// @dev The minimum length of an encoding that contains 2 or more pools\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH =\n        POP_OFFSET + NEXT_OFFSET;\n\n    /// @notice Returns true iff the path contains two or more pools\n    /// @param path The encoded swap path\n    /// @return True if path contains two or more pools, otherwise false\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\n    }\n\n    /// @notice Returns the number of pools in the path\n    /// @param path The encoded swap path\n    /// @return The number of pools in the path\n    function numPools(bytes memory path) internal pure returns (uint256) {\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\n    }\n\n    /// @notice Decodes the first pool in path\n    /// @param path The bytes encoded swap path\n    /// @return tokenA The first token of the given pool\n    /// @return tokenB The second token of the given pool\n    /// @return fee The fee level of the pool\n    function decodeFirstPool(bytes memory path)\n        internal\n        pure\n        returns (\n            address tokenA,\n            address tokenB,\n            uint24 fee\n        )\n    {\n        tokenA = path.toAddress(0);\n        fee = path.toUint24(ADDR_SIZE);\n        tokenB = path.toAddress(NEXT_OFFSET);\n    }\n\n    /// @notice Gets the segment corresponding to the first pool in the path\n    /// @param path The bytes encoded swap path\n    /// @return The segment containing all data necessary to target the first pool in the path\n    function getFirstPool(bytes memory path)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return path.slice(0, POP_OFFSET);\n    }\n\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\n    /// @param path The swap path\n    /// @return The remaining token + fee elements in the path\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\n    }\n}\n"
    },
    "contracts/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Source: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonalo S <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity =0.8.4;\n\nlibrary BytesLib {\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n                case 0 {\n                    // Get a location of some free memory and store it in tempBytes as\n                    // Solidity does for memory variables.\n                    tempBytes := mload(0x40)\n\n                    // The first word of the slice result is potentially a partial\n                    // word read from the original array. To read it, we calculate\n                    // the length of that partial word and start copying that many\n                    // bytes into the array. The first word we copy will start with\n                    // data we don't care about, but the last `lengthmod` bytes will\n                    // land at the beginning of the contents of the new array. When\n                    // we're done copying, we overwrite the full first word with\n                    // the actual length of the slice.\n                    let lengthmod := and(_length, 31)\n\n                    // The multiplication in the next line is necessary\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\n                    // the following copy loop was copying the origin's length\n                    // and then ending prematurely not copying everything it should.\n                    let mc := add(\n                        add(tempBytes, lengthmod),\n                        mul(0x20, iszero(lengthmod))\n                    )\n                    let end := add(mc, _length)\n\n                    for {\n                        // The multiplication in the next line has the same exact purpose\n                        // as the one above.\n                        let cc := add(\n                            add(\n                                add(_bytes, lengthmod),\n                                mul(0x20, iszero(lengthmod))\n                            ),\n                            _start\n                        )\n                    } lt(mc, end) {\n                        mc := add(mc, 0x20)\n                        cc := add(cc, 0x20)\n                    } {\n                        mstore(mc, mload(cc))\n                    }\n\n                    mstore(tempBytes, _length)\n\n                    //update free-memory pointer\n                    //allocating the array padded to 32 bytes like the compiler does now\n                    mstore(0x40, and(add(mc, 31), not(31)))\n                }\n                //if we want a zero-length slice let's just return a zero-length array\n                default {\n                    tempBytes := mload(0x40)\n                    //zero out the 32 bytes slice we are about to return\n                    //we need to do it because Solidity does not garbage collect\n                    mstore(tempBytes, 0)\n\n                    mstore(0x40, add(tempBytes, 0x20))\n                }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (address)\n    {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(\n                mload(add(add(_bytes, 0x20), _start)),\n                0x1000000000000000000000000\n            )\n        }\n\n        return tempAddress;\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start)\n        internal\n        pure\n        returns (uint24)\n    {\n        require(_bytes.length >= _start + 3, \"toUint24_outOfBounds\");\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n}\n"
    },
    "contracts/vaults/YearnVaults/RibbonThetaYearnVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {DSMath} from \"../../vendor/DSMath.sol\";\nimport {GnosisAuction} from \"../../libraries/GnosisAuction.sol\";\nimport {Vault} from \"../../libraries/Vault.sol\";\nimport {ShareMath} from \"../../libraries/ShareMath.sol\";\nimport {VaultLifecycle} from \"../../libraries/VaultLifecycle.sol\";\nimport {VaultLifecycleYearn} from \"../../libraries/VaultLifecycleYearn.sol\";\nimport {RibbonVault} from \"./base/RibbonVault.sol\";\nimport {\n    RibbonThetaYearnVaultStorage\n} from \"../../storage/RibbonThetaYearnVaultStorage.sol\";\n\n/**\n * UPGRADEABILITY: Since we use the upgradeable proxy pattern, we must observe\n * the inheritance chain closely.\n * Any changes/appends in storage variable needs to happen in RibbonThetaYearnVaultStorage.\n * RibbonThetaYearnVault should not inherit from any other contract aside from RibbonVault, RibbonThetaYearnVaultStorage\n */\ncontract RibbonThetaYearnVault is RibbonVault, RibbonThetaYearnVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    /// @notice oTokenFactory is the factory contract used to spawn otokens. Used to lookup otokens.\n    address public immutable OTOKEN_FACTORY;\n\n    // The minimum duration for an option auction.\n    uint256 private constant MIN_AUCTION_DURATION = 5 minutes;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event OpenShort(\n        address indexed options,\n        uint256 depositAmount,\n        address indexed manager\n    );\n\n    event CloseShort(\n        address indexed options,\n        uint256 withdrawAmount,\n        address indexed manager\n    );\n\n    event NewOptionStrikeSelected(uint256 strikePrice, uint256 delta);\n\n    event PremiumDiscountSet(\n        uint256 premiumDiscount,\n        uint256 newPremiumDiscount\n    );\n    event AuctionDurationSet(\n        uint256 auctionDuration,\n        uint256 newAuctionDuration\n    );\n\n    event InstantWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n\n    event InitiateGnosisAuction(\n        address indexed auctioningToken,\n        address indexed biddingToken,\n        uint256 auctionCounter,\n        address indexed manager\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _oTokenFactory is the contract address for minting new opyn option types (strikes, asset, expiry)\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     * @param _yearnRegistry is the address of the yearn registry from token to vault token\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _oTokenFactory,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction,\n        address _yearnRegistry\n    )\n        RibbonVault(\n            _weth,\n            _usdc,\n            _gammaController,\n            _marginPool,\n            _gnosisEasyAuction,\n            _yearnRegistry\n        )\n    {\n        require(_oTokenFactory != address(0), \"!_oTokenFactory\");\n        OTOKEN_FACTORY = _oTokenFactory;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     * @param _owner is the owner of the vault with critical permissions\n     * @param _keeper is the keeper of the vault with medium permissions (weekly actions)\n     * @param _feeRecipient is the address to recieve vault performance and management fees\n     * @param _managementFee is the management fee pct.\n     * @param _performanceFee is the perfomance fee pct.\n     * @param _tokenName is the name of the token\n     * @param _tokenSymbol is the symbol of the token\n     * @param _optionsPremiumPricer is the address of the contract with the\n       black-scholes premium calculation logic\n     * @param _strikeSelection is the address of the contract with strike selection logic\n     * @param _premiumDiscount is the vault's discount applied to the premium\n     * @param _auctionDuration is the duration of the gnosis auction\n     * @param _vaultParams is the struct with vault general data\n     */\n    function initialize(\n        address _owner,\n        address _keeper,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        address _optionsPremiumPricer,\n        address _strikeSelection,\n        uint32 _premiumDiscount,\n        uint256 _auctionDuration,\n        Vault.VaultParams calldata _vaultParams\n    ) external initializer {\n        baseInitialize(\n            _owner,\n            _keeper,\n            _feeRecipient,\n            _managementFee,\n            _performanceFee,\n            _tokenName,\n            _tokenSymbol,\n            _vaultParams\n        );\n        require(_optionsPremiumPricer != address(0), \"!_optionsPremiumPricer\");\n        require(_strikeSelection != address(0), \"!_strikeSelection\");\n        require(\n            _premiumDiscount > 0 &&\n                _premiumDiscount < 100 * Vault.PREMIUM_DISCOUNT_MULTIPLIER,\n            \"!_premiumDiscount\"\n        );\n        require(_auctionDuration >= MIN_AUCTION_DURATION, \"!_auctionDuration\");\n        optionsPremiumPricer = _optionsPremiumPricer;\n        strikeSelection = _strikeSelection;\n        premiumDiscount = _premiumDiscount;\n        auctionDuration = _auctionDuration;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new discount on premiums for options we are selling\n     * @param newPremiumDiscount is the premium discount\n     */\n    function setPremiumDiscount(uint256 newPremiumDiscount) external onlyOwner {\n        require(\n            newPremiumDiscount > 0 &&\n                newPremiumDiscount < 100 * Vault.PREMIUM_DISCOUNT_MULTIPLIER,\n            \"Invalid discount\"\n        );\n        emit PremiumDiscountSet(premiumDiscount, newPremiumDiscount);\n\n        premiumDiscount = newPremiumDiscount;\n    }\n\n    /**\n     * @notice Sets the new auction duration\n     * @param newAuctionDuration is the auction duration\n     */\n    function setAuctionDuration(uint256 newAuctionDuration) external onlyOwner {\n        require(\n            newAuctionDuration >= MIN_AUCTION_DURATION,\n            \"Invalid auction duration\"\n        );\n        emit AuctionDurationSet(auctionDuration, newAuctionDuration);\n\n        auctionDuration = newAuctionDuration;\n    }\n\n    /**\n     * @notice Sets the new strike selection contract\n     * @param newStrikeSelection is the address of the new strike selection contract\n     */\n    function setStrikeSelection(address newStrikeSelection) external onlyOwner {\n        require(newStrikeSelection != address(0), \"!newStrikeSelection\");\n        strikeSelection = newStrikeSelection;\n    }\n\n    /**\n     * @notice Sets the new options premium pricer contract\n     * @param newOptionsPremiumPricer is the address of the new strike selection contract\n     */\n    function setOptionsPremiumPricer(address newOptionsPremiumPricer)\n        external\n        onlyOwner\n    {\n        require(\n            newOptionsPremiumPricer != address(0),\n            \"!newOptionsPremiumPricer\"\n        );\n        optionsPremiumPricer = newOptionsPremiumPricer;\n    }\n\n    /**\n     * @notice Optionality to set strike price manually\n     * @param strikePrice is the strike price of the new oTokens (decimals = 8)\n     */\n    function setStrikePrice(uint128 strikePrice)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        require(strikePrice > 0, \"!strikePrice\");\n        overriddenStrikePrice = strikePrice;\n        lastStrikeOverrideRound = vaultState.round;\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `DepositReceipt.amount`\n     * @param amount is the amount to withdraw\n     */\n    function withdrawInstantly(uint256 amount) external nonReentrant {\n        Vault.DepositReceipt storage depositReceipt =\n            depositReceipts[msg.sender];\n\n        uint256 currentRound = vaultState.round;\n\n        require(amount > 0, \"!amount\");\n        require(depositReceipt.round == currentRound, \"Invalid round\");\n\n        uint256 receiptAmount = depositReceipt.amount;\n        require(receiptAmount >= amount, \"Exceed amount\");\n\n        // Subtraction underflow checks already ensure it is smaller than uint104\n        depositReceipt.amount = uint104(receiptAmount.sub(amount));\n        vaultState.totalPending = uint128(\n            uint256(vaultState.totalPending).sub(amount)\n        );\n\n        emit InstantWithdraw(msg.sender, amount, currentRound);\n\n        VaultLifecycleYearn.unwrapYieldToken(\n            amount,\n            vaultParams.asset,\n            address(collateralToken),\n            YEARN_WITHDRAWAL_BUFFER,\n            YEARN_WITHDRAWAL_SLIPPAGE\n        );\n        VaultLifecycleYearn.transferAsset(\n            WETH,\n            vaultParams.asset,\n            msg.sender,\n            amount\n        );\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     */\n    function completeWithdraw() external nonReentrant {\n        uint256 withdrawAmount = _completeWithdraw();\n        lastQueuedWithdrawAmount = uint128(\n            uint256(lastQueuedWithdrawAmount).sub(withdrawAmount)\n        );\n    }\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and closes the existing short.\n     *         This allows all the users to withdraw if the next option is malicious.\n     */\n    function commitAndClose() external nonReentrant {\n        address oldOption = optionState.currentOption;\n\n        VaultLifecycle.CloseParams memory closeParams =\n            VaultLifecycle.CloseParams({\n                OTOKEN_FACTORY: OTOKEN_FACTORY,\n                USDC: USDC,\n                currentOption: oldOption,\n                delay: DELAY,\n                lastStrikeOverrideRound: lastStrikeOverrideRound,\n                overriddenStrikePrice: overriddenStrikePrice\n            });\n\n        (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        ) =\n            VaultLifecycleYearn.commitAndClose(\n                strikeSelection,\n                optionsPremiumPricer,\n                premiumDiscount,\n                closeParams,\n                vaultParams,\n                vaultState,\n                address(collateralToken)\n            );\n\n        emit NewOptionStrikeSelected(strikePrice, delta);\n\n        ShareMath.assertUint104(premium);\n\n        currentOtokenPremium = uint104(premium);\n        optionState.nextOption = otokenAddress;\n        uint256 nextOptionReady = block.timestamp.add(DELAY);\n        require(\n            nextOptionReady <= type(uint32).max,\n            \"Overflow nextOptionReady\"\n        );\n        optionState.nextOptionReadyAt = uint32(nextOptionReady);\n\n        _closeShort(oldOption);\n    }\n\n    /**\n     * @notice Closes the existing short position for the vault.\n     */\n    function _closeShort(address oldOption) private {\n        uint256 lockedAmount = vaultState.lockedAmount;\n        if (oldOption != address(0)) {\n            vaultState.lastLockedAmount = uint104(lockedAmount);\n        }\n        vaultState.lockedAmount = 0;\n\n        optionState.currentOption = address(0);\n\n        if (oldOption != address(0)) {\n            uint256 withdrawAmount =\n                VaultLifecycle.settleShort(GAMMA_CONTROLLER);\n            emit CloseShort(oldOption, withdrawAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Rolls the vault's funds into a new short position.\n     */\n    function rollToNextOption() external onlyKeeper nonReentrant {\n        (address newOption, uint256 queuedWithdrawAmount) =\n            _rollToNextOption(uint256(lastQueuedWithdrawAmount));\n\n        lastQueuedWithdrawAmount = queuedWithdrawAmount;\n\n        // Locked balance denominated in `collateralToken`\n        // there is a slight imprecision with regards to calculating back from yearn token -> underlying\n        // that stems from miscoordination between ytoken .deposit() amount wrapped and pricePerShare\n        // at that point in time.\n        // ex: if I have 1 eth, deposit 1 eth into yearn vault and calculate value of yearn token balance\n        // denominated in eth (via balance(yearn token) * pricePerShare) we will get 1 eth - 1 wei.\n\n        // We are subtracting `collateralAsset` balance by queuedWithdrawAmount denominated in `collateralAsset` plus\n        // a buffer for withdrawals taking into account slippage from yearn vault\n\n        uint256 lockedBalance =\n            collateralToken.balanceOf(address(this)).sub(\n                DSMath.wdiv(\n                    queuedWithdrawAmount.add(\n                        queuedWithdrawAmount.mul(YEARN_WITHDRAWAL_BUFFER).div(\n                            10000\n                        )\n                    ),\n                    collateralToken.pricePerShare().mul(\n                        VaultLifecycleYearn.decimalShift(\n                            address(collateralToken)\n                        )\n                    )\n                )\n            );\n\n        emit OpenShort(newOption, lockedBalance, msg.sender);\n\n        VaultLifecycle.createShort(\n            GAMMA_CONTROLLER,\n            MARGIN_POOL,\n            newOption,\n            lockedBalance\n        );\n\n        _startAuction();\n    }\n\n    /**\n     * @notice Initiate the gnosis auction.\n     */\n    function startAuction() external onlyKeeper nonReentrant {\n        _startAuction();\n    }\n\n    function _startAuction() private {\n        GnosisAuction.AuctionDetails memory auctionDetails;\n\n        uint256 currOtokenPremium = currentOtokenPremium;\n\n        require(currOtokenPremium > 0, \"!currentOtokenPremium\");\n\n        auctionDetails.oTokenAddress = optionState.currentOption;\n        auctionDetails.gnosisEasyAuction = GNOSIS_EASY_AUCTION;\n        auctionDetails.asset = vaultParams.asset;\n        auctionDetails.assetDecimals = vaultParams.decimals;\n        auctionDetails.oTokenPremium = currOtokenPremium;\n        auctionDetails.duration = auctionDuration;\n\n        optionAuctionID = VaultLifecycle.startAuction(auctionDetails);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from gnosis auction.\n     */\n    function burnRemainingOTokens() external onlyKeeper nonReentrant {\n        uint256 unlockedAssetAmount =\n            VaultLifecycle.burnOtokens(\n                GAMMA_CONTROLLER,\n                optionState.currentOption\n            );\n\n        vaultState.lockedAmount = uint104(\n            uint256(vaultState.lockedAmount).sub(unlockedAssetAmount)\n        );\n\n        // Wrap entire `asset` balance to `collateralToken` balance\n        VaultLifecycleYearn.wrapToYieldToken(\n            vaultParams.asset,\n            address(collateralToken)\n        );\n    }\n}\n"
    },
    "contracts/vaults/YearnVaults/base/RibbonVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    ERC20Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport {DSMath} from \"../../../vendor/DSMath.sol\";\nimport {IYearnRegistry, IYearnVault} from \"../../../interfaces/IYearn.sol\";\nimport {Vault} from \"../../../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../../../libraries/VaultLifecycle.sol\";\nimport {VaultLifecycleYearn} from \"../../../libraries/VaultLifecycleYearn.sol\";\nimport {ShareMath} from \"../../../libraries/ShareMath.sol\";\nimport {IWETH} from \"../../../interfaces/IWETH.sol\";\n\ncontract RibbonVault is\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    ERC20Upgradeable\n{\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  NON UPGRADEABLE STORAGE\n     ***********************************************/\n\n    /// @notice Stores the user's pending deposit for the round\n    mapping(address => Vault.DepositReceipt) public depositReceipts;\n\n    /// @notice On every round's close, the pricePerShare value of an rTHETA token is stored\n    /// This is used to determine the number of shares to be returned\n    /// to a user with their DepositReceipt.depositAmount\n    mapping(uint256 => uint256) public roundPricePerShare;\n\n    /// @notice Stores pending user withdrawals\n    mapping(address => Vault.Withdrawal) public withdrawals;\n\n    /// @notice Vault's parameters like cap, decimals\n    Vault.VaultParams public vaultParams;\n\n    /// @notice Vault's lifecycle state like round and locked amounts\n    Vault.VaultState public vaultState;\n\n    /// @notice Vault's state of the options sold and the timelocked option\n    Vault.OptionState public optionState;\n\n    /// @notice Fee recipient for the performance and management fees\n    address public feeRecipient;\n\n    /// @notice role in charge of weekly vault operations such as rollToNextOption and burnRemainingOTokens\n    // no access to critical vault changes\n    address public keeper;\n\n    /// @notice Performance fee charged on premiums earned in rollToNextOption. Only charged when there is no loss.\n    uint256 public performanceFee;\n\n    /// @notice Management fee charged on entire AUM in rollToNextOption. Only charged when there is no loss.\n    uint256 public managementFee;\n\n    /// @notice Yearn vault contract\n    IYearnVault public collateralToken;\n\n    // Gap is left to avoid storage collisions. Though RibbonVault is not upgradeable, we add this as a safety measure.\n    uint256[30] private ____gap;\n\n    // *IMPORTANT* NO NEW STORAGE VARIABLES SHOULD BE ADDED HERE\n    // This is to prevent storage collisions. All storage variables should be appended to RibbonThetaYearnVaultStorage\n    // https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#modifying-your-contracts\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    /// @notice WETH9 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n    address public immutable WETH;\n\n    /// @notice USDC 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n    address public immutable USDC;\n\n    /// @notice 15 minute timelock between commitAndClose and rollToNexOption.\n    uint256 public constant DELAY = 0;\n\n    /// @notice Withdrawal buffer for yearn vault\n    uint256 public constant YEARN_WITHDRAWAL_BUFFER = 5; // 0.05%\n\n    /// @notice Slippage incurred during withdrawal\n    uint256 public constant YEARN_WITHDRAWAL_SLIPPAGE = 5; // 0.05%\n\n    /// @notice 7 day period between each options sale.\n    uint256 public constant PERIOD = 7 days;\n\n    // Number of weeks per year = 52.142857 weeks * FEE_MULTIPLIER = 52142857\n    // Dividing by weeks per year requires doing num.mul(FEE_MULTIPLIER).div(WEEKS_PER_YEAR)\n    uint256 private constant WEEKS_PER_YEAR = 52142857;\n\n    // GAMMA_CONTROLLER is the top-level contract in Gamma protocol\n    // which allows users to perform multiple actions on their vaults\n    // and positions https://github.com/opynfinance/GammaProtocol/blob/master/contracts/core/Controller.sol\n    address public immutable GAMMA_CONTROLLER;\n\n    // MARGIN_POOL is Gamma protocol's collateral pool.\n    // Needed to approve collateral.safeTransferFrom for minting otokens.\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/core/MarginPool.sol\n    address public immutable MARGIN_POOL;\n\n    // GNOSIS_EASY_AUCTION is Gnosis protocol's contract for initiating auctions and placing bids\n    // https://github.com/gnosis/ido-contracts/blob/main/contracts/EasyAuction.sol\n    address public immutable GNOSIS_EASY_AUCTION;\n\n    // Yearn registry contract\n    address public immutable YEARN_REGISTRY;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event Deposit(address indexed account, uint256 amount, uint256 round);\n\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n\n    event Redeem(address indexed account, uint256 share, uint256 round);\n\n    event ManagementFeeSet(uint256 managementFee, uint256 newManagementFee);\n\n    event PerformanceFeeSet(uint256 performanceFee, uint256 newPerformanceFee);\n\n    event CapSet(uint256 oldCap, uint256 newCap);\n\n    event Withdraw(address indexed account, uint256 amount, uint256 shares);\n\n    event CollectVaultFees(\n        uint256 performanceFee,\n        uint256 vaultFee,\n        uint256 round,\n        address indexed feeRecipient\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     * @param _yearnRegistry is the address of the yearn registry from token to vault token\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction,\n        address _yearnRegistry\n    ) {\n        require(_weth != address(0), \"!_weth\");\n        require(_usdc != address(0), \"!_usdc\");\n        require(_gnosisEasyAuction != address(0), \"!_gnosisEasyAuction\");\n        require(_gammaController != address(0), \"!_gammaController\");\n        require(_marginPool != address(0), \"!_marginPool\");\n        require(_yearnRegistry != address(0), \"!_yearnRegistry\");\n\n        WETH = _weth;\n        USDC = _usdc;\n        GAMMA_CONTROLLER = _gammaController;\n        MARGIN_POOL = _marginPool;\n        GNOSIS_EASY_AUCTION = _gnosisEasyAuction;\n        YEARN_REGISTRY = _yearnRegistry;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function baseInitialize(\n        address _owner,\n        address _keeper,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) internal initializer {\n        VaultLifecycle.verifyInitializerParams(\n            _owner,\n            _keeper,\n            _feeRecipient,\n            _performanceFee,\n            _managementFee,\n            _tokenName,\n            _tokenSymbol,\n            _vaultParams\n        );\n\n        __ReentrancyGuard_init();\n        __ERC20_init(_tokenName, _tokenSymbol);\n        __Ownable_init();\n        transferOwnership(_owner);\n\n        keeper = _keeper;\n\n        feeRecipient = _feeRecipient;\n        performanceFee = _performanceFee;\n        managementFee = _managementFee.mul(Vault.FEE_MULTIPLIER).div(\n            WEEKS_PER_YEAR\n        );\n        vaultParams = _vaultParams;\n\n        _upgradeYearnVault();\n\n        uint256 assetBalance = totalBalance();\n        ShareMath.assertUint104(assetBalance);\n        vaultState.lastLockedAmount = uint104(assetBalance);\n\n        vaultState.round = 1;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the keeper.\n     */\n    modifier onlyKeeper() {\n        require(msg.sender == keeper, \"!keeper\");\n        _;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new keeper\n     * @param newKeeper is the address of the new keeper\n     */\n    function setNewKeeper(address newKeeper) external onlyOwner {\n        require(newKeeper != address(0), \"!newKeeper\");\n        keeper = newKeeper;\n    }\n\n    /**\n     * @notice Sets the new fee recipient\n     * @param newFeeRecipient is the address of the new fee recipient\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        require(newFeeRecipient != address(0), \"!newFeeRecipient\");\n        require(newFeeRecipient != feeRecipient, \"Must be new feeRecipient\");\n        feeRecipient = newFeeRecipient;\n    }\n\n    /**\n     * @notice Sets the management fee for the vault\n     * @param newManagementFee is the management fee (6 decimals). ex: 2 * 10 ** 6 = 2%\n     */\n    function setManagementFee(uint256 newManagementFee) external onlyOwner {\n        require(\n            newManagementFee < 100 * Vault.FEE_MULTIPLIER,\n            \"Invalid management fee\"\n        );\n\n        // We are dividing annualized management fee by num weeks in a year\n        uint256 tmpManagementFee =\n            newManagementFee.mul(Vault.FEE_MULTIPLIER).div(WEEKS_PER_YEAR);\n\n        emit ManagementFeeSet(managementFee, newManagementFee);\n\n        managementFee = tmpManagementFee;\n    }\n\n    /**\n     * @notice Sets the performance fee for the vault\n     * @param newPerformanceFee is the performance fee (6 decimals). ex: 20 * 10 ** 6 = 20%\n     */\n    function setPerformanceFee(uint256 newPerformanceFee) external onlyOwner {\n        require(\n            newPerformanceFee < 100 * Vault.FEE_MULTIPLIER,\n            \"Invalid performance fee\"\n        );\n        emit PerformanceFeeSet(performanceFee, newPerformanceFee);\n        performanceFee = newPerformanceFee;\n    }\n\n    /**\n     * @notice Sets a new cap for deposits\n     * @param newCap is the new cap for deposits\n     */\n    function setCap(uint256 newCap) external onlyOwner {\n        require(newCap > 0, \"!newCap\");\n        ShareMath.assertUint104(newCap);\n        emit CapSet(vaultParams.cap, newCap);\n        vaultParams.cap = uint104(newCap);\n    }\n\n    /************************************************\n     *  DEPOSIT & WITHDRAWALS\n     ***********************************************/\n\n    /**\n     * @notice Deposits the `asset` from msg.sender.\n     * @param amount is the amount of `asset` to deposit\n     */\n    function deposit(uint256 amount) external nonReentrant {\n        require(amount > 0, \"!amount\");\n\n        _depositFor(amount, msg.sender);\n\n        // An approve() by the msg.sender is required beforehand\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\n     * @notice Used for vault -> vault deposits on the user's behalf\n     * @param amount is the amount of `asset` to deposit\n     * @param creditor is the address that can claim/withdraw deposited amount\n     */\n    function depositFor(uint256 amount, address creditor)\n        external\n        nonReentrant\n    {\n        require(amount > 0, \"!amount\");\n        require(creditor != address(0), \"!creditor\");\n\n        _depositFor(amount, creditor);\n\n        // An approve() by the msg.sender is required beforehand\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `collateralToken` into the contract and mint vault shares.\n     * @param amount is the amount of `collateralToken` to deposit\n     */\n    function depositYieldToken(uint256 amount) external nonReentrant {\n        require(amount > 0, \"!amount\");\n\n        uint256 amountInAsset =\n            DSMath.wmul(\n                amount,\n                collateralToken.pricePerShare().mul(\n                    VaultLifecycleYearn.decimalShift(address(collateralToken))\n                )\n            );\n\n        _depositFor(amountInAsset, msg.sender);\n\n        IERC20(address(collateralToken)).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Mints the vault shares to the creditor\n     * @param amount is the amount of `asset` deposited\n     * @param creditor is the address to receieve the deposit\n     */\n    function _depositFor(uint256 amount, address creditor) private {\n        uint256 currentRound = vaultState.round;\n        uint256 totalWithDepositedAmount = totalBalance().add(amount);\n\n        require(totalWithDepositedAmount <= vaultParams.cap, \"Exceed cap\");\n        require(\n            totalWithDepositedAmount >= vaultParams.minimumSupply,\n            \"Insufficient balance\"\n        );\n\n        emit Deposit(creditor, amount, currentRound);\n\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[creditor];\n\n        // If we have an unprocessed pending deposit from the previous rounds, we have to process it.\n        uint256 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        uint256 depositAmount = amount;\n        // If we have a pending deposit in the current round, we add on to the pending deposit\n        if (currentRound == depositReceipt.round) {\n            uint256 newAmount = uint256(depositReceipt.amount).add(amount);\n            depositAmount = newAmount;\n        }\n\n        ShareMath.assertUint104(depositAmount);\n\n        depositReceipts[creditor] = Vault.DepositReceipt({\n            round: uint16(currentRound),\n            amount: uint104(depositAmount),\n            unredeemedShares: uint128(unredeemedShares)\n        });\n\n        uint256 newTotalPending = uint256(vaultState.totalPending).add(amount);\n        ShareMath.assertUint128(newTotalPending);\n        vaultState.totalPending = uint128(newTotalPending);\n    }\n\n    /**\n     * @notice Initiates a withdrawal that can be processed once the round completes\n     * @param numShares is the number of shares to withdraw\n     */\n    function initiateWithdraw(uint256 numShares) external nonReentrant {\n        require(numShares > 0, \"!numShares\");\n\n        // We do a max redeem before initiating a withdrawal\n        // But we check if they must first have unredeemed shares\n        if (\n            depositReceipts[msg.sender].amount > 0 ||\n            depositReceipts[msg.sender].unredeemedShares > 0\n        ) {\n            _redeem(0, true);\n        }\n\n        // This caches the `round` variable used in shareBalances\n        uint256 currentRound = vaultState.round;\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        bool withdrawalIsSameRound = withdrawal.round == currentRound;\n        emit InitiateWithdraw(msg.sender, numShares, currentRound);\n        uint256 existingShares = uint256(withdrawal.shares);\n        uint256 withdrawalShares;\n        if (withdrawalIsSameRound) {\n            withdrawalShares = existingShares.add(numShares);\n        } else {\n            require(existingShares == 0, \"Existing withdraw\");\n            withdrawalShares = numShares;\n            withdrawals[msg.sender].round = uint16(currentRound);\n        }\n        ShareMath.assertUint128(withdrawalShares);\n        withdrawals[msg.sender].shares = uint128(withdrawalShares);\n        uint256 newQueuedWithdrawShares =\n            uint256(vaultState.queuedWithdrawShares).add(numShares);\n        ShareMath.assertUint128(newQueuedWithdrawShares);\n        vaultState.queuedWithdrawShares = uint128(newQueuedWithdrawShares);\n\n        _transfer(msg.sender, address(this), numShares);\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     * @return withdrawAmount the current withdrawal amount\n     */\n    function _completeWithdraw() internal returns (uint256) {\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        uint256 withdrawalShares = withdrawal.shares;\n        uint256 withdrawalRound = withdrawal.round;\n\n        // This checks if there is a withdrawal\n        require(withdrawalShares > 0, \"Not initiated\");\n\n        require(withdrawalRound < vaultState.round, \"Round not closed\");\n\n        // We leave the round number as non-zero to save on gas for subsequent writes\n        withdrawals[msg.sender].shares = 0;\n        vaultState.queuedWithdrawShares = uint128(\n            uint256(vaultState.queuedWithdrawShares).sub(withdrawalShares)\n        );\n\n        uint256 withdrawAmount =\n            ShareMath.sharesToAsset(\n                withdrawalShares,\n                roundPricePerShare[withdrawalRound],\n                vaultParams.decimals\n            );\n\n        emit Withdraw(msg.sender, withdrawAmount, withdrawalShares);\n\n        _burn(address(this), withdrawalShares);\n\n        VaultLifecycleYearn.unwrapYieldToken(\n            withdrawAmount,\n            vaultParams.asset,\n            address(collateralToken),\n            YEARN_WITHDRAWAL_BUFFER,\n            YEARN_WITHDRAWAL_SLIPPAGE\n        );\n\n        require(withdrawAmount > 0, \"!withdrawAmount\");\n\n        VaultLifecycleYearn.transferAsset(\n            WETH,\n            vaultParams.asset,\n            msg.sender,\n            withdrawAmount\n        );\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem\n     */\n    function redeem(uint256 numShares) external nonReentrant {\n        require(numShares > 0, \"!numShares\");\n        _redeem(numShares, false);\n    }\n\n    /**\n     * @notice Redeems the entire unredeemedShares balance that is owed to the account\n     */\n    function maxRedeem() external nonReentrant {\n        _redeem(0, true);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem, could be 0 when isMax=true\n     * @param isMax is flag for when callers do a max redemption\n     */\n    function _redeem(uint256 numShares, bool isMax) internal {\n        Vault.DepositReceipt memory depositReceipt =\n            depositReceipts[msg.sender];\n\n        // This handles the null case when depositReceipt.round = 0\n        // Because we start with round = 1 at `initialize`\n        uint256 currentRound = vaultState.round;\n\n        uint256 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        numShares = isMax ? unredeemedShares : numShares;\n        if (numShares == 0) {\n            return;\n        }\n        require(numShares <= unredeemedShares, \"Exceeds available\");\n\n        // If we have a depositReceipt on the same round, BUT we have some unredeemed shares\n        // we debit from the unredeemedShares, but leave the amount field intact\n        // If the round has past, with no new deposits, we just zero it out for new deposits.\n        if (depositReceipt.round < currentRound) {\n            depositReceipts[msg.sender].amount = 0;\n        }\n\n        ShareMath.assertUint128(numShares);\n\n        depositReceipts[msg.sender].unredeemedShares = uint128(\n            unredeemedShares.sub(numShares)\n        );\n\n        emit Redeem(msg.sender, numShares, depositReceipt.round);\n\n        _transfer(address(this), msg.sender, numShares);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /*\n     * @notice Helper function that helps to save gas for writing values into the roundPricePerShare map.\n     *         Writing `1` into the map makes subsequent writes warm, reducing the gas from 20k to 5k.\n     *         Having 1 initialized beforehand will not be an issue as long as we round down share calculations to 0.\n     * @param numRounds is the number of rounds to initialize in the map\n     */\n    function initRounds(uint256 numRounds) external nonReentrant {\n        require(numRounds > 0, \"!numRounds\");\n\n        uint256 _round = vaultState.round;\n        for (uint256 i = 0; i < numRounds; i++) {\n            uint256 index = _round + i;\n            require(roundPricePerShare[index] == 0, \"Initialized\"); // AVOID OVERWRITING ACTUAL VALUES\n            roundPricePerShare[index] = ShareMath.PLACEHOLDER_UINT;\n        }\n    }\n\n    /*\n     * @notice Helper function that performs most administrative tasks\n     * such as setting next option, minting new shares, getting vault fees, etc.\n     * @param lastQueuedWithdrawAmount is old queued withdraw amount\n     * @return newOption is the new option address\n     * @return queuedWithdrawAmount is the queued amount for withdrawal\n     */\n    function _rollToNextOption(uint256 lastQueuedWithdrawAmount)\n        internal\n        returns (address, uint256)\n    {\n        require(block.timestamp >= optionState.nextOptionReadyAt, \"!ready\");\n\n        address newOption = optionState.nextOption;\n        require(newOption != address(0), \"!nextOption\");\n\n        (\n            uint256 lockedBalance,\n            uint256 queuedWithdrawAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares,\n            uint256 performanceFeeInAsset,\n            uint256 totalVaultFee\n        ) =\n            VaultLifecycle.rollover(\n                vaultState,\n                VaultLifecycle.RolloverParams(\n                    vaultParams.decimals,\n                    totalBalance(),\n                    totalSupply(),\n                    lastQueuedWithdrawAmount,\n                    performanceFee,\n                    managementFee\n                )\n            );\n\n        optionState.currentOption = newOption;\n        optionState.nextOption = address(0);\n\n        // Finalize the pricePerShare at the end of the round\n        uint256 currentRound = vaultState.round;\n        roundPricePerShare[currentRound] = newPricePerShare;\n\n        address recipient = feeRecipient;\n\n        emit CollectVaultFees(\n            performanceFeeInAsset,\n            totalVaultFee,\n            currentRound,\n            recipient\n        );\n\n        vaultState.totalPending = 0;\n        vaultState.round = uint16(currentRound + 1);\n        ShareMath.assertUint104(lockedBalance);\n        vaultState.lockedAmount = uint104(lockedBalance);\n\n        _mint(address(this), mintShares);\n\n        address collateral = address(collateralToken);\n\n        // Wrap entire `asset` balance to `collateralToken` balance\n        VaultLifecycleYearn.wrapToYieldToken(vaultParams.asset, collateral);\n\n        if (totalVaultFee > 0) {\n            VaultLifecycleYearn.withdrawYieldAndBaseToken(\n                WETH,\n                vaultParams.asset,\n                collateral,\n                recipient,\n                totalVaultFee\n            );\n        }\n\n        return (newOption, queuedWithdrawAmount);\n    }\n\n    /*\n      Upgrades the vault to point to the latest yearn vault for the asset token\n    */\n    function upgradeYearnVault() external onlyOwner {\n        // Unwrap old yvUSDC\n        IYearnVault collateral = IYearnVault(collateralToken);\n        collateral.withdraw(\n            collateral.balanceOf(address(this)),\n            address(this),\n            YEARN_WITHDRAWAL_SLIPPAGE\n        );\n\n        _upgradeYearnVault();\n    }\n\n    function _upgradeYearnVault() internal {\n        address collateralAddr =\n            IYearnRegistry(YEARN_REGISTRY).latestVault(vaultParams.asset);\n        require(collateralAddr != address(0), \"!collateralToken\");\n        collateralToken = IYearnVault(collateralAddr);\n    }\n\n    /************************************************\n     *  GETTERS\n     ***********************************************/\n\n    /**\n     * @notice Returns the asset balance held on the vault for the account\n     * @param account is the address to lookup balance for\n     * @return the amount of `asset` custodied by the vault for the user\n     */\n    function accountVaultBalance(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 _decimals = vaultParams.decimals;\n        uint256 assetPerShare =\n            ShareMath.pricePerShare(\n                totalSupply(),\n                totalBalance(),\n                vaultState.totalPending,\n                _decimals\n            );\n        return\n            ShareMath.sharesToAsset(shares(account), assetPerShare, _decimals);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance including unredeemed shares\n     * @param account is the account to lookup share balance for\n     * @return the share balance\n     */\n    function shares(address account) public view returns (uint256) {\n        (uint256 heldByAccount, uint256 heldByVault) = shareBalances(account);\n        return heldByAccount.add(heldByVault);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance split between account and vault holdings\n     * @param account is the account to lookup share balance for\n     * @return heldByAccount is the shares held by account\n     * @return heldByVault is the shares held on the vault (unredeemedShares)\n     */\n    function shareBalances(address account)\n        public\n        view\n        returns (uint256 heldByAccount, uint256 heldByVault)\n    {\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[account];\n\n        if (depositReceipt.round < ShareMath.PLACEHOLDER_UINT) {\n            return (balanceOf(account), 0);\n        }\n\n        uint256 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                vaultState.round,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        return (balanceOf(account), unredeemedShares);\n    }\n\n    /**\n     * @notice The price of a unit of share denominated in the `asset`\n     */\n    function pricePerShare() external view returns (uint256) {\n        return\n            ShareMath.pricePerShare(\n                totalSupply(),\n                totalBalance(),\n                vaultState.totalPending,\n                vaultParams.decimals\n            );\n    }\n\n    /**\n     * @notice Returns the vault's total balance, including the amounts locked into a short position\n     * @return total balance of the vault, including the amounts locked in third party protocols\n     */\n    function totalBalance() public view returns (uint256) {\n        return\n            uint256(vaultState.lockedAmount)\n                .add(IERC20(vaultParams.asset).balanceOf(address(this)))\n                .add(\n                DSMath.wmul(\n                    collateralToken.balanceOf(address(this)),\n                    collateralToken.pricePerShare().mul(\n                        VaultLifecycleYearn.decimalShift(\n                            address(collateralToken)\n                        )\n                    )\n                )\n            );\n    }\n\n    /**\n     * @notice Returns the token decimals\n     */\n    function decimals() public view override returns (uint8) {\n        return vaultParams.decimals;\n    }\n\n    function cap() external view returns (uint256) {\n        return vaultParams.cap;\n    }\n\n    function nextOptionReadyAt() external view returns (uint256) {\n        return optionState.nextOptionReadyAt;\n    }\n\n    function currentOption() external view returns (address) {\n        return optionState.currentOption;\n    }\n\n    function nextOption() external view returns (address) {\n        return optionState.nextOption;\n    }\n\n    function totalPending() external view returns (uint256) {\n        return vaultState.totalPending;\n    }\n\n    /************************************************\n     *  HELPERS\n     ***********************************************/\n}\n"
    },
    "contracts/storage/RibbonThetaYearnVaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nabstract contract RibbonThetaYearnVaultStorageV1 {\n    // Logic contract used to price options\n    address public optionsPremiumPricer;\n    // Logic contract used to select strike prices\n    address public strikeSelection;\n    // Premium discount on options we are selling (thousandths place: 000 - 999)\n    uint256 public premiumDiscount;\n    // Current oToken premium\n    uint256 public currentOtokenPremium;\n    // Last round id at which the strike was manually overridden\n    uint16 public lastStrikeOverrideRound;\n    // Price last overridden strike set to\n    uint256 public overriddenStrikePrice;\n    // Auction duration\n    uint256 public auctionDuration;\n    // Auction id of current option\n    uint256 public optionAuctionID;\n}\n\nabstract contract RibbonThetaYearnVaultStorageV2 {\n    // Amount locked for scheduled withdrawals last week;\n    uint256 public lastQueuedWithdrawAmount;\n}\n\n// We are following Compound's method of upgrading new contract implementations\n// When we need to add new storage variables, we create a new version of RibbonThetaVaultStorage\n// e.g. RibbonThetaVaultStorage<versionNumber>, so finally it would look like\n// contract RibbonThetaVaultStorage is RibbonThetaVaultStorageV1, RibbonThetaVaultStorageV2\nabstract contract RibbonThetaYearnVaultStorage is\n    RibbonThetaYearnVaultStorageV1,\n    RibbonThetaYearnVaultStorageV2\n{\n\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal initializer {\n        __Context_init_unchained();\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal initializer {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal initializer {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal initializer {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/vaults/TreasuryVault/RibbonTreasuryVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    ERC20Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport {Vault} from \"../../libraries/Vault.sol\";\nimport {\n    VaultLifecycleTreasury\n} from \"../../libraries/VaultLifecycleTreasury.sol\";\nimport {\n    RibbonTreasuryVaultStorage\n} from \"../../storage/RibbonTreasuryVaultStorage.sol\";\nimport {ShareMath} from \"../../libraries/ShareMath.sol\";\nimport {IWETH} from \"../../interfaces/IWETH.sol\";\nimport {GnosisAuction} from \"../../libraries/GnosisAuction.sol\";\nimport {IERC20Detailed} from \"../../interfaces/IERC20Detailed.sol\";\n\ncontract RibbonTreasuryVault is\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    ERC20Upgradeable,\n    RibbonTreasuryVaultStorage\n{\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    /// @notice WETH9 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n    address public immutable WETH;\n\n    /// @notice USDC 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n    address public immutable USDC;\n\n    /// @notice 15 minute timelock between commitAndClose and rollToNexOption.\n    uint256 public constant DELAY = 0;\n\n    // Number of weeks per year = 52.142857 weeks * FEE_MULTIPLIER = 52142857\n    // Dividing by weeks per year requires doing num.mul(FEE_MULTIPLIER).div(WEEKS_PER_YEAR)\n    uint256 private constant WEEKS_PER_YEAR = 52142857;\n\n    // GAMMA_CONTROLLER is the top-level contract in Gamma protocol\n    // which allows users to perform multiple actions on their vaults\n    // and positions https://github.com/opynfinance/GammaProtocol/blob/master/contracts/core/Controller.sol\n    address public immutable GAMMA_CONTROLLER;\n\n    // MARGIN_POOL is Gamma protocol's collateral pool.\n    // Needed to approve collateral.safeTransferFrom for minting otokens.\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/core/MarginPool.sol\n    address public immutable MARGIN_POOL;\n\n    // GNOSIS_EASY_AUCTION is Gnosis protocol's contract for initiating auctions and placing bids\n    // https://github.com/gnosis/ido-contracts/blob/main/contracts/EasyAuction.sol\n    address public immutable GNOSIS_EASY_AUCTION;\n\n    /// OTOKEN_FACTORY is the factory contract used to spawn otokens. Used to lookup otokens.\n    address public immutable OTOKEN_FACTORY;\n\n    // The minimum duration for an option auction.\n    uint256 private constant MIN_AUCTION_DURATION = 5 minutes;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event Deposit(address indexed account, uint256 amount, uint256 round);\n\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n\n    event Redeem(address indexed account, uint256 share, uint256 round);\n\n    event ManagementFeeSet(uint256 managementFee, uint256 newManagementFee);\n\n    event PerformanceFeeSet(uint256 performanceFee, uint256 newPerformanceFee);\n\n    event CapSet(uint256 oldCap, uint256 newCap);\n\n    event Withdraw(address indexed account, uint256 amount, uint256 shares);\n\n    event CollectManagementFee(\n        uint256 managementFee,\n        uint256 round,\n        address indexed feeRecipient\n    );\n\n    event CollectPerformanceFee(\n        uint256 performanceFee,\n        uint256 round,\n        address indexed feeRecipient\n    );\n\n    event DistributePremium(\n        uint256 amount,\n        uint256[] amounts,\n        address[] recipients,\n        uint256 round\n    );\n\n    event OpenShort(\n        address indexed options,\n        uint256 depositAmount,\n        address indexed manager\n    );\n\n    event CloseShort(\n        address indexed options,\n        uint256 withdrawAmount,\n        address indexed manager\n    );\n\n    event NewOptionStrikeSelected(uint256 strikePrice, uint256 delta);\n\n    event PremiumDiscountSet(\n        uint256 premiumDiscount,\n        uint256 newPremiumDiscount\n    );\n\n    event AuctionDurationSet(\n        uint256 auctionDuration,\n        uint256 newAuctionDuration\n    );\n\n    event InstantWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n\n    event InitiateGnosisAuction(\n        address indexed auctioningToken,\n        address indexed biddingToken,\n        uint256 auctionCounter,\n        address indexed manager\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _oTokenFactory is the contract address for minting new opyn option types (strikes, asset, expiry)\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _oTokenFactory,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction\n    ) {\n        require(_weth != address(0), \"!_weth\");\n        require(_usdc != address(0), \"!_usdc\");\n        require(_oTokenFactory != address(0), \"!_oTokenFactory\");\n        require(_gammaController != address(0), \"!_gammaController\");\n        require(_marginPool != address(0), \"!_marginPool\");\n        require(_gnosisEasyAuction != address(0), \"!_gnosisEasyAuction\");\n\n        WETH = _weth;\n        USDC = _usdc;\n        OTOKEN_FACTORY = _oTokenFactory;\n        GAMMA_CONTROLLER = _gammaController;\n        MARGIN_POOL = _marginPool;\n        GNOSIS_EASY_AUCTION = _gnosisEasyAuction;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function initialize(\n        VaultLifecycleTreasury.InitParams calldata _initParams,\n        Vault.VaultParams calldata _vaultParams\n    ) external initializer {\n        VaultLifecycleTreasury.verifyInitializerParams(\n            _initParams,\n            _vaultParams,\n            MIN_AUCTION_DURATION\n        );\n\n        __ReentrancyGuard_init();\n        __ERC20_init(_initParams._tokenName, _initParams._tokenSymbol);\n        __Ownable_init();\n        transferOwnership(_initParams._owner);\n\n        keeper = _initParams._keeper;\n        period = _initParams._period;\n        optionsPremiumPricer = _initParams._optionsPremiumPricer;\n        strikeSelection = _initParams._strikeSelection;\n        premiumDiscount = _initParams._premiumDiscount;\n        auctionDuration = _initParams._auctionDuration;\n        feeRecipient = _initParams._feeRecipient;\n        performanceFee = _initParams._performanceFee;\n        managementFee = _perRoundManagementFee(_initParams._managementFee);\n        maxDepositors = _initParams._maxDepositors;\n        minDeposit = _initParams._minDeposit;\n\n        vaultParams = _vaultParams;\n        vaultState.round = 1;\n\n        uint256 assetBalance =\n            IERC20(vaultParams.asset).balanceOf(address(this));\n        ShareMath.assertUint104(assetBalance);\n        vaultState.lastLockedAmount = uint104(assetBalance);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the keeper.\n     */\n    modifier onlyKeeper() {\n        require(msg.sender == keeper, \"!keeper\");\n        _;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new keeper\n     * @param newKeeper is the address of the new keeper\n     */\n    function setNewKeeper(address newKeeper) external onlyOwner {\n        require(newKeeper != address(0), \"!newKeeper\");\n        keeper = newKeeper;\n    }\n\n    /**\n     * @notice Sets the new fee recipient\n     * @param newFeeRecipient is the address of the new fee recipient\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        require(newFeeRecipient != address(0), \"!newFeeRecipient\");\n        require(newFeeRecipient != feeRecipient, \"Must be new feeRecipient\");\n        feeRecipient = newFeeRecipient;\n    }\n\n    /**\n     * @notice Sets the management fee for the vault\n     * @param newManagementFee is the management fee (6 decimals). ex: 2 * 10 ** 6 = 2%\n     */\n    function setManagementFee(uint256 newManagementFee) external onlyOwner {\n        require(\n            newManagementFee < 100 * Vault.FEE_MULTIPLIER,\n            \"Invalid management fee\"\n        );\n\n        managementFee = _perRoundManagementFee(newManagementFee);\n\n        emit ManagementFeeSet(managementFee, newManagementFee);\n    }\n\n    /**\n     * @notice Internal function to set the management fee for the vault\n     * @param managementFee is the management fee (6 decimals). ex: 2 * 10 ** 6 = 2\n     * @return perRoundManagementFee is the management divided by the number of rounds per year\n     */\n    function _perRoundManagementFee(uint256 managementFee)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _period = period;\n        uint256 feeDivider =\n            _period % 30 == 0\n                ? Vault.FEE_MULTIPLIER * (12 / (_period / 30))\n                : WEEKS_PER_YEAR / (_period / 7);\n\n        // We are dividing annualized management fee by num weeks in a year\n        return managementFee.mul(Vault.FEE_MULTIPLIER).div(feeDivider);\n    }\n\n    /**\n     * @notice Sets the performance fee for the vault\n     * @param newPerformanceFee is the performance fee (6 decimals). ex: 20 * 10 ** 6 = 20%\n     */\n    function setPerformanceFee(uint256 newPerformanceFee) external onlyOwner {\n        require(\n            newPerformanceFee < 100 * Vault.FEE_MULTIPLIER,\n            \"Invalid performance fee\"\n        );\n\n        emit PerformanceFeeSet(performanceFee, newPerformanceFee);\n\n        performanceFee = newPerformanceFee;\n    }\n\n    /**\n     * @notice Sets a new cap for deposits\n     * @param newCap is the new cap for deposits\n     */\n    function setCap(uint256 newCap) external onlyOwner {\n        require(newCap > 0, \"!newCap\");\n        ShareMath.assertUint104(newCap);\n        emit CapSet(vaultParams.cap, newCap);\n        vaultParams.cap = uint104(newCap);\n    }\n\n    /**\n     * @notice Sets the new discount on premiums for options we are selling\n     * @param newPremiumDiscount is the premium discount\n     */\n    function setPremiumDiscount(uint256 newPremiumDiscount) external onlyOwner {\n        require(\n            newPremiumDiscount > 0 &&\n                newPremiumDiscount < 100 * Vault.PREMIUM_DISCOUNT_MULTIPLIER,\n            \"Invalid discount\"\n        );\n\n        emit PremiumDiscountSet(premiumDiscount, newPremiumDiscount);\n\n        premiumDiscount = newPremiumDiscount;\n    }\n\n    /**\n     * @notice Sets the new auction duration\n     * @param newAuctionDuration is the auction duration\n     */\n    function setAuctionDuration(uint256 newAuctionDuration) external onlyOwner {\n        require(\n            newAuctionDuration >= MIN_AUCTION_DURATION,\n            \"Invalid auction duration\"\n        );\n\n        emit AuctionDurationSet(auctionDuration, newAuctionDuration);\n\n        auctionDuration = newAuctionDuration;\n    }\n\n    /**\n     * @notice Sets the new strike selection contract\n     * @param newStrikeSelection is the address of the new strike selection contract\n     */\n    function setStrikeSelection(address newStrikeSelection) external onlyOwner {\n        require(newStrikeSelection != address(0), \"!newStrikeSelection\");\n        strikeSelection = newStrikeSelection;\n    }\n\n    /**\n     * @notice Sets the new options premium pricer contract\n     * @param newOptionsPremiumPricer is the address of the new strike selection contract\n     */\n    function setOptionsPremiumPricer(address newOptionsPremiumPricer)\n        external\n        onlyOwner\n    {\n        require(\n            newOptionsPremiumPricer != address(0),\n            \"!newOptionsPremiumPricer\"\n        );\n        optionsPremiumPricer = newOptionsPremiumPricer;\n    }\n\n    /**\n     * @notice Optionality to set strike price manually\n     * @param strikePrice is the strike price of the new oTokens (decimals = 8)\n     */\n    function setStrikePrice(uint128 strikePrice)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        require(strikePrice > 0, \"!strikePrice\");\n        overriddenStrikePrice = strikePrice;\n        lastStrikeOverrideRound = vaultState.round;\n    }\n\n    /**\n     * @notice Set the maximum number of depositors\n     * @param newMaxDepositors is the new cap for number of depositors\n     */\n    function setMaxDepositors(uint256 newMaxDepositors)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        require(newMaxDepositors > 0, \"!newMaxDepositors\");\n        maxDepositors = newMaxDepositors;\n    }\n\n    /**\n     * @notice Set the minimum deposit amount\n     * @param newMinDeposit is the new minimum amount for deposit\n     */\n    function setMinDeposit(uint256 newMinDeposit)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        require(newMinDeposit > 0, \"!newMinDeposit\");\n        minDeposit = newMinDeposit;\n    }\n\n    /************************************************\n     *  DEPOSIT & WITHDRAWALS\n     ***********************************************/\n\n    /**\n     * @notice Internal function to add new depositor address\n     * @param newDepositor is the address to include in the depositors list\n     */\n    function _addDepositor(address newDepositor) internal {\n        if (!depositorsMap[newDepositor]) {\n            require(newDepositor != address(0), \"Depositor address null\");\n            require(\n                (depositorsArray.length + 1) <= maxDepositors,\n                \"Number of depositors exceeds limit\"\n            );\n\n            depositorsMap[newDepositor] = true;\n            depositorsArray.push(newDepositor);\n        }\n    }\n\n    /**\n     * @notice Remove addresses from depositors list\n     * @param excludeDepositor is the address to exclude from the depositors list\n     */\n    function _removeDepositor(address excludeDepositor) internal {\n        address[] storage array = depositorsArray;\n        uint256 arrayLength = array.length;\n\n        require(depositorsMap[excludeDepositor], \"Depositor does not exist\");\n\n        depositorsMap[excludeDepositor] = false;\n\n        for (uint256 i = 0; i < arrayLength - 1; i++) {\n            if (excludeDepositor == array[i]) {\n                (array[i], array[arrayLength - 1]) = (\n                    array[arrayLength - 1],\n                    array[i]\n                );\n            }\n        }\n        array.pop();\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender.\n     * @param amount is the amount of `asset` to deposit\n     */\n    function deposit(uint256 amount) external nonReentrant {\n        require(amount > 0, \"!amount\");\n\n        _addDepositor(msg.sender);\n\n        _depositFor(amount, msg.sender);\n\n        // An approve() by the msg.sender is required beforehand\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Mints the vault shares to the creditor\n     * @param amount is the amount of `asset` deposited\n     * @param creditor is the address to receieve the deposit\n     */\n    function _depositFor(uint256 amount, address creditor) private {\n        uint256 currentRound = vaultState.round;\n        uint256 totalWithDepositedAmount = totalBalance().add(amount);\n\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[creditor];\n        uint256 totalUserDeposit =\n            accountVaultBalance(msg.sender).add(depositReceipt.amount).add(\n                amount\n            );\n\n        require(totalWithDepositedAmount <= vaultParams.cap, \"Exceed cap\");\n        require(\n            totalWithDepositedAmount >= vaultParams.minimumSupply,\n            \"Insufficient balance\"\n        );\n        require(totalUserDeposit >= minDeposit, \"Minimum deposit not reached\");\n\n        emit Deposit(creditor, amount, currentRound);\n\n        // If we have an unprocessed pending deposit from the previous rounds, we have to process it.\n        uint256 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        uint256 depositAmount = amount;\n\n        // If we have a pending deposit in the current round, we add on to the pending deposit\n        if (currentRound == depositReceipt.round) {\n            uint256 newAmount = uint256(depositReceipt.amount).add(amount);\n            depositAmount = newAmount;\n        }\n\n        ShareMath.assertUint104(depositAmount);\n\n        depositReceipts[creditor] = Vault.DepositReceipt({\n            round: uint16(currentRound),\n            amount: uint104(depositAmount),\n            unredeemedShares: uint128(unredeemedShares)\n        });\n\n        uint256 newTotalPending = uint256(vaultState.totalPending).add(amount);\n        ShareMath.assertUint128(newTotalPending);\n\n        vaultState.totalPending = uint128(newTotalPending);\n    }\n\n    /**\n     * @notice Initiates a withdrawal that can be processed once the round completes\n     * @param numShares is the number of shares to withdraw\n     */\n    function initiateWithdraw(uint256 numShares) external nonReentrant {\n        require(numShares > 0, \"!numShares\");\n\n        // We do a max redeem before initiating a withdrawal\n        // But we check if they must first have unredeemed shares\n        if (\n            depositReceipts[msg.sender].amount > 0 ||\n            depositReceipts[msg.sender].unredeemedShares > 0\n        ) {\n            _redeem(0, true);\n        }\n\n        // This caches the `round` variable used in shareBalances\n        uint256 currentRound = vaultState.round;\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n        uint256 withdrawalRound = withdrawal.round;\n\n        bool withdrawalIsSameRound = withdrawalRound == currentRound;\n\n        emit InitiateWithdraw(msg.sender, numShares, currentRound);\n\n        uint256 existingShares = uint256(withdrawal.shares);\n\n        uint256 withdrawalShares;\n        if (withdrawalIsSameRound) {\n            withdrawalShares = existingShares.add(numShares);\n        } else {\n            require(existingShares == 0, \"Existing withdraw\");\n            withdrawalShares = numShares;\n            withdrawals[msg.sender].round = uint16(currentRound);\n        }\n\n        // Ensure withdrawal does not reduce user deposit below the minimum amount\n        uint256 vaultDecimals = vaultParams.decimals;\n        uint256 userBalance = accountVaultBalance(msg.sender);\n\n        uint256 withdrawAmount =\n            ShareMath.sharesToAsset(\n                numShares,\n                currentRound != 1\n                    ? roundPricePerShare[currentRound - 1]\n                    : 10**vaultDecimals,\n                vaultDecimals\n            );\n\n        if (userBalance > withdrawAmount) {\n            uint256 totalDeposit = userBalance.sub(withdrawAmount);\n            require(totalDeposit >= minDeposit, \"Minimum deposit not reached\");\n        }\n\n        ShareMath.assertUint128(withdrawalShares);\n        withdrawals[msg.sender].shares = uint128(withdrawalShares);\n\n        uint256 newQueuedWithdrawShares =\n            uint256(vaultState.queuedWithdrawShares).add(numShares);\n        ShareMath.assertUint128(newQueuedWithdrawShares);\n        vaultState.queuedWithdrawShares = uint128(newQueuedWithdrawShares);\n\n        _transfer(msg.sender, address(this), numShares);\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     * @return withdrawAmount the current withdrawal amount\n     */\n    function _completeWithdraw() internal returns (uint256) {\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        uint256 withdrawalShares = withdrawal.shares;\n        uint256 withdrawalRound = withdrawal.round;\n\n        // This checks if there is a withdrawal\n        require(withdrawalShares > 0, \"Not initiated\");\n\n        require(withdrawalRound < vaultState.round, \"Round not closed\");\n\n        // We leave the round number as non-zero to save on gas for subsequent writes\n        withdrawals[msg.sender].shares = 0;\n        vaultState.queuedWithdrawShares = uint128(\n            uint256(vaultState.queuedWithdrawShares).sub(withdrawalShares)\n        );\n\n        uint256 withdrawAmount =\n            ShareMath.sharesToAsset(\n                withdrawalShares,\n                roundPricePerShare[withdrawalRound],\n                vaultParams.decimals\n            );\n\n        emit Withdraw(msg.sender, withdrawAmount, withdrawalShares);\n\n        _burn(address(this), withdrawalShares);\n\n        require(withdrawAmount > 0, \"!withdrawAmount\");\n        transferAsset(msg.sender, withdrawAmount);\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem\n     */\n    function redeem(uint256 numShares) external nonReentrant {\n        require(numShares > 0, \"!numShares\");\n        _redeem(numShares, false);\n    }\n\n    /**\n     * @notice Redeems the entire unredeemedShares balance that is owed to the account\n     */\n    function maxRedeem() external nonReentrant {\n        _redeem(0, true);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem, could be 0 when isMax=true\n     * @param isMax is flag for when callers do a max redemption\n     */\n    function _redeem(uint256 numShares, bool isMax) internal {\n        Vault.DepositReceipt memory depositReceipt =\n            depositReceipts[msg.sender];\n\n        // This handles the null case when depositReceipt.round = 0\n        // Because we start with round = 1 at `initialize`\n        uint256 currentRound = vaultState.round;\n\n        uint256 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        numShares = isMax ? unredeemedShares : numShares;\n        if (numShares == 0) {\n            return;\n        }\n        require(numShares <= unredeemedShares, \"Exceeds available\");\n\n        // If we have a depositReceipt on the same round, BUT we have some unredeemed shares\n        // we debit from the unredeemedShares, but leave the amount field intact\n        // If the round has past, with no new deposits, we just zero it out for new deposits.\n        if (depositReceipt.round < currentRound) {\n            depositReceipts[msg.sender].amount = 0;\n        }\n\n        ShareMath.assertUint128(numShares);\n        depositReceipts[msg.sender].unredeemedShares = uint128(\n            unredeemedShares.sub(numShares)\n        );\n\n        emit Redeem(msg.sender, numShares, depositReceipt.round);\n\n        _transfer(address(this), msg.sender, numShares);\n    }\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `DepositReceipt.amount`\n     * @param amount is the amount to withdraw\n     */\n    function withdrawInstantly(uint256 amount) external nonReentrant {\n        Vault.DepositReceipt storage depositReceipt =\n            depositReceipts[msg.sender];\n\n        uint256 currentRound = vaultState.round;\n        require(amount > 0, \"!amount\");\n        require(depositReceipt.round == currentRound, \"Invalid round\");\n\n        uint256 receiptAmount = depositReceipt.amount;\n        require(receiptAmount >= amount, \"Exceed amount\");\n\n        uint256 userBalance =\n            accountVaultBalance(msg.sender).add(receiptAmount);\n\n        if (userBalance > amount) {\n            uint256 totalUserDeposit = userBalance.sub(amount);\n            require(\n                totalUserDeposit >= minDeposit,\n                \"Minimum deposit not reached\"\n            );\n        }\n\n        // Subtraction underflow checks already ensure it is smaller than uint104\n        depositReceipt.amount = uint104(receiptAmount.sub(amount));\n        vaultState.totalPending = uint128(\n            uint256(vaultState.totalPending).sub(amount)\n        );\n\n        emit InstantWithdraw(msg.sender, amount, currentRound);\n\n        if (depositReceipt.amount == 0 && shares(msg.sender) == 0) {\n            _removeDepositor(msg.sender);\n        }\n\n        transferAsset(msg.sender, amount);\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     */\n    function completeWithdraw() external nonReentrant {\n        Vault.DepositReceipt storage depositReceipt =\n            depositReceipts[msg.sender];\n\n        uint256 withdrawAmount = _completeWithdraw();\n        lastQueuedWithdrawAmount = uint128(\n            uint256(lastQueuedWithdrawAmount).sub(withdrawAmount)\n        );\n\n        if (depositReceipt.amount == 0 && shares(msg.sender) == 0) {\n            _removeDepositor(msg.sender);\n        }\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /*\n     * @notice Helper function that helps to save gas for writing values into the roundPricePerShare map.\n     *         Writing `1` into the map makes subsequent writes warm, reducing the gas from 20k to 5k.\n     *         Having 1 initialized beforehand will not be an issue as long as we round down share calculations to 0.\n     * @param numRounds is the number of rounds to initialize in the map\n     */\n    function initRounds(uint256 numRounds) external nonReentrant {\n        require(numRounds > 0, \"!numRounds\");\n\n        uint256 _round = vaultState.round;\n        for (uint256 i = 0; i < numRounds; i++) {\n            uint256 index = _round + i;\n            require(roundPricePerShare[index] == 0, \"Initialized\"); // AVOID OVERWRITING ACTUAL VALUES\n            roundPricePerShare[index] = ShareMath.PLACEHOLDER_UINT;\n        }\n    }\n\n    /*\n     * @notice Helper function that performs most administrative tasks\n     * such as setting next option, minting new shares, getting vault fees, etc.\n     * @param lastQueuedWithdrawAmount is old queued withdraw amount\n     * @return newOption is the new option address\n     * @return lockedBalance is the new balance used to calculate next option purchase size or collateral size\n     * @return queuedWithdrawAmount is the new queued withdraw amount for this round\n     */\n    function _rollToNextOption(uint256 lastQueuedWithdrawAmount)\n        internal\n        returns (\n            address newOption,\n            uint256 lockedBalance,\n            uint256 queuedWithdrawAmount\n        )\n    {\n        require(block.timestamp >= optionState.nextOptionReadyAt, \"!ready\");\n\n        newOption = optionState.nextOption;\n        require(newOption != address(0), \"!nextOption\");\n\n        uint256 currentRound = vaultState.round;\n        address recipient = feeRecipient;\n        uint256 mintShares;\n        uint256 managementFeeInAsset;\n        {\n            uint256 newPricePerShare;\n            (\n                lockedBalance,\n                queuedWithdrawAmount,\n                newPricePerShare,\n                mintShares,\n                managementFeeInAsset\n            ) = VaultLifecycleTreasury.rollover(\n                vaultState,\n                VaultLifecycleTreasury.RolloverParams(\n                    vaultParams.decimals,\n                    IERC20(vaultParams.asset).balanceOf(address(this)),\n                    totalSupply(),\n                    lastQueuedWithdrawAmount,\n                    currentRound != 1 ? managementFee : 0\n                )\n            );\n\n            optionState.currentOption = newOption;\n            optionState.nextOption = address(0);\n\n            // Finalize the pricePerShare at the end of the round\n\n            roundPricePerShare[currentRound] = newPricePerShare;\n\n            emit CollectManagementFee(\n                managementFeeInAsset,\n                currentRound,\n                recipient\n            );\n\n            vaultState.totalPending = 0;\n            vaultState.round = uint16(currentRound + 1);\n        }\n\n        _mint(address(this), mintShares);\n\n        if (managementFeeInAsset > 0) {\n            transferAsset(payable(recipient), managementFeeInAsset);\n        }\n\n        return (newOption, lockedBalance, queuedWithdrawAmount);\n    }\n\n    /**\n     * @notice Helper function to make an ERC20 transfer\n     * @param recipient is the receiving address\n     * @param amount is the transfer amount\n     */\n    function transferAsset(address recipient, uint256 amount) internal {\n        address asset = vaultParams.asset;\n        IERC20(asset).safeTransfer(recipient, amount);\n    }\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and closes the existing short.\n     *         This allows all the users to withdraw if the next option is malicious.\n     */\n    function commitAndClose() external nonReentrant {\n        address oldOption = optionState.currentOption;\n\n        VaultLifecycleTreasury.CloseParams memory closeParams =\n            VaultLifecycleTreasury.CloseParams({\n                OTOKEN_FACTORY: OTOKEN_FACTORY,\n                USDC: USDC,\n                currentOption: oldOption,\n                delay: DELAY,\n                lastStrikeOverrideRound: lastStrikeOverrideRound,\n                overriddenStrikePrice: overriddenStrikePrice,\n                period: period\n            });\n\n        (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        ) =\n            VaultLifecycleTreasury.commitAndClose(\n                strikeSelection,\n                optionsPremiumPricer,\n                premiumDiscount,\n                closeParams,\n                vaultParams,\n                vaultState\n            );\n\n        emit NewOptionStrikeSelected(strikePrice, delta);\n\n        ShareMath.assertUint104(premium);\n        currentOtokenPremium = uint104(premium);\n        optionState.nextOption = otokenAddress;\n\n        uint256 nextOptionReady = block.timestamp.add(DELAY);\n        require(\n            nextOptionReady <= type(uint32).max,\n            \"Overflow nextOptionReady\"\n        );\n        optionState.nextOptionReadyAt = uint32(nextOptionReady);\n\n        _closeShort(oldOption);\n\n        // In case chargeAndDistribute was not called last round, call\n        // the function to conclude last round's performance fee and distribution\n        if (IERC20(USDC).balanceOf(address(this)) > 0) {\n            _chargeAndDistribute();\n        }\n    }\n\n    /**\n     * @notice Closes the existing short position for the vault.\n     */\n    function _closeShort(address oldOption) private {\n        uint256 lockedAmount = vaultState.lockedAmount;\n        if (oldOption != address(0)) {\n            vaultState.lastLockedAmount = uint104(lockedAmount);\n        }\n        vaultState.lockedAmount = 0;\n\n        optionState.currentOption = address(0);\n\n        if (oldOption != address(0)) {\n            uint256 withdrawAmount =\n                VaultLifecycleTreasury.settleShort(GAMMA_CONTROLLER);\n            emit CloseShort(oldOption, withdrawAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Rolls the vault's funds into a new short position.\n     */\n    function rollToNextOption() external onlyKeeper nonReentrant {\n        (\n            address newOption,\n            uint256 lockedBalance,\n            uint256 queuedWithdrawAmount\n        ) = _rollToNextOption(uint256(lastQueuedWithdrawAmount));\n\n        lastQueuedWithdrawAmount = queuedWithdrawAmount;\n\n        ShareMath.assertUint104(lockedBalance);\n        vaultState.lockedAmount = uint104(lockedBalance);\n\n        emit OpenShort(newOption, lockedBalance, msg.sender);\n\n        VaultLifecycleTreasury.createShort(\n            GAMMA_CONTROLLER,\n            MARGIN_POOL,\n            newOption,\n            lockedBalance\n        );\n\n        _startAuction();\n    }\n\n    /**\n     * @notice Initiate the gnosis auction.\n     */\n    function startAuction() external onlyKeeper nonReentrant {\n        _startAuction();\n    }\n\n    function _startAuction() private {\n        GnosisAuction.AuctionDetails memory auctionDetails;\n\n        uint256 currOtokenPremium = currentOtokenPremium;\n\n        require(currOtokenPremium > 0, \"!currentOtokenPremium\");\n\n        uint256 stableDecimals = IERC20Detailed(USDC).decimals();\n\n        auctionDetails.oTokenAddress = optionState.currentOption;\n        auctionDetails.gnosisEasyAuction = GNOSIS_EASY_AUCTION;\n        auctionDetails.asset = USDC;\n        auctionDetails.assetDecimals = stableDecimals;\n        auctionDetails.oTokenPremium = currOtokenPremium;\n        auctionDetails.duration = auctionDuration;\n\n        optionAuctionID = VaultLifecycleTreasury.startAuction(auctionDetails);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from gnosis auction.\n     */\n    function burnRemainingOTokens() external onlyKeeper nonReentrant {\n        uint256 unlockedAssetAmount =\n            VaultLifecycleTreasury.burnOtokens(\n                GAMMA_CONTROLLER,\n                optionState.currentOption\n            );\n\n        vaultState.lockedAmount = uint104(\n            uint256(vaultState.lockedAmount).sub(unlockedAssetAmount)\n        );\n    }\n\n    /**\n     * @notice Settles the round's Gnosis auction and distribute the premiums earned\n     */\n    function concludeOptionsSale() external onlyKeeper nonReentrant {\n        VaultLifecycleTreasury.settleAuction(\n            GNOSIS_EASY_AUCTION,\n            optionAuctionID\n        );\n\n        if (IERC20(USDC).balanceOf(address(this)) > 0) {\n            _chargeAndDistribute();\n        }\n    }\n\n    /**\n     * @notice Charge performance fee and distribute remaining to depositors addresses\n     */\n    function chargeAndDistribute() external onlyKeeper nonReentrant {\n        _chargeAndDistribute();\n    }\n\n    /**\n     * @notice Calculate performance fee and transfer to fee recipient\n     */\n    function _chargeAndDistribute() internal {\n        IERC20 stableAsset = IERC20(USDC);\n        uint256 stableBalance = stableAsset.balanceOf(address(this));\n\n        require(stableBalance > 0, \"no premium to distribute\");\n\n        _chargePerformanceFee(stableAsset, stableBalance);\n\n        _distributePremium(\n            stableAsset,\n            stableAsset.balanceOf(address(this)) // Get the new balance\n        );\n    }\n\n    /**\n     * @notice Charge performance fee\n     */\n    function _chargePerformanceFee(IERC20 token, uint256 amount) internal {\n        address recipient = feeRecipient;\n        uint256 transferAmount =\n            amount.mul(performanceFee).div(100 * Vault.FEE_MULTIPLIER);\n\n        token.safeTransfer(recipient, transferAmount);\n\n        // Performance fee for the round is charged after rollover\n        // hence we need to adjust the round to the previous\n        emit CollectPerformanceFee(\n            transferAmount,\n            vaultState.round - 1,\n            recipient\n        );\n    }\n\n    /**\n     * @notice Distribute the premium to depositor addresses\n     */\n    function _distributePremium(IERC20 token, uint256 amount) internal {\n        // Distribute to depositor address\n        address[] storage _depositors = depositorsArray;\n        uint256[] memory _amounts = new uint256[](_depositors.length);\n        uint256 totalSupply = totalSupply();\n\n        for (uint256 i = 0; i < _depositors.length; i++) {\n            // Distribute to depositors proportional to the amount of\n            // shares they own\n            address depositorAddress = _depositors[i];\n            _amounts[i] = shares(depositorAddress).mul(amount).div(totalSupply);\n\n            token.safeTransfer(depositorAddress, _amounts[i]);\n        }\n\n        emit DistributePremium(\n            amount,\n            _amounts,\n            _depositors,\n            vaultState.round - 1\n        );\n    }\n\n    /************************************************\n     *  GETTERS\n     ***********************************************/\n\n    /**\n     * @notice Returns the asset balance held on the vault for the account\n     * @param account is the address to lookup balance for\n     * @return the amount of `asset` custodied by the vault for the user\n     */\n    function accountVaultBalance(address account)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 _decimals = vaultParams.decimals;\n        uint256 assetPerShare =\n            ShareMath.pricePerShare(\n                totalSupply(),\n                totalBalance(),\n                vaultState.totalPending,\n                _decimals\n            );\n        return\n            ShareMath.sharesToAsset(shares(account), assetPerShare, _decimals);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance including unredeemed shares\n     * @param account is the account to lookup share balance for\n     * @return the share balance\n     */\n    function shares(address account) public view returns (uint256) {\n        (uint256 heldByAccount, uint256 heldByVault) = shareBalances(account);\n        return heldByAccount.add(heldByVault);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance split between account and vault holdings\n     * @param account is the account to lookup share balance for\n     * @return heldByAccount is the shares held by account\n     * @return heldByVault is the shares held on the vault (unredeemedShares)\n     */\n    function shareBalances(address account)\n        public\n        view\n        returns (uint256 heldByAccount, uint256 heldByVault)\n    {\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[account];\n\n        if (depositReceipt.round < ShareMath.PLACEHOLDER_UINT) {\n            return (balanceOf(account), 0);\n        }\n\n        uint256 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                vaultState.round,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        return (balanceOf(account), unredeemedShares);\n    }\n\n    /**\n     * @notice The price of a unit of share denominated in the `asset`\n     */\n    function pricePerShare() external view returns (uint256) {\n        return\n            ShareMath.pricePerShare(\n                totalSupply(),\n                totalBalance(),\n                vaultState.totalPending,\n                vaultParams.decimals\n            );\n    }\n\n    /**\n     * @notice Returns the vault's total balance, including the amounts locked into a short position\n     * @return total balance of the vault, including the amounts locked in third party protocols\n     */\n    function totalBalance() public view returns (uint256) {\n        return\n            uint256(vaultState.lockedAmount).add(\n                IERC20(vaultParams.asset).balanceOf(address(this))\n            );\n    }\n\n    /**\n     * @notice Returns the token decimals\n     */\n    function decimals() public view override returns (uint8) {\n        return vaultParams.decimals;\n    }\n\n    /**\n     * @notice Returns the maximum capacity of the vault in terms of the vault's asset\n     */\n    function cap() external view returns (uint256) {\n        return vaultParams.cap;\n    }\n\n    /**\n     * @notice Returns the date and time for the next options sale\n     */\n    function nextOptionReadyAt() external view returns (uint256) {\n        return optionState.nextOptionReadyAt;\n    }\n\n    /**\n     * @notice Returns the options specification for the current round\n     */\n    function currentOption() external view returns (address) {\n        return optionState.currentOption;\n    }\n\n    /**\n     * @notice Returns the options specification for the next round\n     */\n    function nextOption() external view returns (address) {\n        return optionState.nextOption;\n    }\n\n    /**\n     * @notice Returns total pending deposit for the current round\n     */\n    function totalPending() external view returns (uint256) {\n        return vaultState.totalPending;\n    }\n}\n"
    },
    "contracts/libraries/VaultLifecycleTreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Vault} from \"./Vault.sol\";\nimport {ShareMath} from \"./ShareMath.sol\";\nimport {IStrikeSelection} from \"../interfaces/IRibbon.sol\";\nimport {GnosisAuction} from \"./GnosisAuction.sol\";\nimport {DateTime} from \"./DateTime.sol\";\nimport {\n    IOtokenFactory,\n    IOtoken,\n    IController,\n    GammaTypes\n} from \"../interfaces/GammaInterface.sol\";\nimport {IERC20Detailed} from \"../interfaces/IERC20Detailed.sol\";\nimport {IGnosisAuction} from \"../interfaces/IGnosisAuction.sol\";\nimport {SupportsNonCompliantERC20} from \"./SupportsNonCompliantERC20.sol\";\n\nlibrary VaultLifecycleTreasury {\n    using SafeMath for uint256;\n    using SupportsNonCompliantERC20 for IERC20;\n\n    struct CloseParams {\n        address OTOKEN_FACTORY;\n        address USDC;\n        address currentOption;\n        uint256 delay;\n        uint16 lastStrikeOverrideRound;\n        uint256 overriddenStrikePrice;\n        uint256 period;\n    }\n\n    /**\n     * @notice Initialization parameters for the vault.\n     * @param _owner is the owner of the vault with critical permissions\n     * @param _feeRecipient is the address to recieve vault performance and management fees\n     * @param _managementFee is the management fee pct.\n     * @param _performanceFee is the perfomance fee pct.\n     * @param _tokenName is the name of the token\n     * @param _tokenSymbol is the symbol of the token\n     * @param _optionsPremiumPricer is the address of the contract with the\n       black-scholes premium calculation logic\n     * @param _strikeSelection is the address of the contract with strike selection logic\n     * @param _premiumDiscount is the vault's discount applied to the premium\n     * @param _auctionDuration is the duration of the gnosis auction\n     * @param _period is the period between each option sales\n     */\n    struct InitParams {\n        address _owner;\n        address _keeper;\n        address _feeRecipient;\n        uint256 _managementFee;\n        uint256 _performanceFee;\n        string _tokenName;\n        string _tokenSymbol;\n        address _optionsPremiumPricer;\n        address _strikeSelection;\n        uint32 _premiumDiscount;\n        uint256 _auctionDuration;\n        uint256 _period;\n        uint256 _maxDepositors;\n        uint256 _minDeposit;\n    }\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and calculates its premium for the auction\n     * @param strikeSelection is the address of the contract with strike selection logic\n     * @param optionsPremiumPricer is the address of the contract with the\n       black-scholes premium calculation logic\n     * @param premiumDiscount is the vault's discount applied to the premium\n     * @param closeParams is the struct with details on previous option and strike selection details\n     * @param vaultParams is the struct with vault general data\n     * @param vaultState is the struct with vault accounting state\n     * @return otokenAddress is the address of the new option\n     * @return premium is the premium of the new option\n     * @return strikePrice is the strike price of the new option\n     * @return delta is the delta of the new option\n     */\n    function commitAndClose(\n        address strikeSelection,\n        address optionsPremiumPricer,\n        uint256 premiumDiscount,\n        CloseParams calldata closeParams,\n        Vault.VaultParams storage vaultParams,\n        Vault.VaultState storage vaultState\n    )\n        external\n        returns (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        )\n    {\n        uint256 expiry;\n\n        // uninitialized state\n        if (closeParams.currentOption == address(0)) {\n            expiry = getNextExpiry(block.timestamp, closeParams.period);\n        } else {\n            expiry = getNextExpiry(\n                IOtoken(closeParams.currentOption).expiryTimestamp(),\n                closeParams.period\n            );\n        }\n\n        IStrikeSelection selection = IStrikeSelection(strikeSelection);\n\n        bool isPut = vaultParams.isPut;\n        address underlying = vaultParams.underlying;\n        address asset = vaultParams.asset;\n\n        (strikePrice, delta) = closeParams.lastStrikeOverrideRound ==\n            vaultState.round\n            ? (closeParams.overriddenStrikePrice, 0)\n            : selection.getStrikePrice(expiry, isPut);\n\n        require(strikePrice != 0, \"!strikePrice\");\n\n        // retrieve address if option already exists, or deploy it\n        otokenAddress = getOrDeployOtoken(\n            closeParams,\n            vaultParams,\n            underlying,\n            asset,\n            strikePrice,\n            expiry,\n            isPut\n        );\n\n        // get the black scholes premium of the option\n        premium = GnosisAuction.getOTokenPremiumInStables(\n            otokenAddress,\n            optionsPremiumPricer,\n            premiumDiscount\n        );\n\n        require(premium > 0, \"!premium\");\n\n        return (otokenAddress, premium, strikePrice, delta);\n    }\n\n    /**\n     * @notice Verify the otoken has the correct parameters to prevent vulnerability to opyn contract changes\n     * @param otokenAddress is the address of the otoken\n     * @param vaultParams is the struct with vault general data\n     * @param collateralAsset is the address of the collateral asset\n     * @param USDC is the address of usdc\n     * @param delay is the delay between commitAndClose and rollToNextOption\n     */\n    function verifyOtoken(\n        address otokenAddress,\n        Vault.VaultParams storage vaultParams,\n        address collateralAsset,\n        address USDC,\n        uint256 delay\n    ) private view {\n        require(otokenAddress != address(0), \"!otokenAddress\");\n\n        IOtoken otoken = IOtoken(otokenAddress);\n        require(otoken.isPut() == vaultParams.isPut, \"Type mismatch\");\n        require(\n            otoken.underlyingAsset() == vaultParams.underlying,\n            \"Wrong underlyingAsset\"\n        );\n        require(\n            otoken.collateralAsset() == collateralAsset,\n            \"Wrong collateralAsset\"\n        );\n\n        // we just assume all options use USDC as the strike\n        require(otoken.strikeAsset() == USDC, \"strikeAsset != USDC\");\n\n        uint256 readyAt = block.timestamp.add(delay);\n        require(otoken.expiryTimestamp() >= readyAt, \"Expiry before delay\");\n    }\n\n    /**\n     * @param currentShareSupply is the supply of the shares invoked with totalSupply()\n     * @param asset is the address of the vault's asset\n     * @param decimals is the decimals of the asset\n     * @param lastQueuedWithdrawAmount is the amount queued for withdrawals from last round\n     * @param managementFee is the management fee percent to charge on the AUM\n     */\n    struct RolloverParams {\n        uint256 decimals;\n        uint256 totalBalance;\n        uint256 currentShareSupply;\n        uint256 lastQueuedWithdrawAmount;\n        uint256 managementFee;\n    }\n\n    /**\n     * @notice Calculate the shares to mint, new price per share, and\n      amount of funds to re-allocate as collateral for the new round\n     * @param vaultState is the storage variable vaultState passed from RibbonVault\n     * @param params is the rollover parameters passed to compute the next state\n     * @return newLockedAmount is the amount of funds to allocate for the new round\n     * @return queuedWithdrawAmount is the amount of funds set aside for withdrawal\n     * @return newPricePerShare is the price per share of the new round\n     * @return mintShares is the amount of shares to mint from deposits\n     * @return managementFeeInAsset is the amount of management fee charged by vault\n     */\n    function rollover(\n        Vault.VaultState storage vaultState,\n        RolloverParams calldata params\n    )\n        external\n        view\n        returns (\n            uint256 newLockedAmount,\n            uint256 queuedWithdrawAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares,\n            uint256 managementFeeInAsset\n        )\n    {\n        uint256 currentBalance = params.totalBalance;\n        uint256 pendingAmount = vaultState.totalPending;\n        uint256 queuedWithdrawShares = vaultState.queuedWithdrawShares;\n\n        uint256 balanceForVaultFees;\n        {\n            uint256 pricePerShareBeforeFee =\n                ShareMath.pricePerShare(\n                    params.currentShareSupply,\n                    currentBalance,\n                    pendingAmount,\n                    params.decimals\n                );\n\n            uint256 queuedWithdrawBeforeFee =\n                params.currentShareSupply > 0\n                    ? ShareMath.sharesToAsset(\n                        queuedWithdrawShares,\n                        pricePerShareBeforeFee,\n                        params.decimals\n                    )\n                    : 0;\n\n            // Deduct the difference between the newly scheduled withdrawals\n            // and the older withdrawals\n            // so we can charge them fees before they leave\n            uint256 withdrawAmountDiff =\n                queuedWithdrawBeforeFee > params.lastQueuedWithdrawAmount\n                    ? queuedWithdrawBeforeFee.sub(\n                        params.lastQueuedWithdrawAmount\n                    )\n                    : 0;\n\n            balanceForVaultFees = currentBalance\n                .sub(queuedWithdrawBeforeFee)\n                .add(withdrawAmountDiff);\n        }\n\n        managementFeeInAsset = getManagementFee(\n            balanceForVaultFees,\n            vaultState.totalPending,\n            params.managementFee\n        );\n\n        // Take into account the fee\n        // so we can calculate the newPricePerShare\n        currentBalance = currentBalance.sub(managementFeeInAsset);\n\n        {\n            newPricePerShare = ShareMath.pricePerShare(\n                params.currentShareSupply,\n                currentBalance,\n                pendingAmount,\n                params.decimals\n            );\n\n            // After closing the short, if the options expire in-the-money\n            // vault pricePerShare would go down because vault's asset balance decreased.\n            // This ensures that the newly-minted shares do not take on the loss.\n            mintShares = ShareMath.assetToShares(\n                pendingAmount,\n                newPricePerShare,\n                params.decimals\n            );\n\n            uint256 newSupply = params.currentShareSupply.add(mintShares);\n\n            queuedWithdrawAmount = newSupply > 0\n                ? ShareMath.sharesToAsset(\n                    queuedWithdrawShares,\n                    newPricePerShare,\n                    params.decimals\n                )\n                : 0;\n        }\n\n        return (\n            currentBalance.sub(queuedWithdrawAmount), // new locked balance subtracts the queued withdrawals\n            queuedWithdrawAmount,\n            newPricePerShare,\n            mintShares,\n            managementFeeInAsset\n        );\n    }\n\n    /**\n     * @notice Creates the actual Opyn short position by depositing collateral and minting otokens\n     * @param gammaController is the address of the opyn controller contract\n     * @param marginPool is the address of the opyn margin contract which holds the collateral\n     * @param oTokenAddress is the address of the otoken to mint\n     * @param depositAmount is the amount of collateral to deposit\n     * @return the otoken mint amount\n     */\n    function createShort(\n        address gammaController,\n        address marginPool,\n        address oTokenAddress,\n        uint256 depositAmount\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n        uint256 newVaultID =\n            (controller.getAccountVaultCounter(address(this))).add(1);\n\n        // An otoken's collateralAsset is the vault's `asset`\n        // So in the context of performing Opyn short operations we call them collateralAsset\n        IOtoken oToken = IOtoken(oTokenAddress);\n        address collateralAsset = oToken.collateralAsset();\n\n        uint256 collateralDecimals =\n            uint256(IERC20Detailed(collateralAsset).decimals());\n        uint256 mintAmount;\n\n        if (oToken.isPut()) {\n            // For minting puts, there will be instances where the full depositAmount will not be used for minting.\n            // This is because of an issue with precision.\n            //\n            // For ETH put options, we are calculating the mintAmount (10**8 decimals) using\n            // the depositAmount (10**18 decimals), which will result in truncation of decimals when scaling down.\n            // As a result, there will be tiny amounts of dust left behind in the Opyn vault when minting put otokens.\n            //\n            // For simplicity's sake, we do not refund the dust back to the address(this) on minting otokens.\n            // We retain the dust in the vault so the calling contract can withdraw the\n            // actual locked amount + dust at settlement.\n            //\n            // To test this behavior, we can console.log\n            // MarginCalculatorInterface(0x7A48d10f372b3D7c60f6c9770B91398e4ccfd3C7).getExcessCollateral(vault)\n            // to see how much dust (or excess collateral) is left behind.\n            mintAmount = depositAmount\n                .mul(10**Vault.OTOKEN_DECIMALS)\n                .mul(10**18) // we use 10**18 to give extra precision\n                .div(oToken.strikePrice().mul(10**(10 + collateralDecimals)));\n        } else {\n            mintAmount = depositAmount;\n\n            if (collateralDecimals > 8) {\n                uint256 scaleBy = 10**(collateralDecimals.sub(8)); // oTokens have 8 decimals\n                if (mintAmount > scaleBy) {\n                    mintAmount = depositAmount.div(scaleBy); // scale down from 10**18 to 10**8\n                }\n            }\n        }\n\n        // double approve to fix non-compliant ERC20s\n        IERC20 collateralToken = IERC20(collateralAsset);\n        collateralToken.safeApproveNonCompliant(marginPool, depositAmount);\n\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](3);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.OpenVault,\n            address(this), // owner\n            address(this), // receiver\n            address(0), // asset, otoken\n            newVaultID, // vaultId\n            0, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.DepositCollateral,\n            address(this), // owner\n            address(this), // address to transfer from\n            collateralAsset, // deposited asset\n            newVaultID, // vaultId\n            depositAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[2] = IController.ActionArgs(\n            IController.ActionType.MintShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            oTokenAddress, // option address\n            newVaultID, // vaultId\n            mintAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        return mintAmount;\n    }\n\n    /**\n     * @notice Close the existing short otoken position. Currently this implementation is simple.\n     * It closes the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time. Since calling `_closeShort` deletes vaults by\n     calling SettleVault action, this assumption should hold.\n     * @param gammaController is the address of the opyn controller contract\n     * @return amount of collateral redeemed from the vault\n     */\n    function settleShort(address gammaController) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault =\n            controller.getVault(address(this), vaultID);\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        // An otoken's collateralAsset is the vault's `asset`\n        // So in the context of performing Opyn short operations we call them collateralAsset\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        // The short position has been previously closed, or all the otokens have been burned.\n        // So we return early.\n        if (address(collateralToken) == address(0)) {\n            return 0;\n        }\n\n        // This is equivalent to doing IERC20(vault.asset).balanceOf(address(this))\n        uint256 startCollateralBalance =\n            collateralToken.balanceOf(address(this));\n\n        // If it is after expiry, we need to settle the short position using the normal way\n        // Delete the vault and withdraw all remaining collateral from the vault\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](1);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.SettleVault,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(0), // not used\n            vaultID, // vaultId\n            0, // not used\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance.sub(startCollateralBalance);\n    }\n\n    /**\n     * @notice Exercises the ITM option using existing long otoken position. Currently this implementation is simple.\n     * It calls the `Redeem` action to claim the payout.\n     * @param gammaController is the address of the opyn controller contract\n     * @param oldOption is the address of the old option\n     * @param asset is the address of the vault's asset\n     * @return amount of asset received by exercising the option\n     */\n    function settleLong(\n        address gammaController,\n        address oldOption,\n        address asset\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n\n        uint256 oldOptionBalance = IERC20(oldOption).balanceOf(address(this));\n\n        if (controller.getPayout(oldOption, oldOptionBalance) == 0) {\n            return 0;\n        }\n\n        uint256 startAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        // If it is after expiry, we need to redeem the profits\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](1);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.Redeem,\n            address(0), // not used\n            address(this), // address to send profits to\n            oldOption, // address of otoken\n            0, // not used\n            oldOptionBalance, // otoken balance\n            0, // not used\n            \"\" // not used\n        );\n\n        controller.operate(actions);\n\n        uint256 endAssetBalance = IERC20(asset).balanceOf(address(this));\n\n        return endAssetBalance.sub(startAssetBalance);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from auction. Currently this implementation is simple.\n     * It burns oTokens from the most recent vault opened by the contract. This assumes that the contract will\n     * only have a single vault open at any given time.\n     * @param gammaController is the address of the opyn controller contract\n     * @param currentOption is the address of the current option\n     * @return amount of collateral redeemed by burning otokens\n     */\n    function burnOtokens(address gammaController, address currentOption)\n        external\n        returns (uint256)\n    {\n        uint256 numOTokensToBurn =\n            IERC20(currentOption).balanceOf(address(this));\n\n        require(numOTokensToBurn > 0, \"No oTokens to burn\");\n\n        IController controller = IController(gammaController);\n\n        // gets the currently active vault ID\n        uint256 vaultID = controller.getAccountVaultCounter(address(this));\n\n        GammaTypes.Vault memory vault =\n            controller.getVault(address(this), vaultID);\n\n        require(vault.shortOtokens.length > 0, \"No short\");\n\n        IERC20 collateralToken = IERC20(vault.collateralAssets[0]);\n\n        uint256 startCollateralBalance =\n            collateralToken.balanceOf(address(this));\n\n        // Burning `amount` of oTokens from the ribbon vault,\n        // then withdrawing the corresponding collateral amount from the vault\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](2);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.BurnShortOption,\n            address(this), // owner\n            address(this), // address to transfer from\n            address(vault.shortOtokens[0]), // otoken address\n            vaultID, // vaultId\n            numOTokensToBurn, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.WithdrawCollateral,\n            address(this), // owner\n            address(this), // address to transfer to\n            address(collateralToken), // withdrawn asset\n            vaultID, // vaultId\n            vault.collateralAmounts[0].mul(numOTokensToBurn).div(\n                vault.shortAmounts[0]\n            ), // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        uint256 endCollateralBalance = collateralToken.balanceOf(address(this));\n\n        return endCollateralBalance.sub(startCollateralBalance);\n    }\n\n    /**\n     * @notice Calculates the management fee for this week's round\n     * @param currentBalance is the balance of funds held on the vault after closing short\n     * @param pendingAmount is the pending deposit amount\n     * @param managementFeePercent is the management fee pct.\n     * @return managementFeeInAsset is the management fee\n     */\n    function getManagementFee(\n        uint256 currentBalance,\n        uint256 pendingAmount,\n        uint256 managementFeePercent\n    ) internal pure returns (uint256 managementFeeInAsset) {\n        // At the first round, currentBalance=0, pendingAmount>0\n        // so we just do not charge anything on the first round\n        uint256 lockedBalanceSansPending =\n            currentBalance > pendingAmount\n                ? currentBalance.sub(pendingAmount)\n                : 0;\n\n        uint256 _managementFeeInAsset;\n\n        // Always charge management fee regardless of whether the vault is\n        // making a profit from the previous options sale\n        _managementFeeInAsset = managementFeePercent > 0\n            ? lockedBalanceSansPending.mul(managementFeePercent).div(\n                100 * Vault.FEE_MULTIPLIER\n            )\n            : 0;\n\n        return _managementFeeInAsset;\n    }\n\n    /**\n     * @notice Either retrieves the option token if it already exists, or deploy it\n     * @param closeParams is the struct with details on previous option and strike selection details\n     * @param vaultParams is the struct with vault general data\n     * @param underlying is the address of the underlying asset of the option\n     * @param collateralAsset is the address of the collateral asset of the option\n     * @param strikePrice is the strike price of the option\n     * @param expiry is the expiry timestamp of the option\n     * @param isPut is whether the option is a put\n     * @return the address of the option\n     */\n    function getOrDeployOtoken(\n        CloseParams calldata closeParams,\n        Vault.VaultParams storage vaultParams,\n        address underlying,\n        address collateralAsset,\n        uint256 strikePrice,\n        uint256 expiry,\n        bool isPut\n    ) internal returns (address) {\n        IOtokenFactory factory = IOtokenFactory(closeParams.OTOKEN_FACTORY);\n\n        address otokenFromFactory =\n            factory.getOtoken(\n                underlying,\n                closeParams.USDC,\n                collateralAsset,\n                strikePrice,\n                expiry,\n                isPut\n            );\n\n        if (otokenFromFactory != address(0)) {\n            return otokenFromFactory;\n        }\n\n        address otoken =\n            factory.createOtoken(\n                underlying,\n                closeParams.USDC,\n                collateralAsset,\n                strikePrice,\n                expiry,\n                isPut\n            );\n\n        verifyOtoken(\n            otoken,\n            vaultParams,\n            collateralAsset,\n            closeParams.USDC,\n            closeParams.delay\n        );\n\n        return otoken;\n    }\n\n    /**\n     * @notice Starts the gnosis auction\n     * @param auctionDetails is the struct with all the custom parameters of the auction\n     * @return the auction id of the newly created auction\n     */\n    function startAuction(GnosisAuction.AuctionDetails calldata auctionDetails)\n        external\n        returns (uint256)\n    {\n        return GnosisAuction.startAuction(auctionDetails);\n    }\n\n    /**\n     * @notice Settles the gnosis auction\n     * @param gnosisEasyAuction is the contract address of Gnosis easy auction protocol\n     * @param auctionID is the auction ID of the gnosis easy auction\n     */\n    function settleAuction(address gnosisEasyAuction, uint256 auctionID)\n        internal\n    {\n        IGnosisAuction(gnosisEasyAuction).settleAuction(auctionID);\n    }\n\n    /**\n     * @notice Places a bid in an auction\n     * @param bidDetails is the struct with all the details of the\n      bid including the auction's id and how much to bid\n     */\n    function placeBid(GnosisAuction.BidDetails calldata bidDetails)\n        external\n        returns (\n            uint256 sellAmount,\n            uint256 buyAmount,\n            uint64 userId\n        )\n    {\n        return GnosisAuction.placeBid(bidDetails);\n    }\n\n    /**\n     * @notice Claims the oTokens belonging to the vault\n     * @param auctionSellOrder is the sell order of the bid\n     * @param gnosisEasyAuction is the address of the gnosis auction contract\n     holding custody to the funds\n     * @param counterpartyThetaVault is the address of the counterparty theta\n     vault of this delta vault\n     */\n    function claimAuctionOtokens(\n        Vault.AuctionSellOrder calldata auctionSellOrder,\n        address gnosisEasyAuction,\n        address counterpartyThetaVault\n    ) external {\n        GnosisAuction.claimAuctionOtokens(\n            auctionSellOrder,\n            gnosisEasyAuction,\n            counterpartyThetaVault\n        );\n    }\n\n    /**\n     * @notice Verify the constructor params satisfy requirements\n     * @param _initParams is the initialization parameter including owner, keeper, etc.\n     * @param _vaultParams is the struct with vault general data\n     */\n    function verifyInitializerParams(\n        InitParams calldata _initParams,\n        Vault.VaultParams calldata _vaultParams,\n        uint256 _min_auction_duration\n    ) external pure {\n        require(_initParams._owner != address(0), \"!_owner\");\n        require(_initParams._keeper != address(0), \"!_keeper\");\n        require(_initParams._feeRecipient != address(0), \"!_feeRecipient\");\n        require(\n            _initParams._performanceFee < 100 * Vault.FEE_MULTIPLIER,\n            \"performanceFee >= 100%\"\n        );\n        require(\n            _initParams._managementFee < 100 * Vault.FEE_MULTIPLIER,\n            \"managementFee >= 100%\"\n        );\n        require(bytes(_initParams._tokenName).length > 0, \"!_tokenName\");\n        require(bytes(_initParams._tokenSymbol).length > 0, \"!_tokenSymbol\");\n        require(\n            (_initParams._period == 7) ||\n                (_initParams._period == 14) ||\n                (_initParams._period == 30) ||\n                (_initParams._period == 90) ||\n                (_initParams._period == 180),\n            \"!_period\"\n        );\n        require(\n            _initParams._optionsPremiumPricer != address(0),\n            \"!_optionsPremiumPricer\"\n        );\n        require(\n            _initParams._strikeSelection != address(0),\n            \"!_strikeSelection\"\n        );\n        require(\n            _initParams._premiumDiscount > 0 &&\n                _initParams._premiumDiscount <\n                100 * Vault.PREMIUM_DISCOUNT_MULTIPLIER,\n            \"!_premiumDiscount\"\n        );\n        require(\n            _initParams._auctionDuration >= _min_auction_duration,\n            \"!_auctionDuration\"\n        );\n        require(_initParams._maxDepositors > 0, \"!_maxDepositors\");\n        require(_initParams._minDeposit > 0, \"!_minDeposit\");\n\n        require(_vaultParams.asset != address(0), \"!asset\");\n        require(_vaultParams.underlying != address(0), \"!underlying\");\n        require(_vaultParams.minimumSupply > 0, \"!minimumSupply\");\n        require(_vaultParams.cap > 0, \"!cap\");\n        require(\n            _vaultParams.cap > _vaultParams.minimumSupply,\n            \"cap has to be higher than minimumSupply\"\n        );\n    }\n\n    /**\n     * @notice Gets the next options expiry timestamp, this function should be called\n     when there is sufficient guard to ensure valid period\n     * @param timestamp is the expiry timestamp of the current option\n     * @param period is no. of days in between option sales. Available periods are: \n     * 7(1w), 14(2w), 30(1m), 90(3m), 180(6m)\n     */\n    function getNextExpiry(uint256 timestamp, uint256 period)\n        internal\n        pure\n        returns (uint256 nextExpiry)\n    {\n        if (period == 7) {\n            nextExpiry = DateTime.getNextFriday(timestamp);\n            nextExpiry = nextExpiry <= timestamp\n                ? nextExpiry + 1 weeks\n                : nextExpiry;\n        } else if (period == 14) {\n            nextExpiry = DateTime.getNextFriday(timestamp);\n            nextExpiry = nextExpiry <= timestamp\n                ? nextExpiry + 2 weeks\n                : nextExpiry;\n        } else if (period == 30) {\n            nextExpiry = DateTime.getMonthLastFriday(timestamp);\n            nextExpiry = nextExpiry <= timestamp\n                ? DateTime.getMonthLastFriday(nextExpiry + 1 weeks)\n                : nextExpiry;\n        } else if (period == 90) {\n            nextExpiry = DateTime.getQuarterLastFriday(timestamp);\n            nextExpiry = nextExpiry <= timestamp\n                ? DateTime.getQuarterLastFriday(nextExpiry + 1 weeks)\n                : nextExpiry;\n        } else if (period == 180) {\n            nextExpiry = DateTime.getBiannualLastFriday(timestamp);\n            nextExpiry = nextExpiry <= timestamp\n                ? DateTime.getBiannualLastFriday(nextExpiry + 1 weeks)\n                : nextExpiry;\n        }\n\n        nextExpiry = nextExpiry - (nextExpiry % (24 hours)) + (8 hours);\n    }\n}\n"
    },
    "contracts/storage/RibbonTreasuryVaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {Vault} from \"../libraries/Vault.sol\";\n\nabstract contract RibbonTreasuryVaultStorageV1 {\n    /// @notice Vault's parameters like cap, decimals\n    Vault.VaultParams public vaultParams;\n\n    /// @notice Vault's lifecycle state like round and locked amounts\n    Vault.VaultState public vaultState;\n\n    /// @notice Vault's state of the options sold and the timelocked option\n    Vault.OptionState public optionState;\n\n    /// @notice Stores the user's pending deposit for the round\n    mapping(address => Vault.DepositReceipt) public depositReceipts;\n\n    /// @notice On every round's close, the pricePerShare value of an rTHETA token is stored\n    /// This is used to determine the number of shares to be returned\n    /// to a user with their DepositReceipt.depositAmount\n    mapping(uint256 => uint256) public roundPricePerShare;\n\n    /// @notice Stores pending user withdrawals\n    mapping(address => Vault.Withdrawal) public withdrawals;\n\n    /// @notice Mapping of depositors in the vault\n    mapping(address => bool) public depositorsMap;\n\n    /// @notice Array of depositors in the vault\n    address[] public depositorsArray;\n\n    /// @notice Fee recipient for the performance and management fees\n    address public feeRecipient;\n\n    /// @notice role in charge of weekly vault operations such as rollToNextOption and burnRemainingOTokens\n    // no access to critical vault changes\n    address public keeper;\n\n    /// @notice Logic contract used to price options\n    address public optionsPremiumPricer;\n\n    /// @notice Logic contract used to select strike prices\n    address public strikeSelection;\n\n    /// @notice Performance fee charged on premiums earned in rollToNextOption. Only charged when there is no loss.\n    uint256 public performanceFee;\n\n    /// @notice Management fee charged on entire AUM in rollToNextOption. Only charged when there is no loss.\n    uint256 public managementFee;\n\n    /// @notice Premium discount on options we are selling (thousandths place: 000 - 999)\n    uint256 public premiumDiscount;\n\n    /// @notice Current oToken premium\n    uint256 public currentOtokenPremium;\n\n    /// @notice Price last overridden strike set to\n    uint256 public overriddenStrikePrice;\n\n    /// @notice Auction duration\n    uint256 public auctionDuration;\n\n    /// @notice Auction id of current option\n    uint256 public optionAuctionID;\n\n    /// @notice Amount locked for scheduled withdrawals last week;\n    uint256 public lastQueuedWithdrawAmount;\n\n    /// @notice Period between each options sale.\n    /// Available options 7 (weekly), 14 (biweekly), 30 (monthly), 90 (quarterly), 180 (biannually)\n    uint256 public period;\n\n    /// @notice Maximum number of depositors\n    uint256 public maxDepositors;\n\n    /// @notice Minimum amount to deposit\n    uint256 public minDeposit;\n\n    /// @notice Last round id at which the strike was manually overridden\n    uint16 public lastStrikeOverrideRound;\n}\n\n// We are following Compound's method of upgrading new contract implementations\n// When we need to add new storage variables, we create a new version of RibbonTreasuryVaultStorage\n// e.g. RibbonTreasuryVaultStorage<versionNumber>, so finally it would look like\n// contract RibbonTreasuryVaultStorage is RibbonTreasuryVaultStorageV1, RibbonTreasuryVaultStorageV2\nabstract contract RibbonTreasuryVaultStorage is RibbonTreasuryVaultStorageV1 {\n\n}\n"
    },
    "contracts/libraries/DateTime.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Source: https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\n// ----------------------------------------------------------------------------\n// BokkyPooBah's DateTime Library v1.01\n// ----------------------------------------------------------------------------\n\npragma solidity =0.8.4;\n\nlibrary DateTime {\n    uint256 constant SECONDS_PER_DAY = 24 * 60 * 60;\n    uint256 constant SECONDS_PER_HOUR = 60 * 60;\n    uint256 constant SECONDS_PER_MINUTE = 60;\n    int256 constant OFFSET19700101 = 2440588;\n\n    uint256 constant DOW_MON = 1;\n    uint256 constant DOW_TUE = 2;\n    uint256 constant DOW_WED = 3;\n    uint256 constant DOW_THU = 4;\n    uint256 constant DOW_FRI = 5;\n    uint256 constant DOW_SAT = 6;\n    uint256 constant DOW_SUN = 7;\n\n    // ------------------------------------------------------------------------\n    // Calculate the number of days from 1970/01/01 to year/month/day using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // days = day\n    //      - 32075\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\n    //      - offset\n    // ------------------------------------------------------------------------\n    function _daysFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 _days) {\n        require(year >= 1970);\n        int256 _year = int256(year);\n        int256 _month = int256(month);\n        int256 _day = int256(day);\n\n        int256 __days =\n            _day -\n                32075 +\n                (1461 * (_year + 4800 + (_month - 14) / 12)) /\n                4 +\n                (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\n                12 -\n                (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\n                4 -\n                OFFSET19700101;\n\n        _days = uint256(__days);\n    }\n\n    // ------------------------------------------------------------------------\n    // Calculate year/month/day from the number of days since 1970/01/01 using\n    // the date conversion algorithm from\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\n    //\n    // int L = days + 68569 + offset\n    // int N = 4 * L / 146097\n    // L = L - (146097 * N + 3) / 4\n    // year = 4000 * (L + 1) / 1461001\n    // L = L - 1461 * year / 4 + 31\n    // month = 80 * L / 2447\n    // dd = L - 2447 * month / 80\n    // L = month / 11\n    // month = month + 2 - 12 * L\n    // year = 100 * (N - 49) + year + L\n    // ------------------------------------------------------------------------\n    function _daysToDate(uint256 _days)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day\n        )\n    {\n        int256 __days = int256(_days);\n\n        int256 L = __days + 68569 + OFFSET19700101;\n        int256 N = (4 * L) / 146097;\n        L = L - (146097 * N + 3) / 4;\n        int256 _year = (4000 * (L + 1)) / 1461001;\n        L = L - (1461 * _year) / 4 + 31;\n        int256 _month = (80 * L) / 2447;\n        int256 _day = L - (2447 * _month) / 80;\n        L = _month / 11;\n        _month = _month + 2 - 12 * L;\n        _year = 100 * (N - 49) + _year + L;\n\n        year = uint256(_year);\n        month = uint256(_month);\n        day = uint256(_day);\n    }\n\n    function isLeapYear(uint256 timestamp)\n        internal\n        pure\n        returns (bool leapYear)\n    {\n        (uint256 year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n        leapYear = _isLeapYear(year);\n    }\n\n    function _isLeapYear(uint256 year) internal pure returns (bool leapYear) {\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\n    }\n\n    function getDaysInMonth(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 daysInMonth)\n    {\n        (uint256 year, uint256 month, ) =\n            _daysToDate(timestamp / SECONDS_PER_DAY);\n        daysInMonth = _getDaysInMonth(year, month);\n    }\n\n    function _getDaysInMonth(uint256 year, uint256 month)\n        internal\n        pure\n        returns (uint256 daysInMonth)\n    {\n        if (\n            month == 1 ||\n            month == 3 ||\n            month == 5 ||\n            month == 7 ||\n            month == 8 ||\n            month == 10 ||\n            month == 12\n        ) {\n            daysInMonth = 31;\n        } else if (month != 2) {\n            daysInMonth = 30;\n        } else {\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\n        }\n    }\n\n    // 1 = Monday, 7 = Sunday\n    function getDayOfWeek(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 dayOfWeek)\n    {\n        uint256 _days = timestamp / SECONDS_PER_DAY;\n        dayOfWeek = ((_days + 3) % 7) + 1;\n    }\n\n    function getYear(uint256 timestamp) internal pure returns (uint256 year) {\n        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getMonth(uint256 timestamp) internal pure returns (uint256 month) {\n        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function getDay(uint256 timestamp) internal pure returns (uint256 day) {\n        (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\n    }\n\n    function timestampFromDate(\n        uint256 year,\n        uint256 month,\n        uint256 day\n    ) internal pure returns (uint256 timestamp) {\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\n    }\n\n    /**\n     * @notice Gets the Friday of the same week\n     * @param timestamp is the given date and time\n     * @return the Friday of the same week in unix time\n     */\n    function getThisWeekFriday(uint256 timestamp)\n        internal\n        pure\n        returns (uint256)\n    {\n        return timestamp + 5 days - getDayOfWeek(timestamp) * 1 days;\n    }\n\n    /**\n     * @notice Gets the next friday after the given date and time\n     * @param timestamp is the given date and time\n     * @return the next friday after the given date and time\n     */\n    function getNextFriday(uint256 timestamp) internal pure returns (uint256) {\n        uint256 friday = getThisWeekFriday(timestamp);\n        return friday >= timestamp ? friday : friday + 1 weeks;\n    }\n\n    /**\n     * @notice Gets the last day of the month\n     * @param timestamp is the given date and time\n     * @return the last day of the same month in unix time\n     */\n    function getLastDayOfMonth(uint256 timestamp)\n        internal\n        pure\n        returns (uint256)\n    {\n        return\n            timestampFromDate(getYear(timestamp), getMonth(timestamp) + 1, 1) -\n            1 days;\n    }\n\n    /**\n     * @notice Gets the last Friday of the month\n     * @param timestamp is the given date and time\n     * @return the last Friday of the same month in unix time\n     */\n    function getMonthLastFriday(uint256 timestamp)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 lastDay = getLastDayOfMonth(timestamp);\n        uint256 friday = getThisWeekFriday(lastDay);\n\n        return friday > lastDay ? friday - 1 weeks : friday;\n    }\n\n    /**\n     * @notice Gets the last Friday of the quarter\n     * @param timestamp is the given date and time\n     * @return the last Friday of the quarter in unix time\n     */\n    function getQuarterLastFriday(uint256 timestamp)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 month = getMonth(timestamp);\n        uint256 quarterMonth =\n            (month <= 3) ? 3 : (month <= 6) ? 6 : (month <= 9) ? 9 : 12;\n\n        uint256 quarterDate =\n            timestampFromDate(getYear(timestamp), quarterMonth, 1);\n\n        return getMonthLastFriday(quarterDate);\n    }\n\n    /**\n     * @notice Gets the last Friday of the half-year\n     * @param timestamp is the given date and time\n     * @return the last friday of the half-year\n     */\n    function getBiannualLastFriday(uint256 timestamp)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 month = getMonth(timestamp);\n        uint256 biannualMonth = (month <= 6) ? 6 : 12;\n\n        uint256 biannualDate =\n            timestampFromDate(getYear(timestamp), biannualMonth, 1);\n\n        return getMonthLastFriday(biannualDate);\n    }\n}\n"
    },
    "contracts/tests/TestVaultLifecycleTreasury.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {VaultLifecycleTreasury} from \"../libraries/VaultLifecycleTreasury.sol\";\n\ncontract TestVaultLifecycleTreasury {\n    function getNextExpiry(uint256 currentExpiry, uint256 interval)\n        external\n        pure\n        returns (uint256)\n    {\n        return VaultLifecycleTreasury.getNextExpiry(currentExpiry, interval);\n    }\n}\n"
    },
    "contracts/vaults/STETHVault/RibbonThetaSTETHVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {GnosisAuction} from \"../../libraries/GnosisAuction.sol\";\nimport {Vault} from \"../../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../../libraries/VaultLifecycle.sol\";\nimport {VaultLifecycleSTETH} from \"../../libraries/VaultLifecycleSTETH.sol\";\nimport {ShareMath} from \"../../libraries/ShareMath.sol\";\nimport {RibbonVault} from \"./base/RibbonVault.sol\";\nimport {\n    RibbonThetaSTETHVaultStorage\n} from \"../../storage/RibbonThetaSTETHVaultStorage.sol\";\n\n/**\n * UPGRADEABILITY: Since we use the upgradeable proxy pattern, we must observe\n * the inheritance chain closely.\n * Any changes/appends in storage variable needs to happen in RibbonThetaSTETHVaultStorage.\n * RibbonThetaSTETHVault should not inherit from any other contract aside from RibbonVault, RibbonThetaSTETHVaultStorage\n */\ncontract RibbonThetaSTETHVault is RibbonVault, RibbonThetaSTETHVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    /// @notice is the factory contract used to spawn otokens. Used to lookup otokens.\n    address public immutable OTOKEN_FACTORY;\n\n    // The minimum duration for an option auction.\n    uint256 private constant MIN_AUCTION_DURATION = 5 minutes;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event OpenShort(\n        address indexed options,\n        uint256 depositAmount,\n        address indexed manager\n    );\n\n    event CloseShort(\n        address indexed options,\n        uint256 withdrawAmount,\n        address indexed manager\n    );\n\n    event NewOptionStrikeSelected(uint256 strikePrice, uint256 delta);\n\n    event PremiumDiscountSet(\n        uint256 premiumDiscount,\n        uint256 newPremiumDiscount\n    );\n\n    event AuctionDurationSet(\n        uint256 auctionDuration,\n        uint256 newAuctionDuration\n    );\n\n    event InstantWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n\n    event InitiateGnosisAuction(\n        address indexed auctioningToken,\n        address indexed biddingToken,\n        uint256 auctionCounter,\n        address indexed manager\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _wsteth is the LDO contract\n     * @param _ldo is the LDO contract\n     * @param _oTokenFactory is the contract address for minting new opyn option types (strikes, asset, expiry)\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     * @param _crvPool is the steth/eth crv stables pool\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _wsteth,\n        address _ldo,\n        address _oTokenFactory,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction,\n        address _crvPool\n    )\n        RibbonVault(\n            _weth,\n            _usdc,\n            _wsteth,\n            _ldo,\n            _gammaController,\n            _marginPool,\n            _gnosisEasyAuction,\n            _crvPool\n        )\n    {\n        require(_oTokenFactory != address(0), \"!_oTokenFactory\");\n        OTOKEN_FACTORY = _oTokenFactory;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     * @param _owner is the owner of the vault with critical permissions\n     * @param _keeper is the keeper of the vault with medium permissions (weekly actions)\n     * @param _feeRecipient is the address to recieve vault performance and management fees\n     * @param _managementFee is the management fee pct.\n     * @param _performanceFee is the perfomance fee pct.\n     * @param _tokenName is the name of the token\n     * @param _tokenSymbol is the symbol of the token\n     * @param _optionsPremiumPricer is the address of the contract with the\n       black-scholes premium calculation logic\n     * @param _strikeSelection is the address of the contract with strike selection logic\n     * @param _premiumDiscount is the vault's discount applied to the premium\n     * @param _auctionDuration is the duration of the gnosis auction\n     * @param _vaultParams is the struct with vault general data\n     */\n    function initialize(\n        address _owner,\n        address _keeper,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        address _optionsPremiumPricer,\n        address _strikeSelection,\n        uint32 _premiumDiscount,\n        uint256 _auctionDuration,\n        Vault.VaultParams calldata _vaultParams\n    ) external initializer {\n        baseInitialize(\n            _owner,\n            _keeper,\n            _feeRecipient,\n            _managementFee,\n            _performanceFee,\n            _tokenName,\n            _tokenSymbol,\n            _vaultParams\n        );\n        require(_optionsPremiumPricer != address(0), \"!_optionsPremiumPricer\");\n        require(_strikeSelection != address(0), \"!_strikeSelection\");\n        require(\n            _premiumDiscount > 0 &&\n                _premiumDiscount < 100 * Vault.PREMIUM_DISCOUNT_MULTIPLIER,\n            \"!_premiumDiscount\"\n        );\n        require(_auctionDuration >= MIN_AUCTION_DURATION, \"!_auctionDuration\");\n        optionsPremiumPricer = _optionsPremiumPricer;\n        strikeSelection = _strikeSelection;\n        premiumDiscount = _premiumDiscount;\n        auctionDuration = _auctionDuration;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new discount on premiums for options we are selling\n     * @param newPremiumDiscount is the premium discount\n     */\n    function setPremiumDiscount(uint256 newPremiumDiscount) external onlyOwner {\n        require(\n            newPremiumDiscount > 0 &&\n                newPremiumDiscount < 100 * Vault.PREMIUM_DISCOUNT_MULTIPLIER,\n            \"Invalid discount\"\n        );\n\n        emit PremiumDiscountSet(premiumDiscount, newPremiumDiscount);\n        premiumDiscount = newPremiumDiscount;\n    }\n\n    /**\n     * @notice Sets the new auction duration\n     * @param newAuctionDuration is the auction duration\n     */\n    function setAuctionDuration(uint256 newAuctionDuration) external onlyOwner {\n        require(\n            newAuctionDuration >= MIN_AUCTION_DURATION,\n            \"Invalid auction duration\"\n        );\n        emit AuctionDurationSet(auctionDuration, newAuctionDuration);\n        auctionDuration = newAuctionDuration;\n    }\n\n    /**\n     * @notice Sets the new strike selection or options premium pricer contract\n     * @param newContract is the address of the new strike selection or options premium pricer contract\n     * @param isStrikeSelection is whether we are setting the strike selection contract\n     */\n    function setStrikeSelectionOrPricer(\n        address newContract,\n        bool isStrikeSelection\n    ) external onlyOwner {\n        require(newContract != address(0), \"!newContract\");\n        if (isStrikeSelection) {\n            strikeSelection = newContract;\n        } else {\n            optionsPremiumPricer = newContract;\n        }\n    }\n\n    /**\n     * @notice Optionality to set strike price manually\n     * @param strikePrice is the strike price of the new oTokens (decimals = 8)\n     */\n    function setStrikePrice(uint128 strikePrice)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        require(strikePrice > 0, \"!strikePrice\");\n        overriddenStrikePrice = strikePrice;\n        lastStrikeOverrideRound = vaultState.round;\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `DepositReceipt.amount`\n     * @param amount is the amount to withdraw in `asset`\n     * @param minETHOut is the min amount of `asset` to recieve for the swapped amount of steth in crv pool\n     */\n    function withdrawInstantly(uint256 amount, uint256 minETHOut)\n        external\n        nonReentrant\n    {\n        Vault.DepositReceipt storage depositReceipt =\n            depositReceipts[msg.sender];\n\n        uint256 currentRound = vaultState.round;\n\n        require(amount > 0, \"!amount\");\n        require(depositReceipt.round == currentRound, \"Invalid round\");\n\n        uint256 receiptAmount = depositReceipt.amount;\n        require(receiptAmount >= amount, \"Exceed amount\");\n\n        // Subtraction underflow checks already ensure it is smaller than uint104\n        depositReceipt.amount = uint104(receiptAmount.sub(amount));\n        vaultState.totalPending = uint128(\n            uint256(vaultState.totalPending).sub(amount)\n        );\n\n        emit InstantWithdraw(msg.sender, amount, currentRound);\n\n        // Unwrap may incur curve pool slippage\n        uint256 amountETHOut =\n            VaultLifecycleSTETH.unwrapYieldToken(\n                amount,\n                address(collateralToken),\n                STETH,\n                STETH_ETH_CRV_POOL,\n                minETHOut\n            );\n\n        VaultLifecycleSTETH.transferAsset(msg.sender, amountETHOut);\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     * @param minETHOut is the min amount of `asset` to recieve for the swapped amount of steth in crv pool\n     */\n    function completeWithdraw(uint256 minETHOut) external nonReentrant {\n        uint256 withdrawAmount = _completeWithdraw(minETHOut);\n        lastQueuedWithdrawAmount = uint128(\n            uint256(lastQueuedWithdrawAmount).sub(withdrawAmount)\n        );\n    }\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and closes the existing short.\n     *         This allows all the users to withdraw if the next option is malicious.\n     */\n    function commitAndClose() external nonReentrant {\n        address oldOption = optionState.currentOption;\n\n        VaultLifecycle.CloseParams memory closeParams =\n            VaultLifecycle.CloseParams({\n                OTOKEN_FACTORY: OTOKEN_FACTORY,\n                USDC: USDC,\n                currentOption: oldOption,\n                delay: DELAY,\n                lastStrikeOverrideRound: lastStrikeOverrideRound,\n                overriddenStrikePrice: overriddenStrikePrice\n            });\n\n        (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        ) =\n            VaultLifecycleSTETH.commitAndClose(\n                strikeSelection,\n                optionsPremiumPricer,\n                premiumDiscount,\n                closeParams,\n                vaultParams,\n                vaultState,\n                address(collateralToken)\n            );\n\n        emit NewOptionStrikeSelected(strikePrice, delta);\n\n        ShareMath.assertUint104(premium);\n\n        currentOtokenPremium = uint104(premium);\n        optionState.nextOption = otokenAddress;\n        uint256 nextOptionReady = block.timestamp.add(DELAY);\n        require(\n            nextOptionReady <= type(uint32).max,\n            \"Overflow nextOptionReady\"\n        );\n        optionState.nextOptionReadyAt = uint32(nextOptionReady);\n\n        _closeShort(oldOption);\n    }\n\n    /**\n     * @notice Closes the existing short position for the vault.\n     */\n    function _closeShort(address oldOption) private {\n        uint256 lockedAmount = vaultState.lockedAmount;\n        if (oldOption != address(0)) {\n            vaultState.lastLockedAmount = uint104(lockedAmount);\n        }\n        vaultState.lockedAmount = 0;\n\n        optionState.currentOption = address(0);\n\n        if (oldOption != address(0)) {\n            uint256 withdrawAmount =\n                VaultLifecycle.settleShort(GAMMA_CONTROLLER);\n            emit CloseShort(oldOption, withdrawAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Rolls the vault's funds into a new short position.\n     */\n    function rollToNextOption() external onlyKeeper nonReentrant {\n        (address newOption, uint256 queuedWithdrawAmount) =\n            _rollToNextOption(uint256(lastQueuedWithdrawAmount));\n\n        lastQueuedWithdrawAmount = queuedWithdrawAmount;\n\n        // Locked balance denominated in `collateralToken`\n        uint256 lockedBalance =\n            collateralToken.balanceOf(address(this)).sub(\n                collateralToken.getWstETHByStETH(queuedWithdrawAmount)\n            );\n\n        emit OpenShort(newOption, lockedBalance, msg.sender);\n\n        VaultLifecycleSTETH.createShort(\n            GAMMA_CONTROLLER,\n            MARGIN_POOL,\n            newOption,\n            lockedBalance\n        );\n\n        _startAuction();\n    }\n\n    /**\n     * @notice Initiate the gnosis auction.\n     */\n    function startAuction() external onlyKeeper nonReentrant {\n        _startAuction();\n    }\n\n    function _startAuction() private {\n        GnosisAuction.AuctionDetails memory auctionDetails;\n\n        uint256 currOtokenPremium = currentOtokenPremium;\n\n        require(currOtokenPremium > 0, \"!currentOtokenPremium\");\n\n        auctionDetails.oTokenAddress = optionState.currentOption;\n        auctionDetails.gnosisEasyAuction = GNOSIS_EASY_AUCTION;\n        auctionDetails.asset = vaultParams.asset;\n        auctionDetails.assetDecimals = vaultParams.decimals;\n        auctionDetails.oTokenPremium = currOtokenPremium;\n        auctionDetails.duration = auctionDuration;\n\n        optionAuctionID = VaultLifecycle.startAuction(auctionDetails);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from gnosis auction.\n     */\n    function burnRemainingOTokens() external onlyKeeper nonReentrant {\n        uint256 unlockedAssetAmount =\n            VaultLifecycle.burnOtokens(\n                GAMMA_CONTROLLER,\n                optionState.currentOption\n            );\n\n        vaultState.lockedAmount = uint104(\n            uint256(vaultState.lockedAmount).sub(\n                collateralToken.getStETHByWstETH(unlockedAssetAmount)\n            )\n        );\n\n        // Wrap entire `asset` balance to `collateralToken` balance\n        VaultLifecycleSTETH.wrapToYieldToken(\n            WETH,\n            address(collateralToken),\n            STETH\n        );\n    }\n}\n"
    },
    "contracts/libraries/VaultLifecycleSTETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {DSMath} from \"../vendor/DSMath.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {VaultLifecycle} from \"./VaultLifecycle.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Vault} from \"./Vault.sol\";\nimport {ShareMath} from \"./ShareMath.sol\";\nimport {ISTETH, IWSTETH} from \"../interfaces/ISTETH.sol\";\nimport {IWETH} from \"../interfaces/IWETH.sol\";\nimport {ICRV} from \"../interfaces/ICRV.sol\";\nimport {IStrikeSelection} from \"../interfaces/IRibbon.sol\";\nimport {GnosisAuction} from \"./GnosisAuction.sol\";\nimport {\n    IOtokenFactory,\n    IOtoken,\n    IController,\n    GammaTypes\n} from \"../interfaces/GammaInterface.sol\";\nimport {IERC20Detailed} from \"../interfaces/IERC20Detailed.sol\";\n\nlibrary VaultLifecycleSTETH {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and calculates its premium for the auction\n     * @param strikeSelection is the address of the contract with strike selection logic\n     * @param optionsPremiumPricer is the address of the contract with the\n       black-scholes premium calculation logic\n     * @param premiumDiscount is the vault's discount applied to the premium\n     * @param closeParams is the struct with details on previous option and strike selection details\n     * @param vaultParams is the struct with vault general data\n     * @param vaultState is the struct with vault accounting state\n     * @param collateralAsset is the address of the collateral asset\n     * @return otokenAddress is the address of the new option\n     * @return premium is the premium of the new option\n     * @return strikePrice is the strike price of the new option\n     * @return delta is the delta of the new option\n     */\n    function commitAndClose(\n        address strikeSelection,\n        address optionsPremiumPricer,\n        uint256 premiumDiscount,\n        VaultLifecycle.CloseParams calldata closeParams,\n        Vault.VaultParams storage vaultParams,\n        Vault.VaultState storage vaultState,\n        address collateralAsset\n    )\n        external\n        returns (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        )\n    {\n        uint256 expiry =\n            VaultLifecycle.getNextExpiry(closeParams.currentOption);\n\n        IStrikeSelection selection = IStrikeSelection(strikeSelection);\n\n        // calculate strike and delta\n        (strikePrice, delta) = closeParams.lastStrikeOverrideRound ==\n            vaultState.round\n            ? (closeParams.overriddenStrikePrice, selection.delta())\n            : selection.getStrikePrice(expiry, false);\n\n        require(strikePrice != 0, \"!strikePrice\");\n\n        // retrieve address if option already exists, or deploy it\n        otokenAddress = VaultLifecycle.getOrDeployOtoken(\n            closeParams,\n            vaultParams,\n            vaultParams.underlying,\n            collateralAsset,\n            strikePrice,\n            expiry,\n            false\n        );\n\n        // get the black scholes premium of the option and adjust premium based on\n        // steth <-> eth exchange rate\n        premium = DSMath.wmul(\n            GnosisAuction.getOTokenPremium(\n                otokenAddress,\n                optionsPremiumPricer,\n                premiumDiscount\n            ),\n            IWSTETH(collateralAsset).stEthPerToken()\n        );\n\n        require(premium > 0, \"!premium\");\n\n        return (otokenAddress, premium, strikePrice, delta);\n    }\n\n    /**\n     * @notice Calculate the shares to mint, new price per share, and\n      amount of funds to re-allocate as collateral for the new round\n     * @param currentShareSupply is the total supply of shares\n     * @param currentBalance is the total balance of the vault\n     * @param vaultParams is the struct with vault general data\n     * @param vaultState is the struct with vault accounting state\n     * @return newLockedAmount is the amount of funds to allocate for the new round\n     * @return queuedWithdrawAmount is the amount of funds set aside for withdrawal\n     * @return newPricePerShare is the price per share of the new round\n     * @return mintShares is the amount of shares to mint from deposits\n     */\n    function rollover(\n        uint256 currentShareSupply,\n        uint256 currentBalance,\n        Vault.VaultParams calldata vaultParams,\n        Vault.VaultState calldata vaultState\n    )\n        external\n        pure\n        returns (\n            uint256 newLockedAmount,\n            uint256 queuedWithdrawAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares\n        )\n    {\n        uint256 pendingAmount = uint256(vaultState.totalPending);\n        uint256 _decimals = vaultParams.decimals;\n\n        newPricePerShare = ShareMath.pricePerShare(\n            currentShareSupply,\n            currentBalance,\n            pendingAmount,\n            _decimals\n        );\n\n        // After closing the short, if the options expire in-the-money\n        // vault pricePerShare would go down because vault's asset balance decreased.\n        // This ensures that the newly-minted shares do not take on the loss.\n        uint256 _mintShares =\n            ShareMath.assetToShares(pendingAmount, newPricePerShare, _decimals);\n\n        uint256 newSupply = currentShareSupply.add(_mintShares);\n        uint256 queuedAmount =\n            newSupply > 0\n                ? ShareMath.sharesToAsset(\n                    vaultState.queuedWithdrawShares,\n                    newPricePerShare,\n                    _decimals\n                )\n                : 0;\n\n        return (\n            currentBalance.sub(queuedAmount),\n            queuedAmount,\n            newPricePerShare,\n            _mintShares\n        );\n    }\n\n    /**\n     * @notice Creates the actual Opyn short position by depositing collateral and minting otokens\n     * @param gammaController is the address of the opyn controller contract\n     * @param marginPool is the address of the opyn margin contract which holds the collateral\n     * @param oTokenAddress is the address of the otoken to mint\n     * @param depositAmount is the amount of collateral to deposit\n     * @return the otoken mint amount\n     */\n    function createShort(\n        address gammaController,\n        address marginPool,\n        address oTokenAddress,\n        uint256 depositAmount\n    ) external returns (uint256) {\n        IController controller = IController(gammaController);\n        uint256 newVaultID =\n            (controller.getAccountVaultCounter(address(this))).add(1);\n\n        // An otoken's collateralAsset is the vault's `asset`\n        // So in the context of performing Opyn short operations we call them collateralAsset\n        IOtoken oToken = IOtoken(oTokenAddress);\n        address collateralAsset = oToken.collateralAsset();\n\n        uint256 collateralDecimals =\n            uint256(IERC20Detailed(collateralAsset).decimals());\n        uint256 mintAmount;\n\n        mintAmount = depositAmount;\n        if (collateralDecimals > 8) {\n            uint256 scaleBy = 10**(collateralDecimals.sub(8)); // oTokens have 8 decimals\n            if (mintAmount > scaleBy) {\n                mintAmount = depositAmount.div(scaleBy); // scale down from 10**18 to 10**8\n            }\n        }\n\n        IERC20 collateralToken = IERC20(collateralAsset);\n        collateralToken.safeApprove(marginPool, depositAmount);\n\n        IController.ActionArgs[] memory actions =\n            new IController.ActionArgs[](3);\n\n        actions[0] = IController.ActionArgs(\n            IController.ActionType.OpenVault,\n            address(this), // owner\n            address(this), // receiver\n            address(0), // asset, otoken\n            newVaultID, // vaultId\n            0, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[1] = IController.ActionArgs(\n            IController.ActionType.DepositCollateral,\n            address(this), // owner\n            address(this), // address to transfer from\n            collateralAsset, // deposited asset\n            newVaultID, // vaultId\n            depositAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        actions[2] = IController.ActionArgs(\n            IController.ActionType.MintShortOption,\n            address(this), // owner\n            address(this), // address to transfer to\n            oTokenAddress, // option address\n            newVaultID, // vaultId\n            mintAmount, // amount\n            0, //index\n            \"\" //data\n        );\n\n        controller.operate(actions);\n\n        return mintAmount;\n    }\n\n    /**\n     * @notice Withdraws stETH + WETH (if necessary) from vault using vault shares\n     * @param collateralToken is the address of the collateral token\n     * @param weth is the WETH address\n     * @param recipient is the recipient\n     * @param amount is the withdraw amount in `asset`\n     * @return withdrawAmount is the withdraw amount in `collateralToken`\n     */\n    function withdrawYieldAndBaseToken(\n        address collateralToken,\n        address weth,\n        address recipient,\n        uint256 amount\n    ) external returns (uint256) {\n        IWSTETH collateral = IWSTETH(collateralToken);\n\n        uint256 withdrawAmount = collateral.getWstETHByStETH(amount);\n\n        uint256 yieldTokenBalance =\n            withdrawYieldToken(collateralToken, recipient, withdrawAmount);\n\n        // If there is not enough wstETH in the vault, it withdraws as much as possible and\n        // transfers the rest in `asset`\n        if (withdrawAmount > yieldTokenBalance) {\n            withdrawBaseToken(\n                collateralToken,\n                weth,\n                recipient,\n                withdrawAmount,\n                yieldTokenBalance\n            );\n        }\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @notice Withdraws stETH from vault\n     * @param collateralToken is the address of the collateral token\n     * @param recipient is the recipient\n     * @param withdrawAmount is the withdraw amount in terms of yearn tokens\n     * @return yieldTokenBalance is the balance of the yield token\n     */\n    function withdrawYieldToken(\n        address collateralToken,\n        address recipient,\n        uint256 withdrawAmount\n    ) internal returns (uint256) {\n        IERC20 collateral = IERC20(collateralToken);\n\n        uint256 yieldTokenBalance = collateral.balanceOf(address(this));\n        uint256 yieldTokensToWithdraw =\n            DSMath.min(yieldTokenBalance, withdrawAmount);\n        if (yieldTokensToWithdraw > 0) {\n            collateral.safeTransfer(recipient, yieldTokensToWithdraw);\n        }\n\n        return yieldTokenBalance;\n    }\n\n    /**\n     * @notice Withdraws `asset` from vault\n     * @param collateralToken is the address of the collateral token\n     * @param weth is the WETH address\n     * @param recipient is the recipient\n     * @param withdrawAmount is the withdraw amount in terms of yearn tokens\n     * @param yieldTokenBalance is the collateral token (stETH) balance of the vault\n     */\n    function withdrawBaseToken(\n        address collateralToken,\n        address weth,\n        address recipient,\n        uint256 withdrawAmount,\n        uint256 yieldTokenBalance\n    ) internal {\n        uint256 underlyingTokensToWithdraw =\n            IWSTETH(collateralToken).getStETHByWstETH(\n                withdrawAmount.sub(yieldTokenBalance)\n            );\n\n        IWETH(weth).deposit{value: underlyingTokensToWithdraw}();\n        IERC20(weth).safeTransfer(recipient, underlyingTokensToWithdraw);\n    }\n\n    /**\n     * @notice Unwraps the necessary amount of the wstETH token\n     *         and transfers ETH amount to vault\n     * @param amount is the amount of ETH to withdraw\n     * @param wstEth is the address of wstETH\n     * @param stethToken is the address of stETH\n     * @param crvPool is the address of the steth <-> eth pool on curve\n     * @param minETHOut is the minimum eth amount to receive from the swap\n     * @return amountETHOut is the amount of eth unwrapped\n     available for the withdrawal (may incur curve slippage)\n     */\n    function unwrapYieldToken(\n        uint256 amount,\n        address wstEth,\n        address stethToken,\n        address crvPool,\n        uint256 minETHOut\n    ) external returns (uint256) {\n        require(\n            amount >= minETHOut,\n            \"Amount withdrawn smaller than minETHOut from swap\"\n        );\n        require(\n            minETHOut.mul(10**18).div(amount) >= 0.95 ether,\n            \"Slippage on minETHOut too high\"\n        );\n\n        uint256 ethBalance = address(this).balance;\n        IERC20 steth = IERC20(stethToken);\n        uint256 stethBalance = steth.balanceOf(address(this));\n\n        // 3 different success scenarios\n        // Scenario 1. We hold enough ETH to satisfy withdrawal. Send it out directly\n        // Scenario 2. We hold enough wstETH to satisy withdrawal. Unwrap then swap\n        // Scenario 3. We hold enough ETH + stETH to satisfy withdrawal. Do a swap\n\n        // Scenario 1\n        if (ethBalance >= amount) {\n            return amount;\n        }\n\n        // Scenario 2\n        stethBalance = unwrapWstethForWithdrawal(\n            wstEth,\n            steth,\n            ethBalance,\n            stethBalance,\n            amount,\n            minETHOut\n        );\n\n        // Scenario 3\n        // Now that we satisfied the ETH + stETH sum, we swap the stETH amounts necessary\n        // to facilitate a withdrawal\n\n        // This won't underflow since we already asserted that ethBalance < amount before this\n        uint256 stEthAmountToSwap =\n            DSMath.min(amount.sub(ethBalance), stethBalance);\n\n        uint256 ethAmountOutFromSwap =\n            swapStEthToEth(steth, crvPool, stEthAmountToSwap);\n\n        uint256 totalETHOut = ethBalance.add(ethAmountOutFromSwap);\n\n        // Since minETHOut is derived from calling the Curve pool's getter,\n        // it reverts in the worst case where the user needs to unwrap and sell\n        // 100% of their ETH withdrawal amount\n        require(\n            totalETHOut >= minETHOut,\n            \"Output ETH amount smaller than minETHOut\"\n        );\n\n        return totalETHOut;\n    }\n\n    /**\n     * @notice Unwraps the required amount of wstETH to a target ETH amount\n     * @param wstEthAddress is the address for wstETH\n     * @param steth is the ERC20 of stETH\n     * @param startStEthBalance is the starting stETH balance used to determine how much more to unwrap\n     * @param ethAmount is the ETH amount needed for the contract\n     * @param minETHOut is the ETH amount but adjusted for slippage\n     * @return the new stETH balance\n     */\n    function unwrapWstethForWithdrawal(\n        address wstEthAddress,\n        IERC20 steth,\n        uint256 ethBalance,\n        uint256 startStEthBalance,\n        uint256 ethAmount,\n        uint256 minETHOut\n    ) internal returns (uint256) {\n        uint256 ethstEthSum = ethBalance.add(startStEthBalance);\n\n        if (ethstEthSum < minETHOut) {\n            uint256 stethNeededFromUnwrap = ethAmount.sub(ethstEthSum);\n            IWSTETH wstEth = IWSTETH(wstEthAddress);\n            uint256 wstAmountToUnwrap =\n                wstEth.getWstETHByStETH(stethNeededFromUnwrap);\n\n            wstEth.unwrap(wstAmountToUnwrap);\n\n            uint256 newStEthBalance = steth.balanceOf(address(this));\n            require(\n                ethBalance.add(newStEthBalance) >= minETHOut,\n                \"Unwrapping wstETH did not return sufficient stETH\"\n            );\n            return newStEthBalance;\n        }\n        return startStEthBalance;\n    }\n\n    /**\n     * @notice Swaps from stEth to ETH on the Lido Curve pool\n     * @param steth is the address for the Lido staked ether\n     * @param crvPool is the Curve pool address to do the swap\n     * @param stEthAmount is the stEth amount to be swapped to Ether\n     * @return ethAmountOutFromSwap is the returned ETH amount from swap\n     */\n    function swapStEthToEth(\n        IERC20 steth,\n        address crvPool,\n        uint256 stEthAmount\n    ) internal returns (uint256) {\n        steth.safeApprove(crvPool, stEthAmount);\n\n        // CRV SWAP HERE from steth -> eth\n        // 0 = ETH, 1 = STETH\n        // We are setting 1, which is the smallest possible value for the _minAmountOut parameter\n        // However it is fine because we check that the totalETHOut >= minETHOut at the end\n        // which makes sandwich attacks not possible\n        uint256 ethAmountOutFromSwap =\n            ICRV(crvPool).exchange(1, 0, stEthAmount, 1);\n\n        return ethAmountOutFromSwap;\n    }\n\n    /**\n     * @notice Wraps the necessary amount of the base token to the yield-bearing yearn token\n     * @param weth is the address of weth\n     * @param collateralToken is the address of the collateral token\n     */\n    function wrapToYieldToken(\n        address weth,\n        address collateralToken,\n        address steth\n    ) external {\n        // Unwrap all weth premiums transferred to contract\n        IWETH wethToken = IWETH(weth);\n        uint256 wethBalance = wethToken.balanceOf(address(this));\n\n        if (wethBalance > 0) {\n            wethToken.withdraw(wethBalance);\n        }\n\n        uint256 ethBalance = address(this).balance;\n\n        IWSTETH collateral = IWSTETH(collateralToken);\n        IERC20 stethToken = IERC20(steth);\n\n        if (ethBalance > 0) {\n            // Send eth to Lido, recieve steth\n            ISTETH(steth).submit{value: ethBalance}(address(this));\n        }\n\n        // Get all steth in contract\n        uint256 stethBalance = stethToken.balanceOf(address(this));\n\n        if (stethBalance > 0) {\n            // approve wrap\n            stethToken.safeApprove(collateralToken, stethBalance.add(1));\n            // Wrap to wstETH - need to add 1 to steth balance as it is innacurate\n            collateral.wrap(stethBalance.add(1));\n        }\n    }\n\n    /**\n     * @notice Helper function to make either an ETH transfer or ERC20 transfer\n     * @param recipient is the receiving address\n     * @param amount is the transfer amount\n     */\n    function transferAsset(address recipient, uint256 amount) public {\n        (bool success, ) = payable(recipient).call{value: amount}(\"\");\n        require(success, \"!success\");\n    }\n}\n"
    },
    "contracts/vaults/STETHVault/base/RibbonVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    ERC20Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport {IWSTETH} from \"../../../interfaces/ISTETH.sol\";\nimport {Vault} from \"../../../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../../../libraries/VaultLifecycle.sol\";\nimport {VaultLifecycleSTETH} from \"../../../libraries/VaultLifecycleSTETH.sol\";\nimport {ShareMath} from \"../../../libraries/ShareMath.sol\";\n\ncontract RibbonVault is\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    ERC20Upgradeable\n{\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  NON UPGRADEABLE STORAGE\n     ***********************************************/\n\n    /// @notice Stores the user's pending deposit for the round\n    mapping(address => Vault.DepositReceipt) public depositReceipts;\n\n    /// @notice On every round's close, the pricePerShare value of an rTHETA token is stored\n    /// This is used to determine the number of shares to be returned\n    /// to a user with their DepositReceipt.depositAmount\n    mapping(uint256 => uint256) public roundPricePerShare;\n\n    /// @notice Stores pending user withdrawals\n    mapping(address => Vault.Withdrawal) public withdrawals;\n\n    /// @notice Vault's parameters like cap, decimals\n    Vault.VaultParams public vaultParams;\n\n    /// @notice Vault's lifecycle state like round and locked amounts\n    Vault.VaultState public vaultState;\n\n    /// @notice Vault's state of the options sold and the timelocked option\n    Vault.OptionState public optionState;\n\n    /// @notice Fee recipient for the performance and management fees\n    address public feeRecipient;\n\n    /// @notice role in charge of weekly vault operations such as rollToNextOption and burnRemainingOTokens\n    // no access to critical vault changes\n    address public keeper;\n\n    /// @notice Performance fee charged on premiums earned in rollToNextOption. Only charged when there is no loss.\n    uint256 public performanceFee;\n\n    /// @notice Management fee charged on entire AUM in rollToNextOption. Only charged when there is no loss.\n    uint256 public managementFee;\n\n    /// @notice wstETH vault contract\n    IWSTETH public immutable collateralToken;\n\n    // Gap is left to avoid storage collisions. Though RibbonVault is not upgradeable, we add this as a safety measure.\n    uint256[30] private ____gap;\n\n    // *IMPORTANT* NO NEW STORAGE VARIABLES SHOULD BE ADDED HERE\n    // This is to prevent storage collisions. All storage variables should be appended to RibbonThetaSTETHVaultStorage\n    // https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#modifying-your-contracts\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    /// @notice WETH9 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n    address public immutable WETH;\n\n    /// @notice USDC 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n    address public immutable USDC;\n\n    /// @notice Lido DAO token 0x5a98fcbea516cf06857215779fd812ca3bef1b32\n    address public immutable LDO;\n\n    /// @notice 15 minute timelock between commitAndClose and rollToNexOption.\n    uint256 public constant DELAY = 0;\n\n    /// @notice 7 day period between each options sale.\n    uint256 public constant PERIOD = 7 days;\n\n    // Number of weeks per year = 52.142857 weeks * FEE_MULTIPLIER = 52142857\n    // Dividing by weeks per year requires doing num.mul(FEE_MULTIPLIER).div(WEEKS_PER_YEAR)\n    uint256 private constant WEEKS_PER_YEAR = 52142857;\n\n    // GAMMA_CONTROLLER is the top-level contract in Gamma protocol\n    // which allows users to perform multiple actions on their vaults\n    // and positions https://github.com/opynfinance/GammaProtocol/blob/master/contracts/core/Controller.sol\n    address public immutable GAMMA_CONTROLLER;\n\n    // MARGIN_POOL is Gamma protocol's collateral pool.\n    // Needed to approve collateral.safeTransferFrom for minting otokens.\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/core/MarginPool.sol\n    address public immutable MARGIN_POOL;\n\n    // GNOSIS_EASY_AUCTION is Gnosis protocol's contract for initiating auctions and placing bids\n    // https://github.com/gnosis/ido-contracts/blob/main/contracts/EasyAuction.sol\n    address public immutable GNOSIS_EASY_AUCTION;\n\n    // Curve stETH / ETH stables pool\n    address public immutable STETH_ETH_CRV_POOL;\n\n    /// @notice STETH contract address\n    address public immutable STETH;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event Deposit(address indexed account, uint256 amount, uint256 round);\n\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n\n    event Redeem(address indexed account, uint256 share, uint256 round);\n\n    event ManagementFeeSet(uint256 managementFee, uint256 newManagementFee);\n    event PerformanceFeeSet(uint256 performanceFee, uint256 newPerformanceFee);\n    event CapSet(uint256 oldCap, uint256 newCap);\n\n    event Withdraw(address indexed account, uint256 amount, uint256 shares);\n\n    event CollectVaultFees(\n        uint256 performanceFee,\n        uint256 vaultFee,\n        uint256 round,\n        address indexed feeRecipient\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _wsteth is the wstETH contract\n     * @param _ldo is the LDO contract\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     * @param _crvPool is the steth/eth crv stables pool\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _wsteth,\n        address _ldo,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction,\n        address _crvPool\n    ) {\n        require(_weth != address(0), \"!_weth\");\n        require(_usdc != address(0), \"!_usdc\");\n        require(_wsteth != address(0), \"!_wsteth\");\n        require(_ldo != address(0), \"!_ldo\");\n\n        require(_gnosisEasyAuction != address(0), \"!_gnosisEasyAuction\");\n        require(_gammaController != address(0), \"!_gammaController\");\n        require(_marginPool != address(0), \"!_marginPool\");\n        require(_crvPool != address(0), \"!_crvPool\");\n\n        WETH = _weth;\n        USDC = _usdc;\n        LDO = _ldo;\n        STETH = IWSTETH(_wsteth).stETH();\n\n        GAMMA_CONTROLLER = _gammaController;\n        MARGIN_POOL = _marginPool;\n        GNOSIS_EASY_AUCTION = _gnosisEasyAuction;\n        STETH_ETH_CRV_POOL = _crvPool;\n        collateralToken = IWSTETH(_wsteth);\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function baseInitialize(\n        address _owner,\n        address _keeper,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) internal initializer {\n        VaultLifecycle.verifyInitializerParams(\n            _owner,\n            _keeper,\n            _feeRecipient,\n            _performanceFee,\n            _managementFee,\n            _tokenName,\n            _tokenSymbol,\n            _vaultParams\n        );\n\n        __ReentrancyGuard_init();\n        __ERC20_init(_tokenName, _tokenSymbol);\n        __Ownable_init();\n        transferOwnership(_owner);\n\n        keeper = _keeper;\n\n        feeRecipient = _feeRecipient;\n        performanceFee = _performanceFee;\n        managementFee = _managementFee.mul(Vault.FEE_MULTIPLIER).div(\n            WEEKS_PER_YEAR\n        );\n        vaultParams = _vaultParams;\n\n        uint256 assetBalance = totalBalance();\n        ShareMath.assertUint104(assetBalance);\n        vaultState.lastLockedAmount = uint104(assetBalance);\n\n        vaultState.round = 1;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the keeper.\n     */\n    modifier onlyKeeper() {\n        require(msg.sender == keeper, \"!keeper\");\n        _;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new keeper\n     * @param newKeeper is the address of the new keeper\n     */\n    function setNewKeeper(address newKeeper) external onlyOwner {\n        require(newKeeper != address(0), \"!newKeeper\");\n        keeper = newKeeper;\n    }\n\n    /**\n     * @notice Sets the new fee recipient\n     * @param newFeeRecipient is the address of the new fee recipient\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        require(newFeeRecipient != address(0), \"!newFeeRecipient\");\n        require(newFeeRecipient != feeRecipient, \"Must be new feeRecipient\");\n        feeRecipient = newFeeRecipient;\n    }\n\n    /**\n     * @notice Sets the management fee for the vault\n     * @param newManagementFee is the management fee (6 decimals). ex: 2 * 10 ** 6 = 2%\n     */\n    function setManagementFee(uint256 newManagementFee) external onlyOwner {\n        require(\n            newManagementFee < 100 * Vault.FEE_MULTIPLIER,\n            \"Invalid management fee\"\n        );\n\n        // We are dividing annualized management fee by num weeks in a year\n        uint256 tmpManagementFee =\n            newManagementFee.mul(Vault.FEE_MULTIPLIER).div(WEEKS_PER_YEAR);\n\n        emit ManagementFeeSet(managementFee, newManagementFee);\n\n        managementFee = tmpManagementFee;\n    }\n\n    /**\n     * @notice Sets the performance fee for the vault\n     * @param newPerformanceFee is the performance fee (6 decimals). ex: 20 * 10 ** 6 = 20%\n     */\n    function setPerformanceFee(uint256 newPerformanceFee) external onlyOwner {\n        require(\n            newPerformanceFee < 100 * Vault.FEE_MULTIPLIER,\n            \"Invalid performance fee\"\n        );\n        emit PerformanceFeeSet(performanceFee, newPerformanceFee);\n        performanceFee = newPerformanceFee;\n    }\n\n    /**\n     * @notice Sets a new cap for deposits\n     * @param newCap is the new cap for deposits\n     */\n    function setCap(uint256 newCap) external onlyOwner {\n        require(newCap > 0, \"!newCap\");\n        ShareMath.assertUint104(newCap);\n        emit CapSet(vaultParams.cap, newCap);\n        vaultParams.cap = uint104(newCap);\n    }\n\n    /************************************************\n     *  DEPOSIT & WITHDRAWALS\n     ***********************************************/\n\n    /**\n     * @notice Deposits ETH into the contract and mint vault shares.\n     */\n    function depositETH() external payable nonReentrant {\n        require(msg.value > 0, \"!value\");\n\n        _depositFor(msg.value, msg.sender, true);\n    }\n\n    /**\n     * @notice Deposits the `collateralAsset` into the contract and mint vault shares.\n     * @param amount is the amount of `collateralAsset` to deposit\n     */\n    function depositYieldToken(uint256 amount) external nonReentrant {\n        require(amount > 0, \"!amount\");\n\n        // stETH transfers suffer from an off-by-1 error\n        _depositFor(amount.sub(1), msg.sender, false);\n\n        IERC20(STETH).safeTransferFrom(msg.sender, address(this), amount);\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\n     * @notice Used for vault -> vault deposits on the user's behalf\n     * @param creditor is the address that can claim/withdraw deposited amount\n     */\n    function depositFor(address creditor) external payable nonReentrant {\n        require(msg.value > 0, \"!value\");\n        require(creditor != address(0), \"!creditor\");\n\n        _depositFor(msg.value, creditor, true);\n    }\n\n    /**\n     * @notice Mints the vault shares to the creditor\n     * @param amount is the amount of `asset` deposited\n     * @param creditor is the address to receieve the deposit\n     * @param isETH is whether this is a depositETH call\n     */\n    function _depositFor(\n        uint256 amount,\n        address creditor,\n        bool isETH\n    ) private {\n        uint256 currentRound = vaultState.round;\n        uint256 totalWithDepositedAmount =\n            isETH ? totalBalance() : totalBalance().add(amount);\n\n        require(totalWithDepositedAmount <= vaultParams.cap, \"Exceed cap\");\n        require(\n            totalWithDepositedAmount >= vaultParams.minimumSupply,\n            \"Insufficient balance\"\n        );\n\n        emit Deposit(creditor, amount, currentRound);\n\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[creditor];\n\n        // If we have an unprocessed pending deposit from the previous rounds, we have to process it.\n        uint256 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        uint256 depositAmount = amount;\n        // If we have a pending deposit in the current round, we add on to the pending deposit\n        if (currentRound == depositReceipt.round) {\n            uint256 newAmount = uint256(depositReceipt.amount).add(amount);\n            depositAmount = newAmount;\n        }\n\n        ShareMath.assertUint104(depositAmount);\n\n        depositReceipts[creditor] = Vault.DepositReceipt({\n            round: uint16(currentRound),\n            amount: uint104(depositAmount),\n            unredeemedShares: uint128(unredeemedShares)\n        });\n\n        uint256 newTotalPending = uint256(vaultState.totalPending).add(amount);\n        ShareMath.assertUint128(newTotalPending);\n        vaultState.totalPending = uint128(newTotalPending);\n    }\n\n    /**\n     * @notice Initiates a withdrawal that can be processed once the round completes\n     * @param numShares is the number of shares to withdraw\n     */\n    function initiateWithdraw(uint256 numShares) external nonReentrant {\n        require(numShares > 0, \"!numShares\");\n\n        // We do a max redeem before initiating a withdrawal\n        // But we check if they must first have unredeemed shares\n        if (\n            depositReceipts[msg.sender].amount > 0 ||\n            depositReceipts[msg.sender].unredeemedShares > 0\n        ) {\n            _redeem(0, true);\n        }\n\n        // This caches the `round` variable used in shareBalances\n        uint256 currentRound = vaultState.round;\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        bool withdrawalIsSameRound = withdrawal.round == currentRound;\n\n        emit InitiateWithdraw(msg.sender, numShares, currentRound);\n\n        uint256 existingShares = uint256(withdrawal.shares);\n\n        uint256 withdrawalShares;\n        if (withdrawalIsSameRound) {\n            withdrawalShares = existingShares.add(numShares);\n        } else {\n            require(existingShares == 0, \"Existing withdraw\");\n            withdrawalShares = numShares;\n            withdrawals[msg.sender].round = uint16(currentRound);\n        }\n\n        ShareMath.assertUint128(withdrawalShares);\n        withdrawals[msg.sender].shares = uint128(withdrawalShares);\n\n        uint256 newQueuedWithdrawShares =\n            uint256(vaultState.queuedWithdrawShares).add(numShares);\n        ShareMath.assertUint128(newQueuedWithdrawShares);\n        vaultState.queuedWithdrawShares = uint128(newQueuedWithdrawShares);\n\n        _transfer(msg.sender, address(this), numShares);\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     * @param minETHOut is the min amount of `asset` to recieve for the swapped amount of steth in crv pool\n     * @return amountETHOut the current withdrawal amount\n     */\n    function _completeWithdraw(uint256 minETHOut) internal returns (uint256) {\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        uint256 withdrawalShares = withdrawal.shares;\n        uint256 withdrawalRound = withdrawal.round;\n\n        // This checks if there is a withdrawal\n        require(withdrawalShares > 0, \"Not initiated\");\n\n        require(withdrawalRound < vaultState.round, \"Round not closed\");\n\n        // We leave the round number as non-zero to save on gas for subsequent writes\n        withdrawals[msg.sender].shares = 0;\n        vaultState.queuedWithdrawShares = uint128(\n            uint256(vaultState.queuedWithdrawShares).sub(withdrawalShares)\n        );\n\n        uint256 withdrawAmount =\n            ShareMath.sharesToAsset(\n                withdrawalShares,\n                roundPricePerShare[withdrawalRound],\n                vaultParams.decimals\n            );\n\n        // Unwrap may incur curve pool slippage\n        uint256 amountETHOut =\n            VaultLifecycleSTETH.unwrapYieldToken(\n                withdrawAmount,\n                address(collateralToken),\n                STETH,\n                STETH_ETH_CRV_POOL,\n                minETHOut\n            );\n\n        emit Withdraw(msg.sender, amountETHOut, withdrawalShares);\n\n        _burn(address(this), withdrawalShares);\n\n        require(amountETHOut > 0, \"!amountETHOut\");\n\n        VaultLifecycleSTETH.transferAsset(msg.sender, amountETHOut);\n\n        return amountETHOut;\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem\n     */\n    function redeem(uint256 numShares) external nonReentrant {\n        require(numShares > 0, \"!numShares\");\n        _redeem(numShares, false);\n    }\n\n    /**\n     * @notice Redeems the entire unredeemedShares balance that is owed to the account\n     */\n    function maxRedeem() external nonReentrant {\n        _redeem(0, true);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem, could be 0 when isMax=true\n     * @param isMax is flag for when callers do a max redemption\n     */\n    function _redeem(uint256 numShares, bool isMax) internal {\n        Vault.DepositReceipt memory depositReceipt =\n            depositReceipts[msg.sender];\n\n        // This handles the null case when depositReceipt.round = 0\n        // Because we start with round = 1 at `initialize`\n        uint256 currentRound = vaultState.round;\n\n        uint256 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        numShares = isMax ? unredeemedShares : numShares;\n        if (numShares == 0) {\n            return;\n        }\n        require(numShares <= unredeemedShares, \"Exceeds available\");\n\n        // If we have a depositReceipt on the same round, BUT we have some unredeemed shares\n        // we debit from the unredeemedShares, but leave the amount field intact\n        // If the round has past, with no new deposits, we just zero it out for new deposits.\n        if (depositReceipt.round < currentRound) {\n            depositReceipts[msg.sender].amount = 0;\n        }\n\n        ShareMath.assertUint128(numShares);\n        depositReceipts[msg.sender].unredeemedShares = uint128(\n            unredeemedShares.sub(numShares)\n        );\n\n        emit Redeem(msg.sender, numShares, depositReceipt.round);\n\n        _transfer(address(this), msg.sender, numShares);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /*\n     * @notice Helper function that helps to save gas for writing values into the roundPricePerShare map.\n     *         Writing `1` into the map makes subsequent writes warm, reducing the gas from 20k to 5k.\n     *         Having 1 initialized beforehand will not be an issue as long as we round down share calculations to 0.\n     * @param numRounds is the number of rounds to initialize in the map\n     */\n    function initRounds(uint256 numRounds) external nonReentrant {\n        require(numRounds > 0, \"!numRounds\");\n\n        uint256 _round = vaultState.round;\n        for (uint256 i = 0; i < numRounds; i++) {\n            uint256 index = _round + i;\n            require(roundPricePerShare[index] == 0, \"Initialized\"); // AVOID OVERWRITING ACTUAL VALUES\n            roundPricePerShare[index] = ShareMath.PLACEHOLDER_UINT;\n        }\n    }\n\n    /*\n     * @notice Helper function that performs most administrative tasks\n     * such as setting next option, minting new shares, getting vault fees, etc.\n     * @param lastQueuedWithdrawAmount is old queued withdraw amount\n     * @return newOption is the new option address\n     * @return queuedWithdrawAmount is the queued amount for withdrawal\n     */\n    function _rollToNextOption(uint256 lastQueuedWithdrawAmount)\n        internal\n        returns (address, uint256)\n    {\n        require(block.timestamp >= optionState.nextOptionReadyAt, \"!ready\");\n\n        address newOption = optionState.nextOption;\n        require(newOption != address(0), \"!nextOption\");\n\n        (\n            uint256 newLockedBalanceInETH,\n            uint256 queuedWithdrawAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares,\n            uint256 performanceFeeInAsset,\n            uint256 totalVaultFee\n        ) =\n            VaultLifecycle.rollover(\n                vaultState,\n                VaultLifecycle.RolloverParams(\n                    vaultParams.decimals,\n                    totalBalance(),\n                    totalSupply(),\n                    lastQueuedWithdrawAmount,\n                    performanceFee,\n                    managementFee\n                )\n            );\n\n        optionState.currentOption = newOption;\n        optionState.nextOption = address(0);\n\n        {\n            address vaultFeeRecipient = feeRecipient;\n            address collateral = address(collateralToken);\n\n            // Finalize the pricePerShare at the end of the round\n            uint256 currentRound = vaultState.round;\n            roundPricePerShare[currentRound] = newPricePerShare;\n\n            // Wrap entire `asset` balance to `collateralToken` balance\n            VaultLifecycleSTETH.wrapToYieldToken(WETH, collateral, STETH);\n\n            emit CollectVaultFees(\n                performanceFeeInAsset,\n                totalVaultFee,\n                currentRound,\n                vaultFeeRecipient\n            );\n\n            vaultState.totalPending = 0;\n            vaultState.round = uint16(currentRound + 1);\n            ShareMath.assertUint104(newLockedBalanceInETH);\n            vaultState.lockedAmount = uint104(newLockedBalanceInETH);\n\n            _mint(address(this), mintShares);\n\n            if (totalVaultFee > 0) {\n                VaultLifecycleSTETH.withdrawYieldAndBaseToken(\n                    collateral,\n                    WETH,\n                    vaultFeeRecipient,\n                    totalVaultFee\n                );\n            }\n        }\n\n        return (newOption, queuedWithdrawAmount);\n    }\n\n    /*\n     * @notice Transfers LDO rewards to feeRecipient\n     */\n    function sendLDORewards() external {\n        IERC20 ldo = IERC20(LDO);\n        ldo.safeTransfer(feeRecipient, ldo.balanceOf(address(this)));\n    }\n\n    /************************************************\n     *  GETTERS\n     ***********************************************/\n\n    /**\n     * @notice Returns the asset balance held on the vault for the account\n     * @param account is the address to lookup balance for\n     * @return the amount of `asset` custodied by the vault for the user\n     */\n    function accountVaultBalance(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 _decimals = vaultParams.decimals;\n        uint256 assetPerShare =\n            ShareMath.pricePerShare(\n                totalSupply(),\n                totalBalance(),\n                vaultState.totalPending,\n                _decimals\n            );\n        return\n            ShareMath.sharesToAsset(shares(account), assetPerShare, _decimals);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance including unredeemed shares\n     * @param account is the account to lookup share balance for\n     * @return the share balance\n     */\n    function shares(address account) public view returns (uint256) {\n        (uint256 heldByAccount, uint256 heldByVault) = shareBalances(account);\n        return heldByAccount.add(heldByVault);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance split between account and vault holdings\n     * @param account is the account to lookup share balance for\n     * @return heldByAccount is the shares held by account\n     * @return heldByVault is the shares held on the vault (unredeemedShares)\n     */\n    function shareBalances(address account)\n        public\n        view\n        returns (uint256 heldByAccount, uint256 heldByVault)\n    {\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[account];\n\n        if (depositReceipt.round < ShareMath.PLACEHOLDER_UINT) {\n            return (balanceOf(account), 0);\n        }\n\n        uint256 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                vaultState.round,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        return (balanceOf(account), unredeemedShares);\n    }\n\n    /**\n     * @notice The price of a unit of share denominated in the `asset`\n     */\n    function pricePerShare() external view returns (uint256) {\n        return\n            ShareMath.pricePerShare(\n                totalSupply(),\n                totalBalance(),\n                vaultState.totalPending,\n                vaultParams.decimals\n            );\n    }\n\n    /**\n     * @notice Returns the vault's total balance, including the amounts locked into a short position\n     * @return total balance of the vault, including the amounts locked in third party protocols\n     */\n    function totalBalance() public view returns (uint256) {\n        uint256 wethBalance = IERC20(WETH).balanceOf(address(this));\n        uint256 ethBalance = address(this).balance;\n        uint256 stethFromWsteth =\n            collateralToken.getStETHByWstETH(\n                collateralToken.balanceOf(address(this))\n            );\n\n        uint256 stEthBalance = IERC20(STETH).balanceOf(address(this));\n\n        return\n            wethBalance\n                .add(vaultState.lockedAmount)\n                .add(ethBalance)\n                .add(stethFromWsteth)\n                .add(stEthBalance);\n    }\n\n    /**\n     * @notice Returns the token decimals\n     */\n    function decimals() public view override returns (uint8) {\n        return vaultParams.decimals;\n    }\n\n    function cap() external view returns (uint256) {\n        return vaultParams.cap;\n    }\n\n    function nextOptionReadyAt() external view returns (uint256) {\n        return optionState.nextOptionReadyAt;\n    }\n\n    function currentOption() external view returns (address) {\n        return optionState.currentOption;\n    }\n\n    function nextOption() external view returns (address) {\n        return optionState.nextOption;\n    }\n\n    function totalPending() external view returns (uint256) {\n        return vaultState.totalPending;\n    }\n\n    /************************************************\n     *  HELPERS\n     ***********************************************/\n}\n"
    },
    "contracts/storage/RibbonThetaSTETHVaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nabstract contract RibbonThetaSTETHVaultStorageV1 {\n    // Logic contract used to price options\n    address public optionsPremiumPricer;\n    // Logic contract used to select strike prices\n    address public strikeSelection;\n    // Premium discount on options we are selling (thousandths place: 000 - 999)\n    uint256 public premiumDiscount;\n    // Current oToken premium\n    uint256 public currentOtokenPremium;\n    // Last round id at which the strike was manually overridden\n    uint16 public lastStrikeOverrideRound;\n    // Price last overridden strike set to\n    uint256 public overriddenStrikePrice;\n    // Auction duration\n    uint256 public auctionDuration;\n    // Auction id of current option\n    uint256 public optionAuctionID;\n}\n\nabstract contract RibbonThetaSTETHVaultStorageV2 {\n    // Amount locked for scheduled withdrawals last week;\n    uint256 public lastQueuedWithdrawAmount;\n}\n\n// We are following Compound's method of upgrading new contract implementations\n// When we need to add new storage variables, we create a new version of RibbonThetaVaultStorage\n// e.g. RibbonThetaVaultStorage<versionNumber>, so finally it would look like\n// contract RibbonThetaVaultStorage is RibbonThetaVaultStorageV1, RibbonThetaVaultStorageV2\nabstract contract RibbonThetaSTETHVaultStorage is\n    RibbonThetaSTETHVaultStorageV1,\n    RibbonThetaSTETHVaultStorageV2\n{\n\n}\n"
    },
    "contracts/interfaces/ISTETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\ninterface IWSTETH {\n    function getStETHByWstETH(uint256 _amount) external view returns (uint256);\n\n    function getWstETHByStETH(uint256 _amount) external view returns (uint256);\n\n    function stEthPerToken() external view returns (uint256);\n\n    function tokensPerStEth() external view returns (uint256);\n\n    function stETH() external view returns (address);\n\n    function wrap(uint256 _amount) external returns (uint256);\n\n    function unwrap(uint256 _amount) external returns (uint256);\n\n    function approve(address _recipient, uint256 _amount)\n        external\n        returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function decimals() external view returns (uint256);\n}\n\ninterface ISTETH {\n    function getBufferedEther(uint256 _amount) external view returns (uint256);\n\n    function getPooledEthByShares(uint256 _amount)\n        external\n        view\n        returns (uint256);\n\n    function getSharesByPooledEth(uint256 _amount)\n        external\n        view\n        returns (uint256);\n\n    function submit(address _referralAddress)\n        external\n        payable\n        returns (uint256);\n\n    function withdraw(uint256 _amount, bytes32 _pubkeyHash)\n        external\n        returns (uint256);\n\n    function approve(address _recipient, uint256 _amount)\n        external\n        returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function decimals() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ICRV.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\ninterface ICRV {\n    function get_dy(\n        int128 _indexIn,\n        int128 _indexOut,\n        uint256 _amountIn\n    ) external view returns (uint256);\n\n    // https://github.com/curvefi/curve-contract/blob/\n    // b0bbf77f8f93c9c5f4e415bce9cd71f0cdee960e/contracts/pools/steth/StableSwapSTETH.vy#L431\n    function exchange(\n        int128 _indexIn,\n        int128 _indexOut,\n        uint256 _amountIn,\n        uint256 _minAmountOut\n    ) external returns (uint256);\n}\n"
    },
    "contracts/vaults/BaseVaults/RibbonThetaVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport {GnosisAuction} from \"../../libraries/GnosisAuction.sol\";\nimport {\n    RibbonThetaVaultStorage\n} from \"../../storage/RibbonThetaVaultStorage.sol\";\nimport {Vault} from \"../../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../../libraries/ShareMath.sol\";\nimport {RibbonVault} from \"./base/RibbonVault.sol\";\n\n/**\n * UPGRADEABILITY: Since we use the upgradeable proxy pattern, we must observe\n * the inheritance chain closely.\n * Any changes/appends in storage variable needs to happen in RibbonThetaVaultStorage.\n * RibbonThetaVault should not inherit from any other contract aside from RibbonVault, RibbonThetaVaultStorage\n */\ncontract RibbonThetaVault is RibbonVault, RibbonThetaVaultStorage {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    /// @notice oTokenFactory is the factory contract used to spawn otokens. Used to lookup otokens.\n    address public immutable OTOKEN_FACTORY;\n\n    // The minimum duration for an option auction.\n    uint256 private constant MIN_AUCTION_DURATION = 5 minutes;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event OpenShort(\n        address indexed options,\n        uint256 depositAmount,\n        address indexed manager\n    );\n\n    event CloseShort(\n        address indexed options,\n        uint256 withdrawAmount,\n        address indexed manager\n    );\n\n    event NewOptionStrikeSelected(uint256 strikePrice, uint256 delta);\n\n    event PremiumDiscountSet(\n        uint256 premiumDiscount,\n        uint256 newPremiumDiscount\n    );\n\n    event AuctionDurationSet(\n        uint256 auctionDuration,\n        uint256 newAuctionDuration\n    );\n\n    event InstantWithdraw(\n        address indexed account,\n        uint256 amount,\n        uint256 round\n    );\n\n    event InitiateGnosisAuction(\n        address indexed auctioningToken,\n        address indexed biddingToken,\n        uint256 auctionCounter,\n        address indexed manager\n    );\n\n    /************************************************\n     *  STRUCTS\n     ***********************************************/\n\n    /**\n     * @notice Initialization parameters for the vault.\n     * @param _owner is the owner of the vault with critical permissions\n     * @param _feeRecipient is the address to recieve vault performance and management fees\n     * @param _managementFee is the management fee pct.\n     * @param _performanceFee is the perfomance fee pct.\n     * @param _tokenName is the name of the token\n     * @param _tokenSymbol is the symbol of the token\n     * @param _optionsPremiumPricer is the address of the contract with the\n       black-scholes premium calculation logic\n     * @param _strikeSelection is the address of the contract with strike selection logic\n     * @param _premiumDiscount is the vault's discount applied to the premium\n     * @param _auctionDuration is the duration of the gnosis auction\n     * @param _isUsdcAuction is whether Gnosis auction should be denominated in USDC\n     * @param _swapPath is the path for swapping\n     */\n    struct InitParams {\n        address _owner;\n        address _keeper;\n        address _feeRecipient;\n        uint256 _managementFee;\n        uint256 _performanceFee;\n        string _tokenName;\n        string _tokenSymbol;\n        address _optionsPremiumPricer;\n        address _strikeSelection;\n        uint32 _premiumDiscount;\n        uint256 _auctionDuration;\n        bool _isUsdcAuction;\n        bytes _swapPath;\n    }\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _oTokenFactory is the contract address for minting new opyn option types (strikes, asset, expiry)\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     * @param _uniswapRouter is the contract address of UniswapV3 router that handles swaps\n     * @param _uniswapFactory is the contract address of UniswapV3 factory containing\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _oTokenFactory,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction,\n        address _uniswapRouter,\n        address _uniswapFactory\n    )\n        RibbonVault(\n            _weth,\n            _usdc,\n            _gammaController,\n            _marginPool,\n            _gnosisEasyAuction,\n            _uniswapRouter,\n            _uniswapFactory\n        )\n    {\n        require(_oTokenFactory != address(0), \"!_oTokenFactory\");\n        OTOKEN_FACTORY = _oTokenFactory;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     * @param _initParams is the struct with vault initialization parameters\n     * @param _vaultParams is the struct with vault general data\n     */\n    function initialize(\n        InitParams calldata _initParams,\n        Vault.VaultParams calldata _vaultParams\n    ) external initializer {\n        baseInitialize(\n            _initParams._owner,\n            _initParams._keeper,\n            _initParams._feeRecipient,\n            _initParams._managementFee,\n            _initParams._performanceFee,\n            _initParams._tokenName,\n            _initParams._tokenSymbol,\n            _vaultParams\n        );\n        require(\n            _initParams._optionsPremiumPricer != address(0),\n            \"!_optionsPremiumPricer\"\n        );\n        require(\n            _initParams._strikeSelection != address(0),\n            \"!_strikeSelection\"\n        );\n        require(\n            _initParams._premiumDiscount > 0 &&\n                _initParams._premiumDiscount <\n                100 * Vault.PREMIUM_DISCOUNT_MULTIPLIER,\n            \"!_premiumDiscount\"\n        );\n        require(\n            _initParams._auctionDuration >= MIN_AUCTION_DURATION,\n            \"!_auctionDuration\"\n        );\n        optionsPremiumPricer = _initParams._optionsPremiumPricer;\n        strikeSelection = _initParams._strikeSelection;\n        premiumDiscount = _initParams._premiumDiscount;\n        auctionDuration = _initParams._auctionDuration;\n\n        isUsdcAuction = _initParams._isUsdcAuction;\n        if (_initParams._isUsdcAuction) {\n            require(_checkPath(_initParams._swapPath), \"Invalid swapPath\");\n            swapPath = _initParams._swapPath;\n        }\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new discount on premiums for options we are selling\n     * @param newPremiumDiscount is the premium discount\n     */\n    function setPremiumDiscount(uint256 newPremiumDiscount) external onlyOwner {\n        require(\n            newPremiumDiscount > 0 &&\n                newPremiumDiscount < 100 * Vault.PREMIUM_DISCOUNT_MULTIPLIER,\n            \"Invalid discount\"\n        );\n\n        emit PremiumDiscountSet(premiumDiscount, newPremiumDiscount);\n\n        premiumDiscount = newPremiumDiscount;\n    }\n\n    /**\n     * @notice Sets the new auction duration\n     * @param newAuctionDuration is the auction duration\n     */\n    function setAuctionDuration(uint256 newAuctionDuration) external onlyOwner {\n        require(\n            newAuctionDuration >= MIN_AUCTION_DURATION,\n            \"Invalid auction duration\"\n        );\n\n        emit AuctionDurationSet(auctionDuration, newAuctionDuration);\n\n        auctionDuration = newAuctionDuration;\n    }\n\n    /**\n     * @notice Sets the new strike selection contract\n     * @param newStrikeSelection is the address of the new strike selection contract\n     */\n    function setStrikeSelection(address newStrikeSelection) external onlyOwner {\n        require(newStrikeSelection != address(0), \"!newStrikeSelection\");\n        strikeSelection = newStrikeSelection;\n    }\n\n    /**\n     * @notice Sets the new options premium pricer contract\n     * @param newOptionsPremiumPricer is the address of the new strike selection contract\n     */\n    function setOptionsPremiumPricer(address newOptionsPremiumPricer)\n        external\n        onlyOwner\n    {\n        require(\n            newOptionsPremiumPricer != address(0),\n            \"!newOptionsPremiumPricer\"\n        );\n        optionsPremiumPricer = newOptionsPremiumPricer;\n    }\n\n    /**\n     * @notice Optionality to set strike price manually\n     * @param strikePrice is the strike price of the new oTokens (decimals = 8)\n     */\n    function setStrikePrice(uint128 strikePrice)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        require(strikePrice > 0, \"!strikePrice\");\n        overriddenStrikePrice = strikePrice;\n        lastStrikeOverrideRound = vaultState.round;\n    }\n\n    /**\n     * @notice Sets a new path for swaps\n     * @param newSwapPath is the new path\n     */\n    function setSwapPath(bytes calldata newSwapPath)\n        external\n        onlyOwner\n        nonReentrant\n    {\n        require(isUsdcAuction, \"!isUsdcAuction\");\n        require(_checkPath(newSwapPath), \"Invalid swapPath\");\n        swapPath = newSwapPath;\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `DepositReceipt.amount`\n     * @param amount is the amount to withdraw\n     */\n    function withdrawInstantly(uint256 amount) external nonReentrant {\n        Vault.DepositReceipt storage depositReceipt =\n            depositReceipts[msg.sender];\n\n        uint256 currentRound = vaultState.round;\n        require(amount > 0, \"!amount\");\n        require(depositReceipt.round == currentRound, \"Invalid round\");\n\n        uint256 receiptAmount = depositReceipt.amount;\n        require(receiptAmount >= amount, \"Exceed amount\");\n\n        // Subtraction underflow checks already ensure it is smaller than uint104\n        depositReceipt.amount = uint104(receiptAmount.sub(amount));\n        vaultState.totalPending = uint128(\n            uint256(vaultState.totalPending).sub(amount)\n        );\n\n        emit InstantWithdraw(msg.sender, amount, currentRound);\n\n        transferAsset(msg.sender, amount);\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     */\n    function completeWithdraw() external nonReentrant {\n        uint256 withdrawAmount = _completeWithdraw();\n        lastQueuedWithdrawAmount = uint128(\n            uint256(lastQueuedWithdrawAmount).sub(withdrawAmount)\n        );\n    }\n\n    /**\n     * @notice Sets the next option the vault will be shorting, and closes the existing short.\n     *         This allows all the users to withdraw if the next option is malicious.\n     */\n    function commitAndClose() external nonReentrant {\n        address oldOption = optionState.currentOption;\n\n        VaultLifecycle.CloseParams memory closeParams =\n            VaultLifecycle.CloseParams({\n                OTOKEN_FACTORY: OTOKEN_FACTORY,\n                USDC: USDC,\n                currentOption: oldOption,\n                delay: DELAY,\n                lastStrikeOverrideRound: lastStrikeOverrideRound,\n                overriddenStrikePrice: overriddenStrikePrice\n            });\n\n        (\n            address otokenAddress,\n            uint256 premium,\n            uint256 strikePrice,\n            uint256 delta\n        ) =\n            VaultLifecycle.commitAndClose(\n                strikeSelection,\n                optionsPremiumPricer,\n                premiumDiscount,\n                closeParams,\n                vaultParams,\n                vaultState\n            );\n\n        emit NewOptionStrikeSelected(strikePrice, delta);\n\n        ShareMath.assertUint104(premium);\n        currentOtokenPremium = uint104(premium);\n        optionState.nextOption = otokenAddress;\n\n        uint256 nextOptionReady = block.timestamp.add(DELAY);\n        require(\n            nextOptionReady <= type(uint32).max,\n            \"Overflow nextOptionReady\"\n        );\n        optionState.nextOptionReadyAt = uint32(nextOptionReady);\n\n        _closeShort(oldOption);\n    }\n\n    /**\n     * @notice Closes the existing short position for the vault.\n     */\n    function _closeShort(address oldOption) private {\n        uint256 lockedAmount = vaultState.lockedAmount;\n        if (oldOption != address(0)) {\n            vaultState.lastLockedAmount = uint104(lockedAmount);\n        }\n        vaultState.lockedAmount = 0;\n\n        optionState.currentOption = address(0);\n\n        if (oldOption != address(0)) {\n            uint256 withdrawAmount =\n                VaultLifecycle.settleShort(GAMMA_CONTROLLER);\n            emit CloseShort(oldOption, withdrawAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Rolls the vault's funds into a new short position.\n     */\n    function rollToNextOption() external onlyKeeper nonReentrant {\n        (\n            address newOption,\n            uint256 lockedBalance,\n            uint256 queuedWithdrawAmount\n        ) = _rollToNextOption(uint256(lastQueuedWithdrawAmount));\n\n        lastQueuedWithdrawAmount = queuedWithdrawAmount;\n\n        ShareMath.assertUint104(lockedBalance);\n        vaultState.lockedAmount = uint104(lockedBalance);\n\n        emit OpenShort(newOption, lockedBalance, msg.sender);\n\n        VaultLifecycle.createShort(\n            GAMMA_CONTROLLER,\n            MARGIN_POOL,\n            newOption,\n            lockedBalance\n        );\n\n        _startAuction();\n    }\n\n    /**\n     * @notice Initiate the gnosis auction.\n     */\n    function startAuction() external onlyKeeper nonReentrant {\n        _startAuction();\n    }\n\n    function _startAuction() private {\n        GnosisAuction.AuctionDetails memory auctionDetails;\n\n        uint256 currOtokenPremium = currentOtokenPremium;\n\n        require(currOtokenPremium > 0, \"!currentOtokenPremium\");\n\n        bool _isUsdcAuction = isUsdcAuction;\n        auctionDetails.oTokenAddress = optionState.currentOption;\n        auctionDetails.gnosisEasyAuction = GNOSIS_EASY_AUCTION;\n        auctionDetails.asset = _isUsdcAuction ? USDC : vaultParams.asset;\n        auctionDetails.assetDecimals = _isUsdcAuction\n            ? 6\n            : vaultParams.decimals;\n        auctionDetails.oTokenPremium = currOtokenPremium;\n        auctionDetails.duration = auctionDuration;\n\n        optionAuctionID = VaultLifecycle.startAuction(auctionDetails);\n    }\n\n    /**\n     * @notice Burn the remaining oTokens left over from gnosis auction.\n     */\n    function burnRemainingOTokens() external onlyKeeper nonReentrant {\n        uint256 unlockedAssetAmount =\n            VaultLifecycle.burnOtokens(\n                GAMMA_CONTROLLER,\n                optionState.currentOption\n            );\n\n        vaultState.lockedAmount = uint104(\n            uint256(vaultState.lockedAmount).sub(unlockedAssetAmount)\n        );\n    }\n\n    /**\n     * @notice Settle USDC auction and swap the proceeds to underlying asset\n     * @param minAmountOut is the minimum amount of underlying acceptable for the swap\n     */\n    function settleAuctionAndSwap(uint256 minAmountOut)\n        external\n        onlyKeeper\n        nonReentrant\n    {\n        require(isUsdcAuction, \"!isUsdcAuction\");\n        require(minAmountOut > 0, \"!minAmountOut\");\n\n        VaultLifecycle.settleAuction(GNOSIS_EASY_AUCTION, optionAuctionID);\n\n        VaultLifecycle.swap(USDC, minAmountOut, UNISWAP_ROUTER, swapPath);\n    }\n}\n"
    },
    "contracts/storage/RibbonThetaVaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nabstract contract RibbonThetaVaultStorageV1 {\n    // Logic contract used to price options\n    address public optionsPremiumPricer;\n    // Logic contract used to select strike prices\n    address public strikeSelection;\n    // Premium discount on options we are selling (thousandths place: 000 - 999)\n    uint256 public premiumDiscount;\n    // Current oToken premium\n    uint256 public currentOtokenPremium;\n    // Last round id at which the strike was manually overridden\n    uint16 public lastStrikeOverrideRound;\n    // Price last overridden strike set to\n    uint256 public overriddenStrikePrice;\n    // Auction duration\n    uint256 public auctionDuration;\n    // Auction id of current option\n    uint256 public optionAuctionID;\n}\n\nabstract contract RibbonThetaVaultStorageV2 {\n    // Amount locked for scheduled withdrawals last week;\n    uint256 public lastQueuedWithdrawAmount;\n}\n\nabstract contract RibbonThetaVaultStorageV3 {\n    // Auction will be denominated in USDC if true\n    bool public isUsdcAuction;\n    // Path for swaps\n    bytes public swapPath;\n}\n\n// We are following Compound's method of upgrading new contract implementations\n// When we need to add new storage variables, we create a new version of RibbonThetaVaultStorage\n// e.g. RibbonThetaVaultStorage<versionNumber>, so finally it would look like\n// contract RibbonThetaVaultStorage is RibbonThetaVaultStorageV1, RibbonThetaVaultStorageV2\nabstract contract RibbonThetaVaultStorage is\n    RibbonThetaVaultStorageV1,\n    RibbonThetaVaultStorageV2,\n    RibbonThetaVaultStorageV3\n{\n\n}\n"
    },
    "contracts/vaults/BaseVaults/base/RibbonVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {\n    ReentrancyGuardUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport {\n    OwnableUpgradeable\n} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport {\n    ERC20Upgradeable\n} from \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\nimport {Vault} from \"../../../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../../../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../../../libraries/ShareMath.sol\";\nimport {IWETH} from \"../../../interfaces/IWETH.sol\";\n\ncontract RibbonVault is\n    ReentrancyGuardUpgradeable,\n    OwnableUpgradeable,\n    ERC20Upgradeable\n{\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  NON UPGRADEABLE STORAGE\n     ***********************************************/\n\n    /// @notice Stores the user's pending deposit for the round\n    mapping(address => Vault.DepositReceipt) public depositReceipts;\n\n    /// @notice On every round's close, the pricePerShare value of an rTHETA token is stored\n    /// This is used to determine the number of shares to be returned\n    /// to a user with their DepositReceipt.depositAmount\n    mapping(uint256 => uint256) public roundPricePerShare;\n\n    /// @notice Stores pending user withdrawals\n    mapping(address => Vault.Withdrawal) public withdrawals;\n\n    /// @notice Vault's parameters like cap, decimals\n    Vault.VaultParams public vaultParams;\n\n    /// @notice Vault's lifecycle state like round and locked amounts\n    Vault.VaultState public vaultState;\n\n    /// @notice Vault's state of the options sold and the timelocked option\n    Vault.OptionState public optionState;\n\n    /// @notice Fee recipient for the performance and management fees\n    address public feeRecipient;\n\n    /// @notice role in charge of weekly vault operations such as rollToNextOption and burnRemainingOTokens\n    // no access to critical vault changes\n    address public keeper;\n\n    /// @notice Performance fee charged on premiums earned in rollToNextOption. Only charged when there is no loss.\n    uint256 public performanceFee;\n\n    /// @notice Management fee charged on entire AUM in rollToNextOption. Only charged when there is no loss.\n    uint256 public managementFee;\n\n    // Gap is left to avoid storage collisions. Though RibbonVault is not upgradeable, we add this as a safety measure.\n    uint256[30] private ____gap;\n\n    // *IMPORTANT* NO NEW STORAGE VARIABLES SHOULD BE ADDED HERE\n    // This is to prevent storage collisions. All storage variables should be appended to RibbonThetaVaultStorage\n    // or RibbonDeltaVaultStorage instead. Read this documentation to learn more:\n    // https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#modifying-your-contracts\n\n    /************************************************\n     *  IMMUTABLES & CONSTANTS\n     ***********************************************/\n\n    /// @notice WETH9 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2\n    address public immutable WETH;\n\n    /// @notice USDC 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n    address public immutable USDC;\n\n    /// @notice Deprecated: 15 minute timelock between commitAndClose and rollToNexOption.\n    uint256 public constant DELAY = 0;\n\n    /// @notice 7 day period between each options sale.\n    uint256 public constant PERIOD = 7 days;\n\n    // Number of weeks per year = 52.142857 weeks * FEE_MULTIPLIER = 52142857\n    // Dividing by weeks per year requires doing num.mul(FEE_MULTIPLIER).div(WEEKS_PER_YEAR)\n    uint256 private constant WEEKS_PER_YEAR = 52142857;\n\n    // GAMMA_CONTROLLER is the top-level contract in Gamma protocol\n    // which allows users to perform multiple actions on their vaults\n    // and positions https://github.com/opynfinance/GammaProtocol/blob/master/contracts/core/Controller.sol\n    address public immutable GAMMA_CONTROLLER;\n\n    // MARGIN_POOL is Gamma protocol's collateral pool.\n    // Needed to approve collateral.safeTransferFrom for minting otokens.\n    // https://github.com/opynfinance/GammaProtocol/blob/master/contracts/core/MarginPool.sol\n    address public immutable MARGIN_POOL;\n\n    // GNOSIS_EASY_AUCTION is Gnosis protocol's contract for initiating auctions and placing bids\n    // https://github.com/gnosis/ido-contracts/blob/main/contracts/EasyAuction.sol\n    address public immutable GNOSIS_EASY_AUCTION;\n\n    // UNISWAP_ROUTER is the contract address of UniswapV3 Router which handles swaps\n    // https://github.com/Uniswap/v3-periphery/blob/main/contracts/interfaces/ISwapRouter.sol\n    address public immutable UNISWAP_ROUTER;\n\n    // UNISWAP_FACTORY is the contract address of UniswapV3 Factory which stores pool information\n    // https://github.com/Uniswap/v3-core/blob/main/contracts/interfaces/IUniswapV3Factory.sol\n    address public immutable UNISWAP_FACTORY;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event Deposit(address indexed account, uint256 amount, uint256 round);\n\n    event InitiateWithdraw(\n        address indexed account,\n        uint256 shares,\n        uint256 round\n    );\n\n    event Redeem(address indexed account, uint256 share, uint256 round);\n\n    event ManagementFeeSet(uint256 managementFee, uint256 newManagementFee);\n\n    event PerformanceFeeSet(uint256 performanceFee, uint256 newPerformanceFee);\n\n    event CapSet(uint256 oldCap, uint256 newCap);\n\n    event Withdraw(address indexed account, uint256 amount, uint256 shares);\n\n    event CollectVaultFees(\n        uint256 performanceFee,\n        uint256 vaultFee,\n        uint256 round,\n        address indexed feeRecipient\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     * @param _uniswapRouter is the contract address for UniswapV3 router which handles swaps\n     * @param _uniswapFactory is the contract address for UniswapV3 factory\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction,\n        address _uniswapRouter,\n        address _uniswapFactory\n    ) {\n        require(_weth != address(0), \"!_weth\");\n        require(_usdc != address(0), \"!_usdc\");\n        require(_gnosisEasyAuction != address(0), \"!_gnosisEasyAuction\");\n        require(_gammaController != address(0), \"!_gammaController\");\n        require(_marginPool != address(0), \"!_marginPool\");\n        require(_uniswapRouter != address(0), \"!_uniswapRouter\");\n        require(_uniswapFactory != address(0), \"!_uniswapFactory\");\n\n        WETH = _weth;\n        USDC = _usdc;\n        GAMMA_CONTROLLER = _gammaController;\n        MARGIN_POOL = _marginPool;\n        GNOSIS_EASY_AUCTION = _gnosisEasyAuction;\n        UNISWAP_ROUTER = _uniswapRouter;\n        UNISWAP_FACTORY = _uniswapFactory;\n    }\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     */\n    function baseInitialize(\n        address _owner,\n        address _keeper,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        Vault.VaultParams calldata _vaultParams\n    ) internal initializer {\n        VaultLifecycle.verifyInitializerParams(\n            _owner,\n            _keeper,\n            _feeRecipient,\n            _performanceFee,\n            _managementFee,\n            _tokenName,\n            _tokenSymbol,\n            _vaultParams\n        );\n\n        __ReentrancyGuard_init();\n        __ERC20_init(_tokenName, _tokenSymbol);\n        __Ownable_init();\n        transferOwnership(_owner);\n\n        keeper = _keeper;\n\n        feeRecipient = _feeRecipient;\n        performanceFee = _performanceFee;\n        managementFee = _managementFee.mul(Vault.FEE_MULTIPLIER).div(\n            WEEKS_PER_YEAR\n        );\n        vaultParams = _vaultParams;\n\n        uint256 assetBalance =\n            IERC20(vaultParams.asset).balanceOf(address(this));\n        ShareMath.assertUint104(assetBalance);\n        vaultState.lastLockedAmount = uint104(assetBalance);\n\n        vaultState.round = 1;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the keeper.\n     */\n    modifier onlyKeeper() {\n        require(msg.sender == keeper, \"!keeper\");\n        _;\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new keeper\n     * @param newKeeper is the address of the new keeper\n     */\n    function setNewKeeper(address newKeeper) external onlyOwner {\n        require(newKeeper != address(0), \"!newKeeper\");\n        keeper = newKeeper;\n    }\n\n    /**\n     * @notice Sets the new fee recipient\n     * @param newFeeRecipient is the address of the new fee recipient\n     */\n    function setFeeRecipient(address newFeeRecipient) external onlyOwner {\n        require(newFeeRecipient != address(0), \"!newFeeRecipient\");\n        require(newFeeRecipient != feeRecipient, \"Must be new feeRecipient\");\n        feeRecipient = newFeeRecipient;\n    }\n\n    /**\n     * @notice Sets the management fee for the vault\n     * @param newManagementFee is the management fee (6 decimals). ex: 2 * 10 ** 6 = 2%\n     */\n    function setManagementFee(uint256 newManagementFee) external onlyOwner {\n        require(\n            newManagementFee < 100 * Vault.FEE_MULTIPLIER,\n            \"Invalid management fee\"\n        );\n\n        // We are dividing annualized management fee by num weeks in a year\n        uint256 tmpManagementFee =\n            newManagementFee.mul(Vault.FEE_MULTIPLIER).div(WEEKS_PER_YEAR);\n\n        emit ManagementFeeSet(managementFee, newManagementFee);\n\n        managementFee = tmpManagementFee;\n    }\n\n    /**\n     * @notice Sets the performance fee for the vault\n     * @param newPerformanceFee is the performance fee (6 decimals). ex: 20 * 10 ** 6 = 20%\n     */\n    function setPerformanceFee(uint256 newPerformanceFee) external onlyOwner {\n        require(\n            newPerformanceFee < 100 * Vault.FEE_MULTIPLIER,\n            \"Invalid performance fee\"\n        );\n\n        emit PerformanceFeeSet(performanceFee, newPerformanceFee);\n\n        performanceFee = newPerformanceFee;\n    }\n\n    /**\n     * @notice Sets a new cap for deposits\n     * @param newCap is the new cap for deposits\n     */\n    function setCap(uint256 newCap) external onlyOwner {\n        require(newCap > 0, \"!newCap\");\n        ShareMath.assertUint104(newCap);\n        emit CapSet(vaultParams.cap, newCap);\n        vaultParams.cap = uint104(newCap);\n    }\n\n    /************************************************\n     *  DEPOSIT & WITHDRAWALS\n     ***********************************************/\n\n    /**\n     * @notice Deposits ETH into the contract and mint vault shares. Reverts if the asset is not WETH.\n     */\n    function depositETH() external payable nonReentrant {\n        require(vaultParams.asset == WETH, \"!WETH\");\n        require(msg.value > 0, \"!value\");\n\n        _depositFor(msg.value, msg.sender);\n\n        IWETH(WETH).deposit{value: msg.value}();\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender.\n     * @param amount is the amount of `asset` to deposit\n     */\n    function deposit(uint256 amount) external nonReentrant {\n        require(amount > 0, \"!amount\");\n\n        _depositFor(amount, msg.sender);\n\n        // An approve() by the msg.sender is required beforehand\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Deposits the `asset` from msg.sender added to `creditor`'s deposit.\n     * @notice Used for vault -> vault deposits on the user's behalf\n     * @param amount is the amount of `asset` to deposit\n     * @param creditor is the address that can claim/withdraw deposited amount\n     */\n    function depositFor(uint256 amount, address creditor)\n        external\n        nonReentrant\n    {\n        require(amount > 0, \"!amount\");\n        require(creditor != address(0));\n\n        _depositFor(amount, creditor);\n\n        // An approve() by the msg.sender is required beforehand\n        IERC20(vaultParams.asset).safeTransferFrom(\n            msg.sender,\n            address(this),\n            amount\n        );\n    }\n\n    /**\n     * @notice Mints the vault shares to the creditor\n     * @param amount is the amount of `asset` deposited\n     * @param creditor is the address to receieve the deposit\n     */\n    function _depositFor(uint256 amount, address creditor) private {\n        uint256 currentRound = vaultState.round;\n        uint256 totalWithDepositedAmount = totalBalance().add(amount);\n\n        require(totalWithDepositedAmount <= vaultParams.cap, \"Exceed cap\");\n        require(\n            totalWithDepositedAmount >= vaultParams.minimumSupply,\n            \"Insufficient balance\"\n        );\n\n        emit Deposit(creditor, amount, currentRound);\n\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[creditor];\n\n        // If we have an unprocessed pending deposit from the previous rounds, we have to process it.\n        uint256 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        uint256 depositAmount = amount;\n\n        // If we have a pending deposit in the current round, we add on to the pending deposit\n        if (currentRound == depositReceipt.round) {\n            uint256 newAmount = uint256(depositReceipt.amount).add(amount);\n            depositAmount = newAmount;\n        }\n\n        ShareMath.assertUint104(depositAmount);\n\n        depositReceipts[creditor] = Vault.DepositReceipt({\n            round: uint16(currentRound),\n            amount: uint104(depositAmount),\n            unredeemedShares: uint128(unredeemedShares)\n        });\n\n        uint256 newTotalPending = uint256(vaultState.totalPending).add(amount);\n        ShareMath.assertUint128(newTotalPending);\n\n        vaultState.totalPending = uint128(newTotalPending);\n    }\n\n    /**\n     * @notice Initiates a withdrawal that can be processed once the round completes\n     * @param numShares is the number of shares to withdraw\n     */\n    function initiateWithdraw(uint256 numShares) external nonReentrant {\n        require(numShares > 0, \"!numShares\");\n\n        // We do a max redeem before initiating a withdrawal\n        // But we check if they must first have unredeemed shares\n        if (\n            depositReceipts[msg.sender].amount > 0 ||\n            depositReceipts[msg.sender].unredeemedShares > 0\n        ) {\n            _redeem(0, true);\n        }\n\n        // This caches the `round` variable used in shareBalances\n        uint256 currentRound = vaultState.round;\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        bool withdrawalIsSameRound = withdrawal.round == currentRound;\n\n        emit InitiateWithdraw(msg.sender, numShares, currentRound);\n\n        uint256 existingShares = uint256(withdrawal.shares);\n\n        uint256 withdrawalShares;\n        if (withdrawalIsSameRound) {\n            withdrawalShares = existingShares.add(numShares);\n        } else {\n            require(existingShares == 0, \"Existing withdraw\");\n            withdrawalShares = numShares;\n            withdrawals[msg.sender].round = uint16(currentRound);\n        }\n\n        ShareMath.assertUint128(withdrawalShares);\n        withdrawals[msg.sender].shares = uint128(withdrawalShares);\n\n        uint256 newQueuedWithdrawShares =\n            uint256(vaultState.queuedWithdrawShares).add(numShares);\n        ShareMath.assertUint128(newQueuedWithdrawShares);\n        vaultState.queuedWithdrawShares = uint128(newQueuedWithdrawShares);\n\n        _transfer(msg.sender, address(this), numShares);\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     * @return withdrawAmount the current withdrawal amount\n     */\n    function _completeWithdraw() internal returns (uint256) {\n        Vault.Withdrawal storage withdrawal = withdrawals[msg.sender];\n\n        uint256 withdrawalShares = withdrawal.shares;\n        uint256 withdrawalRound = withdrawal.round;\n\n        // This checks if there is a withdrawal\n        require(withdrawalShares > 0, \"Not initiated\");\n\n        require(withdrawalRound < vaultState.round, \"Round not closed\");\n\n        // We leave the round number as non-zero to save on gas for subsequent writes\n        withdrawals[msg.sender].shares = 0;\n        vaultState.queuedWithdrawShares = uint128(\n            uint256(vaultState.queuedWithdrawShares).sub(withdrawalShares)\n        );\n\n        uint256 withdrawAmount =\n            ShareMath.sharesToAsset(\n                withdrawalShares,\n                roundPricePerShare[withdrawalRound],\n                vaultParams.decimals\n            );\n\n        emit Withdraw(msg.sender, withdrawAmount, withdrawalShares);\n\n        _burn(address(this), withdrawalShares);\n\n        require(withdrawAmount > 0, \"!withdrawAmount\");\n        transferAsset(msg.sender, withdrawAmount);\n\n        return withdrawAmount;\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem\n     */\n    function redeem(uint256 numShares) external nonReentrant {\n        require(numShares > 0, \"!numShares\");\n        _redeem(numShares, false);\n    }\n\n    /**\n     * @notice Redeems the entire unredeemedShares balance that is owed to the account\n     */\n    function maxRedeem() external nonReentrant {\n        _redeem(0, true);\n    }\n\n    /**\n     * @notice Redeems shares that are owed to the account\n     * @param numShares is the number of shares to redeem, could be 0 when isMax=true\n     * @param isMax is flag for when callers do a max redemption\n     */\n    function _redeem(uint256 numShares, bool isMax) internal {\n        Vault.DepositReceipt memory depositReceipt =\n            depositReceipts[msg.sender];\n\n        // This handles the null case when depositReceipt.round = 0\n        // Because we start with round = 1 at `initialize`\n        uint256 currentRound = vaultState.round;\n\n        uint256 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                currentRound,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        numShares = isMax ? unredeemedShares : numShares;\n        if (numShares == 0) {\n            return;\n        }\n        require(numShares <= unredeemedShares, \"Exceeds available\");\n\n        // If we have a depositReceipt on the same round, BUT we have some unredeemed shares\n        // we debit from the unredeemedShares, but leave the amount field intact\n        // If the round has past, with no new deposits, we just zero it out for new deposits.\n        if (depositReceipt.round < currentRound) {\n            depositReceipts[msg.sender].amount = 0;\n        }\n\n        ShareMath.assertUint128(numShares);\n        depositReceipts[msg.sender].unredeemedShares = uint128(\n            unredeemedShares.sub(numShares)\n        );\n\n        emit Redeem(msg.sender, numShares, depositReceipt.round);\n\n        _transfer(address(this), msg.sender, numShares);\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /*\n     * @notice Helper function that helps to save gas for writing values into the roundPricePerShare map.\n     *         Writing `1` into the map makes subsequent writes warm, reducing the gas from 20k to 5k.\n     *         Having 1 initialized beforehand will not be an issue as long as we round down share calculations to 0.\n     * @param numRounds is the number of rounds to initialize in the map\n     */\n    function initRounds(uint256 numRounds) external nonReentrant {\n        require(numRounds > 0, \"!numRounds\");\n\n        uint256 _round = vaultState.round;\n        for (uint256 i = 0; i < numRounds; i++) {\n            uint256 index = _round + i;\n            require(roundPricePerShare[index] == 0, \"Initialized\"); // AVOID OVERWRITING ACTUAL VALUES\n            roundPricePerShare[index] = ShareMath.PLACEHOLDER_UINT;\n        }\n    }\n\n    /*\n     * @notice Helper function that performs most administrative tasks\n     * such as setting next option, minting new shares, getting vault fees, etc.\n     * @param lastQueuedWithdrawAmount is old queued withdraw amount\n     * @return newOption is the new option address\n     * @return lockedBalance is the new balance used to calculate next option purchase size or collateral size\n     * @return queuedWithdrawAmount is the new queued withdraw amount for this round\n     */\n    function _rollToNextOption(uint256 lastQueuedWithdrawAmount)\n        internal\n        returns (\n            address newOption,\n            uint256 lockedBalance,\n            uint256 queuedWithdrawAmount\n        )\n    {\n        require(block.timestamp >= optionState.nextOptionReadyAt, \"!ready\");\n\n        newOption = optionState.nextOption;\n        require(newOption != address(0), \"!nextOption\");\n\n        address recipient = feeRecipient;\n        uint256 mintShares;\n        uint256 performanceFeeInAsset;\n        uint256 totalVaultFee;\n        {\n            uint256 newPricePerShare;\n            (\n                lockedBalance,\n                queuedWithdrawAmount,\n                newPricePerShare,\n                mintShares,\n                performanceFeeInAsset,\n                totalVaultFee\n            ) = VaultLifecycle.rollover(\n                vaultState,\n                VaultLifecycle.RolloverParams(\n                    vaultParams.decimals,\n                    IERC20(vaultParams.asset).balanceOf(address(this)),\n                    totalSupply(),\n                    lastQueuedWithdrawAmount,\n                    performanceFee,\n                    managementFee\n                )\n            );\n\n            optionState.currentOption = newOption;\n            optionState.nextOption = address(0);\n\n            // Finalize the pricePerShare at the end of the round\n            uint256 currentRound = vaultState.round;\n            roundPricePerShare[currentRound] = newPricePerShare;\n\n            emit CollectVaultFees(\n                performanceFeeInAsset,\n                totalVaultFee,\n                currentRound,\n                recipient\n            );\n\n            vaultState.totalPending = 0;\n            vaultState.round = uint16(currentRound + 1);\n        }\n\n        _mint(address(this), mintShares);\n\n        if (totalVaultFee > 0) {\n            transferAsset(payable(recipient), totalVaultFee);\n        }\n\n        return (newOption, lockedBalance, queuedWithdrawAmount);\n    }\n\n    /**\n     * @notice Helper function to make either an ETH transfer or ERC20 transfer\n     * @param recipient is the receiving address\n     * @param amount is the transfer amount\n     */\n    function transferAsset(address recipient, uint256 amount) internal {\n        address asset = vaultParams.asset;\n        if (asset == WETH) {\n            IWETH(WETH).withdraw(amount);\n            (bool success, ) = recipient.call{value: amount}(\"\");\n            require(success, \"Transfer failed\");\n            return;\n        }\n        IERC20(asset).safeTransfer(recipient, amount);\n    }\n\n    /************************************************\n     *  GETTERS\n     ***********************************************/\n\n    /**\n     * @notice Returns the asset balance held on the vault for the account\n     * @param account is the address to lookup balance for\n     * @return the amount of `asset` custodied by the vault for the user\n     */\n    function accountVaultBalance(address account)\n        external\n        view\n        returns (uint256)\n    {\n        uint256 _decimals = vaultParams.decimals;\n        uint256 assetPerShare =\n            ShareMath.pricePerShare(\n                totalSupply(),\n                totalBalance(),\n                vaultState.totalPending,\n                _decimals\n            );\n        return\n            ShareMath.sharesToAsset(shares(account), assetPerShare, _decimals);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance including unredeemed shares\n     * @param account is the account to lookup share balance for\n     * @return the share balance\n     */\n    function shares(address account) public view returns (uint256) {\n        (uint256 heldByAccount, uint256 heldByVault) = shareBalances(account);\n        return heldByAccount.add(heldByVault);\n    }\n\n    /**\n     * @notice Getter for returning the account's share balance split between account and vault holdings\n     * @param account is the account to lookup share balance for\n     * @return heldByAccount is the shares held by account\n     * @return heldByVault is the shares held on the vault (unredeemedShares)\n     */\n    function shareBalances(address account)\n        public\n        view\n        returns (uint256 heldByAccount, uint256 heldByVault)\n    {\n        Vault.DepositReceipt memory depositReceipt = depositReceipts[account];\n\n        if (depositReceipt.round < ShareMath.PLACEHOLDER_UINT) {\n            return (balanceOf(account), 0);\n        }\n\n        uint256 unredeemedShares =\n            depositReceipt.getSharesFromReceipt(\n                vaultState.round,\n                roundPricePerShare[depositReceipt.round],\n                vaultParams.decimals\n            );\n\n        return (balanceOf(account), unredeemedShares);\n    }\n\n    /**\n     * @notice The price of a unit of share denominated in the `asset`\n     */\n    function pricePerShare() external view returns (uint256) {\n        return\n            ShareMath.pricePerShare(\n                totalSupply(),\n                totalBalance(),\n                vaultState.totalPending,\n                vaultParams.decimals\n            );\n    }\n\n    /**\n     * @notice Returns the vault's total balance, including the amounts locked into a short position\n     * @return total balance of the vault, including the amounts locked in third party protocols\n     */\n    function totalBalance() public view returns (uint256) {\n        return\n            uint256(vaultState.lockedAmount).add(\n                IERC20(vaultParams.asset).balanceOf(address(this))\n            );\n    }\n\n    /**\n     * @notice Returns the token decimals\n     */\n    function decimals() public view override returns (uint8) {\n        return vaultParams.decimals;\n    }\n\n    function cap() external view returns (uint256) {\n        return vaultParams.cap;\n    }\n\n    function nextOptionReadyAt() external view returns (uint256) {\n        return optionState.nextOptionReadyAt;\n    }\n\n    function currentOption() external view returns (address) {\n        return optionState.currentOption;\n    }\n\n    function nextOption() external view returns (address) {\n        return optionState.nextOption;\n    }\n\n    function totalPending() external view returns (uint256) {\n        return vaultState.totalPending;\n    }\n\n    /************************************************\n     *  HELPERS\n     ***********************************************/\n\n    /**\n     * @notice Helper to check whether swap path goes from stables (USDC) to vault's underlying asset\n     * @param swapPath is the swap path e.g. encodePacked(tokenIn, poolFee, tokenOut)\n     * @return boolean whether the path is valid\n     */\n    function _checkPath(bytes calldata swapPath) internal view returns (bool) {\n        return\n            VaultLifecycle.checkPath(\n                swapPath,\n                USDC,\n                vaultParams.asset,\n                UNISWAP_FACTORY\n            );\n    }\n}\n"
    },
    "contracts/vaults/BaseVaults/RibbonDeltaVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport {GnosisAuction} from \"../../libraries/GnosisAuction.sol\";\nimport {\n    RibbonDeltaVaultStorage\n} from \"../../storage/RibbonDeltaVaultStorage.sol\";\nimport {Vault} from \"../../libraries/Vault.sol\";\nimport {VaultLifecycle} from \"../../libraries/VaultLifecycle.sol\";\nimport {ShareMath} from \"../../libraries/ShareMath.sol\";\nimport {RibbonVault} from \"./base/RibbonVault.sol\";\nimport {IRibbonThetaVault} from \"../../interfaces/IRibbonThetaVault.sol\";\n\n/**\n * UPGRADEABILITY: Since we use the upgradeable proxy pattern, we must observe\n * the inheritance chain closely.\n * Any changes/appends in storage variable needs to happen in RibbonDeltaVaultStorage.\n * RibbonDeltaVault should not inherit from any other contract aside from RibbonVault, RibbonDeltaVaultStorage\n */\ncontract RibbonDeltaVault is RibbonVault, RibbonDeltaVaultStorage {\n    using SafeMath for uint256;\n    using ShareMath for Vault.DepositReceipt;\n\n    /************************************************\n     *  EVENTS\n     ***********************************************/\n\n    event OpenLong(\n        address indexed options,\n        uint256 purchaseAmount,\n        uint256 premium,\n        address indexed manager\n    );\n\n    event CloseLong(\n        address indexed options,\n        uint256 profitAmount,\n        address indexed manager\n    );\n\n    event NewOptionAllocationSet(\n        uint256 optionAllocation,\n        uint256 newOptionAllocation\n    );\n\n    event InstantWithdraw(\n        address indexed account,\n        uint256 share,\n        uint256 round\n    );\n\n    event PlaceAuctionBid(\n        uint256 auctionId,\n        address indexed auctioningToken,\n        uint256 sellAmount,\n        uint256 buyAmount,\n        address indexed bidder\n    );\n\n    /************************************************\n     *  CONSTRUCTOR & INITIALIZATION\n     ***********************************************/\n\n    /**\n     * @notice Initializes the contract with immutable variables\n     * @param _weth is the Wrapped Ether contract\n     * @param _usdc is the USDC contract\n     * @param _gammaController is the contract address for opyn actions\n     * @param _marginPool is the contract address for providing collateral to opyn\n     * @param _gnosisEasyAuction is the contract address that facilitates gnosis auctions\n     * @param _uniswapRouter is the contract address of UniswapV3 router that handles swaps\n     * @param _uniswapFactory is the contract address of UniswapV3 factory containing\n     pools information\n     */\n    constructor(\n        address _weth,\n        address _usdc,\n        address _gammaController,\n        address _marginPool,\n        address _gnosisEasyAuction,\n        address _uniswapRouter,\n        address _uniswapFactory\n    )\n        RibbonVault(\n            _weth,\n            _usdc,\n            _gammaController,\n            _marginPool,\n            _gnosisEasyAuction,\n            _uniswapRouter,\n            _uniswapFactory\n        )\n    {}\n\n    /**\n     * @notice Initializes the OptionVault contract with storage variables.\n     * @param _owner is the owner of the vault with critical permissions\n     * @param _feeRecipient is the address to recieve vault performance and management fees\n     * @param _managementFee is the management fee pct.\n     * @param _performanceFee is the perfomance fee pct.\n     * @param _tokenName is the name of the token\n     * @param _tokenSymbol is the symbol of the token\n     * @param _counterpartyThetaVault is the address of the counterparty theta\n     vault of this delta vault\n     * @param _optionAllocation is the pct of the funds to allocate towards the weekly option\n     * @param _vaultParams is the struct with vault general data\n     */\n    function initialize(\n        address _owner,\n        address _keeper,\n        address _feeRecipient,\n        uint256 _managementFee,\n        uint256 _performanceFee,\n        string memory _tokenName,\n        string memory _tokenSymbol,\n        address _counterpartyThetaVault,\n        uint256 _optionAllocation,\n        Vault.VaultParams calldata _vaultParams\n    ) external initializer {\n        baseInitialize(\n            _owner,\n            _keeper,\n            _feeRecipient,\n            _managementFee,\n            _performanceFee,\n            _tokenName,\n            _tokenSymbol,\n            _vaultParams\n        );\n        require(\n            _counterpartyThetaVault != address(0),\n            \"!_counterpartyThetaVault\"\n        );\n        require(\n            IRibbonThetaVault(_counterpartyThetaVault).vaultParams().asset ==\n                vaultParams.asset,\n            \"!_counterpartyThetaVault: asset\"\n        );\n        // 1000 = 10%. Needs to be less than 10% of the funds allocated to option.\n        require(\n            _optionAllocation > 0 &&\n                _optionAllocation < 10 * Vault.OPTION_ALLOCATION_MULTIPLIER,\n            \"!_optionAllocation\"\n        );\n        counterpartyThetaVault = IRibbonThetaVault(_counterpartyThetaVault);\n        optionAllocation = _optionAllocation;\n    }\n\n    /**\n     * @notice Updates the price per share of the current round. The current round\n     * pps will change right after call rollToNextOption as the gnosis auction contract\n     * takes custody of a % of `asset` tokens, and right after we claim the tokens from\n     * the action as we may recieve some of `asset` tokens back alongside the oToken,\n     * depending on the gnosis auction outcome. Finally it will change at the end of the week\n     * if the oTokens are ITM\n     */\n    function updatePPS(bool isWithdraw) internal {\n        uint256 currentRound = vaultState.round;\n        if (\n            !isWithdraw ||\n            roundPricePerShare[currentRound] <= ShareMath.PLACEHOLDER_UINT\n        ) {\n            roundPricePerShare[currentRound] = ShareMath.pricePerShare(\n                totalSupply(),\n                IERC20(vaultParams.asset).balanceOf(address(this)),\n                vaultState.totalPending,\n                vaultParams.decimals\n            );\n        }\n    }\n\n    /************************************************\n     *  SETTERS\n     ***********************************************/\n\n    /**\n     * @notice Sets the new % allocation of funds towards options purchases (2 decimals. ex: 10 * 10**2 is 10%)\n     * 0 < newOptionAllocation < 1000. 1000 = 10%.\n     * @param newOptionAllocation is the option % allocation\n     */\n    function setOptionAllocation(uint16 newOptionAllocation)\n        external\n        onlyOwner\n    {\n        // Needs to be less than 10%\n        require(\n            newOptionAllocation > 0 &&\n                newOptionAllocation < 10 * Vault.OPTION_ALLOCATION_MULTIPLIER,\n            \"Invalid allocation\"\n        );\n\n        emit NewOptionAllocationSet(optionAllocation, newOptionAllocation);\n\n        optionAllocation = newOptionAllocation;\n    }\n\n    /************************************************\n     *  VAULT OPERATIONS\n     ***********************************************/\n\n    /**\n     * @notice Withdraws the assets on the vault using the outstanding `DepositReceipt.amount`\n     * @param share is the amount of shares to withdraw\n     */\n    function withdrawInstantly(uint256 share) external nonReentrant {\n        require(share > 0, \"!numShares\");\n\n        updatePPS(true);\n\n        (uint256 sharesToWithdrawFromPending, uint256 sharesLeftForWithdrawal) =\n            _withdrawFromNewDeposit(share);\n\n        // Withdraw shares from pending amount\n        if (sharesToWithdrawFromPending > 0) {\n            vaultState.totalPending = uint128(\n                uint256(vaultState.totalPending).sub(\n                    sharesToWithdrawFromPending\n                )\n            );\n        }\n        uint256 currentRound = vaultState.round;\n\n        // If we need to withdraw beyond current round deposit\n        if (sharesLeftForWithdrawal > 0) {\n            (uint256 heldByAccount, uint256 heldByVault) =\n                shareBalances(msg.sender);\n\n            require(\n                sharesLeftForWithdrawal <= heldByAccount.add(heldByVault),\n                \"Insufficient balance\"\n            );\n\n            if (heldByAccount < sharesLeftForWithdrawal) {\n                // Redeem all shares custodied by vault to user\n                _redeem(0, true);\n            }\n\n            // Burn shares\n            _burn(msg.sender, sharesLeftForWithdrawal);\n        }\n\n        emit InstantWithdraw(msg.sender, share, currentRound);\n\n        uint256 withdrawAmount =\n            ShareMath.sharesToAsset(\n                share,\n                roundPricePerShare[currentRound],\n                vaultParams.decimals\n            );\n        transferAsset(msg.sender, withdrawAmount);\n    }\n\n    /**\n     * @notice Completes a scheduled withdrawal from a past round. Uses finalized pps for the round\n     */\n    function completeWithdraw() external nonReentrant {\n        uint256 withdrawAmount = _completeWithdraw();\n        lastQueuedWithdrawAmount = uint128(\n            uint256(lastQueuedWithdrawAmount).sub(withdrawAmount)\n        );\n    }\n\n    /**\n     * @notice Closes the existing long position for the vault.\n     *         This allows all the users to withdraw if the next option is malicious.\n     */\n    function commitAndClose() external nonReentrant {\n        address oldOption = optionState.currentOption;\n\n        address counterpartyNextOption =\n            counterpartyThetaVault.optionState().nextOption;\n        require(counterpartyNextOption != address(0), \"!thetavaultclosed\");\n\n        updatePPS(true);\n\n        optionState.nextOption = counterpartyNextOption;\n\n        uint256 nextOptionReady = block.timestamp.add(DELAY);\n        require(\n            nextOptionReady <= type(uint32).max,\n            \"Overflow nextOptionReady\"\n        );\n        optionState.nextOptionReadyAt = uint32(nextOptionReady);\n\n        optionState.currentOption = address(0);\n        vaultState.lastLockedAmount = uint104(balanceBeforePremium);\n\n        // redeem\n        if (oldOption != address(0)) {\n            uint256 profitAmount =\n                VaultLifecycle.settleLong(\n                    GAMMA_CONTROLLER,\n                    oldOption,\n                    vaultParams.asset\n                );\n            emit CloseLong(oldOption, profitAmount, msg.sender);\n        }\n    }\n\n    /**\n     * @notice Rolls the vault's funds into a new long position.\n     * @param optionPremium is the premium per token to pay in `asset`.\n       Same decimals as `asset` (ex: 1 * 10 ** 8 means 1 WBTC per oToken)\n     */\n    function rollToNextOption(uint256 optionPremium)\n        external\n        onlyKeeper\n        nonReentrant\n    {\n        (\n            address newOption,\n            uint256 lockedBalance,\n            uint256 queuedWithdrawAmount\n        ) = _rollToNextOption(uint256(lastQueuedWithdrawAmount));\n\n        lastQueuedWithdrawAmount = uint128(queuedWithdrawAmount);\n\n        balanceBeforePremium = lockedBalance;\n\n        GnosisAuction.BidDetails memory bidDetails;\n\n        bidDetails.auctionId = counterpartyThetaVault.optionAuctionID();\n        bidDetails.gnosisEasyAuction = GNOSIS_EASY_AUCTION;\n        bidDetails.oTokenAddress = newOption;\n        bidDetails.asset = vaultParams.asset;\n        bidDetails.assetDecimals = vaultParams.decimals;\n        bidDetails.lockedBalance = lockedBalance;\n        bidDetails.optionAllocation = optionAllocation;\n        bidDetails.optionPremium = optionPremium;\n        bidDetails.bidder = msg.sender;\n\n        // place bid\n        (uint256 sellAmount, uint256 buyAmount, uint64 userId) =\n            VaultLifecycle.placeBid(bidDetails);\n\n        auctionSellOrder.sellAmount = uint96(sellAmount);\n        auctionSellOrder.buyAmount = uint96(buyAmount);\n        auctionSellOrder.userId = userId;\n\n        updatePPS(false);\n\n        emit OpenLong(newOption, buyAmount, sellAmount, msg.sender);\n    }\n\n    /**\n     * @notice Claims the delta vault's oTokens from latest auction\n     */\n    function claimAuctionOtokens() external nonReentrant {\n        VaultLifecycle.claimAuctionOtokens(\n            auctionSellOrder,\n            GNOSIS_EASY_AUCTION,\n            address(counterpartyThetaVault)\n        );\n        updatePPS(false);\n    }\n\n    /**\n     * @notice Withdraws from the most recent deposit which has not been processed\n     * @param share is how many shares to withdraw in total\n     * @return the shares to remove from pending\n     * @return the shares left to withdraw\n     */\n    function _withdrawFromNewDeposit(uint256 share)\n        private\n        returns (uint256, uint256)\n    {\n        Vault.DepositReceipt storage depositReceipt =\n            depositReceipts[msg.sender];\n\n        // Immediately get what is in the pending deposits, without need for checking pps\n        if (\n            depositReceipt.round == vaultState.round &&\n            depositReceipt.amount > 0\n        ) {\n            uint256 receiptShares =\n                ShareMath.assetToShares(\n                    depositReceipt.amount,\n                    roundPricePerShare[depositReceipt.round],\n                    vaultParams.decimals\n                );\n            uint256 sharesWithdrawn = Math.min(receiptShares, share);\n            // Subtraction underflow checks already ensure it is smaller than uint104\n            depositReceipt.amount = uint104(\n                ShareMath.sharesToAsset(\n                    uint256(receiptShares).sub(sharesWithdrawn),\n                    roundPricePerShare[depositReceipt.round],\n                    vaultParams.decimals\n                )\n            );\n            return (sharesWithdrawn, share.sub(sharesWithdrawn));\n        }\n\n        return (0, share);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "contracts/storage/RibbonDeltaVaultStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\nimport {IRibbonThetaVault} from \"../interfaces/IRibbonThetaVault.sol\";\nimport {Vault} from \"../libraries/Vault.sol\";\n\nabstract contract RibbonDeltaVaultStorageV1 {\n    // Ribbon counterparty theta vault\n    IRibbonThetaVault public counterpartyThetaVault;\n    // % of funds to be used for weekly option purchase\n    uint256 public optionAllocation;\n    // Delta vault equivalent of lockedAmount\n    uint256 public balanceBeforePremium;\n    // User Id of delta vault in latest gnosis auction\n    Vault.AuctionSellOrder public auctionSellOrder;\n}\n\nabstract contract RibbonDeltaVaultStorageV2 {\n    // Amount locked for scheduled withdrawals last week;\n    uint128 public lastQueuedWithdrawAmount;\n}\n\n// We are following Compound's method of upgrading new contract implementations\n// When we need to add new storage variables, we create a new version of RibbonDeltaVaultStorage\n// e.g. RibbonDeltaVaultStorage<versionNumber>, so finally it would look like\n// contract RibbonDeltaVaultStorage is RibbonDeltaVaultStorageV1, RibbonDeltaVaultStorageV2\nabstract contract RibbonDeltaVaultStorage is\n    RibbonDeltaVaultStorageV1,\n    RibbonDeltaVaultStorageV2\n{\n\n}\n"
    },
    "contracts/utils/PercentStrikeSelection.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {\n    IPriceOracle\n} from \"@ribbon-finance/rvol/contracts/interfaces/IPriceOracle.sol\";\nimport {IOptionsPremiumPricer} from \"../interfaces/IRibbon.sol\";\nimport {\n    IVolatilityOracle\n} from \"@ribbon-finance/rvol/contracts/interfaces/IVolatilityOracle.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Vault} from \"../libraries/Vault.sol\";\n\ncontract PercentStrikeSelection is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     * Immutables\n     */\n    IOptionsPremiumPricer public immutable optionsPremiumPricer;\n\n    // step in absolute terms at which we will increment\n    // (ex: 100 * 10 ** assetOracleDecimals means we will move at increments of 100 points)\n    uint256 public step;\n\n    // multiplier for strike selection\n    uint256 public strikeMultiplier;\n\n    // multiplier to shift asset prices\n    uint256 private immutable assetOracleMultiplier;\n\n    // Delta are in 4 decimal places. 1 * 10**4 = 1 delta.\n    uint256 private constant DELTA_MULTIPLIER = 10**4;\n\n    // ChainLink's USD Price oracles return results in 8 decimal places\n    uint256 private constant ORACLE_PRICE_MULTIPLIER = 10**8;\n\n    // Strike multiplier has 2 decimal places. For example: 150 = 1.5x spot price\n    uint256 private constant STRIKE_MULTIPLIER = 10**2;\n\n    event StepSet(uint256 oldStep, uint256 newStep, address indexed owner);\n\n    constructor(\n        address _optionsPremiumPricer,\n        uint256 _step,\n        uint256 _strikeMultiplier\n    ) {\n        require(_optionsPremiumPricer != address(0), \"!_optionsPremiumPricer\");\n        require(_step > 0, \"!_step\");\n        require(\n            _strikeMultiplier > STRIKE_MULTIPLIER,\n            \"Multiplier must be bigger than 1!\"\n        );\n        optionsPremiumPricer = IOptionsPremiumPricer(_optionsPremiumPricer);\n\n        // ex: delta = 7500 (.75)\n        uint256 _assetOracleMultiplier =\n            10 **\n                IPriceOracle(\n                    IOptionsPremiumPricer(_optionsPremiumPricer).priceOracle()\n                )\n                    .decimals();\n\n        step = _step;\n\n        strikeMultiplier = _strikeMultiplier;\n\n        assetOracleMultiplier = _assetOracleMultiplier;\n    }\n\n    /**\n     * @notice Gets the strike price by multiplying the current underlying price\n     * with a multiplier\n     * @param expiryTimestamp is the unix timestamp of expiration\n     * @param isPut is whether option is put or call\n     * @return newStrikePrice is the strike price of the option (ex: for BTC might be 45000 * 10 ** 8)\n     * @return newDelta will be set to zero for percent strike selection\n     */\n\n    function getStrikePrice(uint256 expiryTimestamp, bool isPut)\n        external\n        view\n        returns (uint256 newStrikePrice, uint256 newDelta)\n    {\n        require(\n            expiryTimestamp > block.timestamp,\n            \"Expiry must be in the future!\"\n        );\n\n        // asset price\n        uint256 strikePrice =\n            optionsPremiumPricer.getUnderlyingPrice().mul(strikeMultiplier).div(\n                STRIKE_MULTIPLIER\n            );\n\n        newStrikePrice = isPut\n            ? strikePrice.sub(strikePrice % step)\n            : strikePrice.add(step.sub(strikePrice % step));\n\n        newDelta = 0;\n    }\n\n    /**\n     * @notice Set the multiplier for setting the strike price\n     * @param newStrikeMultiplier is the strike multiplier (decimals = 2)\n     */\n    function setStrikeMultiplier(uint256 newStrikeMultiplier)\n        external\n        onlyOwner\n    {\n        require(\n            newStrikeMultiplier > STRIKE_MULTIPLIER,\n            \"Multiplier must be bigger than 1!\"\n        );\n        strikeMultiplier = newStrikeMultiplier;\n    }\n\n    /**\n     * @notice Sets new step value\n     * @param newStep is the new step value\n     */\n    function setStep(uint256 newStep) external onlyOwner {\n        require(newStep > 0, \"!newStep\");\n        uint256 oldStep = step;\n        step = newStep.mul(assetOracleMultiplier);\n        emit StepSet(oldStep, newStep, msg.sender);\n    }\n}\n"
    },
    "@ribbon-finance/rvol/contracts/interfaces/IPriceOracle.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity >0.6.0 <0.8.7;\n\ninterface IPriceOracle {\n    function decimals() external view returns (uint256 _decimals);\n\n    function latestAnswer() external view returns (uint256 price);\n}\n"
    },
    "@ribbon-finance/rvol/contracts/interfaces/IVolatilityOracle.sol": {
      "content": "//SPDX-License-Identifier: GPL-3.0\npragma solidity >0.6.0 <0.8.7;\n\ninterface IVolatilityOracle {\n    function commit(address pool) external;\n\n    function twap(address pool) external returns (uint256 price);\n\n    function vol(address pool)\n        external\n        view\n        returns (uint256 standardDeviation);\n\n    function annualizedVol(address pool)\n        external\n        view\n        returns (uint256 annualStdev);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _setOwner(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _setOwner(newOwner);\n    }\n\n    function _setOwner(address newOwner) private {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/vendor/CustomSafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ERC20} from \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n      require(_callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value)),\n          \"ERC20 transfer failed\");\n  }\n\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n      require(_callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value)),\n          \"ERC20 transferFrom failed\");\n  }\n\n  function safeApprove(IERC20 token, address spender, uint256 value) internal {\n    if (_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value))) {\n        return;\n    }\n    require(_callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0))\n        && _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)),\n        \"ERC20 approve failed\");\n  }\n\n  function _callOptionalReturn(IERC20 token, bytes memory data) private returns (bool) {\n      // solhint-disable-next-line avoid-low-level-calls\n      (bool success, bytes memory returndata) = address(token).call(data);\n      if (!success) {\n          return false;\n      }\n\n      if (returndata.length >= 32) { // Return data is optional\n          return abi.decode(returndata, (bool));\n      }\n\n      // In a wierd case when return data is 1-31 bytes long - return false.\n      return returndata.length == 0;\n  }\n}\n"
    },
    "contracts/tests/TestVaultLifecycleSTETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {IWSTETH} from \"../interfaces/ISTETH.sol\";\nimport {VaultLifecycleSTETH} from \"../libraries/VaultLifecycleSTETH.sol\";\n\ncontract TestVaultLifecycleSTETH {\n    address constant wstETH = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;\n    address constant crvPool = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;\n\n    // To avoid using events to get the output, we just set it so we can read\n    // it off the contract\n    uint256 public output;\n\n    function unwrapYieldToken(uint256 amount, uint256 minETHOut) external {\n        uint256 amountETHOut =\n            VaultLifecycleSTETH.unwrapYieldToken(\n                amount,\n                wstETH,\n                IWSTETH(wstETH).stETH(),\n                crvPool,\n                minETHOut\n            );\n        output = amountETHOut;\n    }\n\n    // Enables test to send ETH for testing\n    receive() external payable {}\n}\n"
    },
    "contracts/utils/DeltaStrikeSelection.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {SafeMath} from \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport {\n    IPriceOracle\n} from \"@ribbon-finance/rvol/contracts/interfaces/IPriceOracle.sol\";\nimport {IOptionsPremiumPricer} from \"../interfaces/IRibbon.sol\";\nimport {\n    IVolatilityOracle\n} from \"@ribbon-finance/rvol/contracts/interfaces/IVolatilityOracle.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Vault} from \"../libraries/Vault.sol\";\n\ncontract DeltaStrikeSelection is Ownable {\n    using SafeMath for uint256;\n\n    /**\n     * Immutables\n     */\n    IOptionsPremiumPricer public immutable optionsPremiumPricer;\n\n    IVolatilityOracle public immutable volatilityOracle;\n\n    // delta for options strike price selection. 1 is 10000 (10**4)\n    uint256 public delta;\n\n    // step in absolute terms at which we will increment\n    // (ex: 100 * 10 ** assetOracleDecimals means we will move at increments of 100 points)\n    uint256 public step;\n\n    // multiplier to shift asset prices\n    uint256 private immutable assetOracleMultiplier;\n\n    // Delta are in 4 decimal places. 1 * 10**4 = 1 delta.\n    uint256 private constant DELTA_MULTIPLIER = 10**4;\n\n    // ChainLink's USD Price oracles return results in 8 decimal places\n    uint256 private constant ORACLE_PRICE_MULTIPLIER = 10**8;\n\n    event DeltaSet(uint256 oldDelta, uint256 newDelta, address indexed owner);\n    event StepSet(uint256 oldStep, uint256 newStep, address indexed owner);\n\n    constructor(\n        address _optionsPremiumPricer,\n        uint256 _delta,\n        uint256 _step\n    ) {\n        require(_optionsPremiumPricer != address(0), \"!_optionsPremiumPricer\");\n        require(_delta > 0, \"!_delta\");\n        require(_delta <= DELTA_MULTIPLIER, \"newDelta cannot be more than 1\");\n        require(_step > 0, \"!_step\");\n        optionsPremiumPricer = IOptionsPremiumPricer(_optionsPremiumPricer);\n        volatilityOracle = IVolatilityOracle(\n            IOptionsPremiumPricer(_optionsPremiumPricer).volatilityOracle()\n        );\n        // ex: delta = 7500 (.75)\n        delta = _delta;\n        uint256 _assetOracleMultiplier =\n            10 **\n                IPriceOracle(\n                    IOptionsPremiumPricer(_optionsPremiumPricer).priceOracle()\n                )\n                    .decimals();\n\n        // ex: step = 1000\n        step = _step.mul(_assetOracleMultiplier);\n\n        assetOracleMultiplier = _assetOracleMultiplier;\n    }\n\n    /**\n     * @notice Gets the strike price satisfying the delta value\n     * given the expiry timestamp and whether option is call or put\n     * @param expiryTimestamp is the unix timestamp of expiration\n     * @param isPut is whether option is put or call\n     * @return newStrikePrice is the strike price of the option (ex: for BTC might be 45000 * 10 ** 8)\n     * @return newDelta is the delta of the option given its parameters\n     */\n\n    function getStrikePrice(uint256 expiryTimestamp, bool isPut)\n        external\n        view\n        returns (uint256 newStrikePrice, uint256 newDelta)\n    {\n        require(\n            expiryTimestamp > block.timestamp,\n            \"Expiry must be in the future!\"\n        );\n\n        // asset price\n        uint256 assetPrice = optionsPremiumPricer.getUnderlyingPrice();\n\n        // asset's annualized volatility\n        uint256 annualizedVol =\n            volatilityOracle.annualizedVol(optionsPremiumPricer.pool()).mul(\n                10**10\n            );\n\n        // For each asset prices with step of 'step' (down if put, up if call)\n        //   if asset's getOptionDelta(currStrikePrice, spotPrice, annualizedVol, t) == (isPut ? 1 - delta:delta)\n        //   with certain margin of error\n        //        return strike price\n\n        uint256 strike =\n            isPut\n                ? assetPrice.sub(assetPrice % step).sub(step)\n                : assetPrice.add(step - (assetPrice % step)).add(step);\n        uint256 targetDelta = isPut ? DELTA_MULTIPLIER.sub(delta) : delta;\n        uint256 prevDelta = DELTA_MULTIPLIER;\n\n        while (true) {\n            uint256 currDelta =\n                optionsPremiumPricer.getOptionDelta(\n                    assetPrice.mul(ORACLE_PRICE_MULTIPLIER).div(\n                        assetOracleMultiplier\n                    ),\n                    strike,\n                    annualizedVol,\n                    expiryTimestamp\n                );\n            //  If the current delta is between the previous\n            //  strike price delta and current strike price delta\n            //  then we are done\n            bool foundTargetStrikePrice =\n                isPut\n                    ? targetDelta >= prevDelta && targetDelta <= currDelta\n                    : targetDelta <= prevDelta && targetDelta >= currDelta;\n\n            if (foundTargetStrikePrice) {\n                uint256 finalDelta =\n                    _getBestDelta(prevDelta, currDelta, targetDelta, isPut);\n                uint256 finalStrike =\n                    _getBestStrike(finalDelta, prevDelta, strike, isPut);\n                require(\n                    isPut\n                        ? finalStrike <= assetPrice\n                        : finalStrike >= assetPrice,\n                    \"Invalid strike price\"\n                );\n                // make decimals consistent with oToken strike price decimals (10 ** 8)\n                return (\n                    finalStrike.mul(ORACLE_PRICE_MULTIPLIER).div(\n                        assetOracleMultiplier\n                    ),\n                    finalDelta\n                );\n            }\n\n            strike = isPut ? strike.sub(step) : strike.add(step);\n\n            prevDelta = currDelta;\n        }\n    }\n\n    /**\n     * @notice Rounds to best delta value\n     * @param prevDelta is the delta of the previous strike price\n     * @param currDelta is delta of the current strike price\n     * @param targetDelta is the delta we are targeting\n     * @param isPut is whether its a put\n     * @return the best delta value\n     */\n    function _getBestDelta(\n        uint256 prevDelta,\n        uint256 currDelta,\n        uint256 targetDelta,\n        bool isPut\n    ) private pure returns (uint256) {\n        uint256 finalDelta;\n\n        // for tie breaks (ex: 0.05 <= 0.1 <= 0.15) round to higher strike price\n        // for calls and lower strike price for puts for deltas\n        if (isPut) {\n            uint256 upperBoundDiff = currDelta.sub(targetDelta);\n            uint256 lowerBoundDiff = targetDelta.sub(prevDelta);\n            finalDelta = lowerBoundDiff <= upperBoundDiff\n                ? prevDelta\n                : currDelta;\n        } else {\n            uint256 upperBoundDiff = prevDelta.sub(targetDelta);\n            uint256 lowerBoundDiff = targetDelta.sub(currDelta);\n            finalDelta = lowerBoundDiff <= upperBoundDiff\n                ? currDelta\n                : prevDelta;\n        }\n\n        return finalDelta;\n    }\n\n    /**\n     * @notice Rounds to best delta value\n     * @param finalDelta is the best delta value we found\n     * @param prevDelta is delta of the previous strike price\n     * @param strike is the strike of the previous iteration\n     * @param isPut is whether its a put\n     * @return the best strike\n     */\n    function _getBestStrike(\n        uint256 finalDelta,\n        uint256 prevDelta,\n        uint256 strike,\n        bool isPut\n    ) private view returns (uint256) {\n        if (finalDelta != prevDelta) {\n            return strike;\n        }\n        return isPut ? strike.add(step) : strike.sub(step);\n    }\n\n    /**\n     * @notice Sets new delta value\n     * @param newDelta is the new delta value\n     */\n    function setDelta(uint256 newDelta) external onlyOwner {\n        require(newDelta > 0, \"!newDelta\");\n        require(newDelta <= DELTA_MULTIPLIER, \"newDelta cannot be more than 1\");\n        uint256 oldDelta = delta;\n        delta = newDelta;\n        emit DeltaSet(oldDelta, newDelta, msg.sender);\n    }\n\n    /**\n     * @notice Sets new step value\n     * @param newStep is the new step value\n     */\n    function setStep(uint256 newStep) external onlyOwner {\n        require(newStep > 0, \"!newStep\");\n        uint256 oldStep = step;\n        step = newStep.mul(assetOracleMultiplier);\n        emit StepSet(oldStep, newStep, msg.sender);\n    }\n}\n"
    },
    "contracts/vendor/upgrades/UpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport './Proxy.sol';\nimport '@openzeppelin/contracts/utils/Address.sol';\n\n/**\n * @title UpgradeabilityProxy\n * @dev This contract implements a proxy that allows to change the\n * implementation address to which it will delegate.\n * Such a change is called an implementation upgrade.\n */\ncontract UpgradeabilityProxy is Proxy {\n  /**\n   * @dev Contract constructor.\n   * @param _logic Address of the initial implementation.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, bytes memory _data) payable {\n    assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1));\n    _setImplementation(_logic);\n    if(_data.length > 0) {\n      (bool success,) = _logic.delegatecall(_data);\n      require(success);\n    }\n  }\n\n  /**\n   * @dev Emitted when the implementation is upgraded.\n   * @param implementation Address of the new implementation.\n   */\n  event Upgraded(address indexed implementation);\n\n  /**\n   * @dev Storage slot with the address of the current implementation.\n   * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n  bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /**\n   * @dev Returns the current implementation.\n   * @return impl Address of the current implementation\n   */\n  function _implementation() internal override view returns (address impl) {\n    bytes32 slot = IMPLEMENTATION_SLOT;\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Upgrades the proxy to a new implementation.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _upgradeTo(address newImplementation) internal {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /**\n   * @dev Sets the implementation address of the proxy.\n   * @param newImplementation Address of the new implementation.\n   */\n  function _setImplementation(address newImplementation) internal {\n    require(Address.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\n\n    bytes32 slot = IMPLEMENTATION_SLOT;\n\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n"
    },
    "contracts/vendor/upgrades/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\n/**\n * @title Proxy\n * @dev Implements delegation of calls to other contracts, with proper\n * forwarding of return values and bubbling of failures.\n * It defines a fallback function that delegates all calls to the address\n * returned by the abstract _implementation() internal function.\n */\nabstract contract Proxy {\n  /**\n   * @dev Fallback function.\n   * Implemented entirely in `_fallback`.\n   */\n  fallback () payable external {\n    _fallback();\n  }\n\n  /**\n   * @dev Receive function.\n   * Implemented entirely in `_fallback`.\n   */\n  receive () payable external {\n    // _fallback();\n  }\n\n  /**\n   * @return The Address of the implementation.\n   */\n  function _implementation() internal virtual view returns (address);\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n   * This is a low level function that doesn't return to its internal call site.\n   * It will return to the external caller whatever the implementation returns.\n   * @param implementation Address to delegate.\n   */\n  function _delegate(address implementation) internal {\n    assembly {\n      // Copy msg.data. We take full control of memory in this inline assembly\n      // block because it will not return to Solidity code. We overwrite the\n      // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n      // Call the implementation.\n      // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n      // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 { revert(0, returndatasize()) }\n      default { return(0, returndatasize()) }\n    }\n  }\n\n  /**\n   * @dev Function that is run as the first thing in the fallback function.\n   * Can be redefined in derived contracts to add functionality.\n   * Redefinitions must call super._willFallback().\n   */\n  function _willFallback() internal virtual {\n  }\n\n  /**\n   * @dev fallback implementation.\n   * Extracted to enable manual triggering.\n   */\n  function _fallback() internal {\n    _willFallback();\n    _delegate(_implementation());\n  }\n}\n"
    },
    "contracts/vendor/upgrades/AdminUpgradeabilityProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.8;\n\nimport './UpgradeabilityProxy.sol';\n\n/**\n * @title AdminUpgradeabilityProxy\n * @dev This contract combines an upgradeability proxy with an authorization\n * mechanism for administrative tasks.\n * All external functions in this contract must be guarded by the\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\n * feature proposal that would enable this to be done automatically.\n */\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\n  /**\n   * Contract constructor.\n   * @param _logic address of the initial implementation.\n   * @param admin_ Address of the proxy administrator.\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\n   */\n  constructor(address _logic, address admin_, bytes memory _data) UpgradeabilityProxy(_logic, _data) payable {\n    assert(ADMIN_SLOT == bytes32(uint256(keccak256('eip1967.proxy.admin')) - 1));\n    _setAdmin(admin_);\n  }\n\n  /**\n   * @dev Emitted when the administration has been transferred.\n   * @param previousAdmin Address of the previous admin.\n   * @param newAdmin Address of the new admin.\n   */\n  event AdminChanged(address previousAdmin, address newAdmin);\n\n  /**\n   * @dev Storage slot with the admin of the contract.\n   * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n   * validated in the constructor.\n   */\n\n  bytes32 internal constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  /**\n   * @dev Modifier to check whether the `msg.sender` is the admin.\n   * If it is, it will run the function. Otherwise, it will delegate the call\n   * to the implementation.\n   */\n  modifier ifAdmin() {\n    if (msg.sender == _admin()) {\n      _;\n    } else {\n      _fallback();\n    }\n  }\n\n  /**\n   * @return adminAddress The address of the proxy admin.\n   */\n  function admin() external ifAdmin returns (address adminAddress) {\n    return _admin();\n  }\n\n  /**\n   * @return implementationAddress The address of the implementation.\n   */\n  function implementation() external ifAdmin returns (address implementationAddress) {\n    return _implementation();\n  }\n\n  /**\n   * @dev Changes the admin of the proxy.\n   * Only the current admin can call this function.\n   * @param newAdmin Address to transfer proxy administration to.\n   */\n  function changeAdmin(address newAdmin) external ifAdmin {\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\n    emit AdminChanged(_admin(), newAdmin);\n    _setAdmin(newAdmin);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy.\n   * Only the admin can call this function.\n   * @param newImplementation Address of the new implementation.\n   */\n  function upgradeTo(address newImplementation) external ifAdmin {\n    _upgradeTo(newImplementation);\n  }\n\n  /**\n   * @dev Upgrade the backing implementation of the proxy and call a function\n   * on the new implementation.\n   * This is useful to initialize the proxied contract.\n   * @param newImplementation Address of the new implementation.\n   * @param data Data to send as msg.data in the low level call.\n   * It should include the signature and the parameters of the function to be called, as described in\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\n   */\n  function upgradeToAndCall(address newImplementation, bytes calldata data) payable external ifAdmin {\n    _upgradeTo(newImplementation);\n    (bool success,) = newImplementation.delegatecall(data);\n    require(success);\n  }\n\n  /**\n   * @return adm The admin slot.\n   */\n  function _admin() internal view returns (address adm) {\n    bytes32 slot = ADMIN_SLOT;\n    assembly {\n      adm := sload(slot)\n    }\n  }\n\n  /**\n   * @dev Sets the address of the proxy admin.\n   * @param newAdmin Address of the new proxy admin.\n   */\n  function _setAdmin(address newAdmin) internal {\n    bytes32 slot = ADMIN_SLOT;\n\n    assembly {\n      sstore(slot, newAdmin)\n    }\n  }\n\n  /**\n   * @dev Only fall back when the sender is not the admin.\n   */\n  function _willFallback() internal override virtual {\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\n    super._willFallback();\n  }\n}\n"
    },
    "contracts/tests/TestVaultLifecycle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {VaultLifecycle} from \"../libraries/VaultLifecycle.sol\";\nimport {Vault} from \"../libraries/Vault.sol\";\n\ncontract TestVaultLifecycle {\n    Vault.VaultState public vaultState;\n\n    function getNextFriday(uint256 currentExpiry)\n        external\n        pure\n        returns (uint256 nextFriday)\n    {\n        return VaultLifecycle.getNextFriday(currentExpiry);\n    }\n\n    function getNextExpiry(address currentOption)\n        external\n        view\n        returns (uint256 nextExpiry)\n    {\n        return VaultLifecycle.getNextExpiry(currentOption);\n    }\n\n    function balanceOf(address account) public view returns (uint256) {\n        if (account == address(this)) {\n            return 1 ether;\n        }\n        return 0;\n    }\n\n    function setVaultState(Vault.VaultState calldata newVaultState) public {\n        vaultState.totalPending = newVaultState.totalPending;\n        vaultState.queuedWithdrawShares = newVaultState.queuedWithdrawShares;\n    }\n\n    function rollover(VaultLifecycle.RolloverParams calldata params)\n        external\n        view\n        returns (\n            uint256 newLockedAmount,\n            uint256 queuedWithdrawAmount,\n            uint256 newPricePerShare,\n            uint256 mintShares,\n            uint256 performanceFeeInAsset,\n            uint256 totalVaultFee\n        )\n    {\n        return VaultLifecycle.rollover(vaultState, params);\n    }\n}\n"
    },
    "contracts/tests/TestShareMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.4;\n\nimport {ShareMath} from \"../libraries/ShareMath.sol\";\n\ncontract TestShareMath {\n    function assetToShares(\n        uint256 assetAmount,\n        uint256 pps,\n        uint256 decimals\n    ) external pure returns (uint256) {\n        return ShareMath.assetToShares(assetAmount, pps, decimals);\n    }\n\n    function sharesToAsset(\n        uint256 shares,\n        uint256 pps,\n        uint256 decimals\n    ) external pure returns (uint256) {\n        return ShareMath.sharesToAsset(shares, pps, decimals);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}